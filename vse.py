
#!/usr/bin/env python3
"""
Visual Scenario Editor (VSE) for CARLA Simulator
================================================

This script provides an interactive graphical tool for creating, editing, and
visualizing driving scenarios on CARLA simulator maps.

Features:
- Top-down map viewer with panning and zooming
- Vehicle spawning and management
- Waypoint creation, editing, and deletion for scenario paths
- Undo/redo system for all major actions
- Scenario saving/loading to JSON files
- OpenDRIVE lane overlay visualization
- Scenario Runner integration for testing scenarios
- UI overlays for vehicle selection, action menus, and property editing

TABLE OF CONTENTS
-----------------
Line ~35:    MODULE METADATA & IMPORTS
Line ~117:   TOOLTIP SYSTEM - Hover tooltips for UI elements
Line ~300:   CONNECTION PROFILES - Remote/local CARLA connection settings
Line ~407:   UTILITY FUNCTIONS - Coordinate detection, raycast, math helpers
Line ~813:   DATA MODELS & CLONE HELPERS - State copying for undo/redo
Line ~870:   OVERLAY RENDERER HELPERS - Waypoint/trigger/OpenDRIVE rendering
Line ~1804:  COMMAND PATTERN CLASSES - Undo/redo system implementation
Line ~3108:  WORLD COORDINATE UTILITIES - Screen-to-world transforms
Line ~3763:  CARLA SERVER MANAGEMENT - Server start/stop/detection
Line ~4114:  CARLA SERVER & CONNECTION MANAGEMENT - Client connection handling
Line ~4250:  CAMERA & IMAGE PROCESSING - CameraImageProcessor class (~5000 lines)
Line ~13424: UI CLASSES - Selection menus, info panel, dialogs
Line ~17478: MAIN EDITOR CLASS - VisualScenarioEditor (~9000 lines)
Line ~26821: ENTRY POINT - main() function

Usage:
- Run: python vse.py [--debug] [--port PORT] [--carla-path PATH]
- Press F3 in editor to toggle raycast debugging
- See docs/vse_user_manual.md for full documentation

Dependencies:
- CARLA Python API
- Pygame, pygame_gui
- Numpy

Author: ADL
Date: 2026
"""


############################################################
# Module Metadata & Imports
############################################################

import sys
import argparse
import pygame
import numpy as np
import math
import time
import weakref
import subprocess
import os
import faulthandler
import signal
import threading
import queue
import atexit
import socket
import json
import select
import warnings
import locale
import html
import hashlib
import re
import random
import traceback
import gc
import shutil
import copy
import logging
from collections import deque
from enum import Enum
from pathlib import Path
from typing import Optional, List, Dict, Union, TypedDict, cast, Tuple, Set, Callable, Iterable, Deque
from dataclasses import dataclass, field

from pygame_gui import UIManager
from pygame_gui._constants import (
    UI_FILE_DIALOG_PATH_PICKED,
    UI_CONFIRMATION_DIALOG_CONFIRMED,
    UI_WINDOW_CLOSE,
    UI_SELECTION_LIST_NEW_SELECTION,
    UI_SELECTION_LIST_DOUBLE_CLICKED_SELECTION,
    UI_BUTTON_PRESSED,
    UI_TEXT_ENTRY_FINISHED,
    UI_HORIZONTAL_SLIDER_MOVED,
)
from pygame_gui.windows.ui_confirmation_dialog import UIConfirmationDialog
from pygame_gui.windows.ui_file_dialog import UIFileDialog
from pygame_gui.elements.ui_window import UIWindow
from pygame_gui.elements.ui_button import UIButton
from pygame_gui.elements.ui_selection_list import UISelectionList
from pygame_gui.elements.ui_text_entry_line import UITextEntryLine
from pygame_gui.elements.ui_label import UILabel
from pygame_gui.elements.ui_horizontal_slider import UIHorizontalSlider
from pygame_gui.elements.ui_text_box import UITextBox

# Suppress noisy pygame_gui label size warnings while retaining existing layout.
warnings.filterwarnings(
    "ignore",
    message="Label Rect is too small for text:",
)
warnings.filterwarnings(
    "ignore",
    message="Pygame GUI event types can now be used directly as event.type",
    category=DeprecationWarning,
)


# Import CARLA
try:
    import carla
    from carla import ColorConverter as cc
except ImportError:
    print("CARLA Python API not found. Please add CARLA to your PYTHONPATH.")
    print("Example: export PYTHONPATH=$PYTHONPATH:/path/to/carla/PythonAPI/carla/dist/carla-0.9.15-py3.7-linux-x86_64.egg")
    sys.exit(1)

# Module-level logger for vse
logger = logging.getLogger(__name__)


############################################################
# Tooltip System
############################################################


class TooltipManager:
    """
    Unified tooltip system for the Visual Scenario Editor.
    Tracks hover state across all UI elements and renders tooltips with configurable delay.
    """

    DELAY_MS = 500  # Milliseconds before tooltip appears
    BACKGROUND_COLOR = (50, 50, 50, 230)  # Semi-transparent dark gray
    BORDER_COLOR = (150, 150, 150)  # Light gray border
    TEXT_COLOR = (255, 255, 255)  # White text
    PADDING = 6  # Padding around text
    BORDER_WIDTH = 1  # Border thickness
    VERTICAL_OFFSET = 6  # Gap between element and tooltip

    def __init__(self, screen_width: int, screen_height: int):
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.font: Optional[pygame.font.Font] = None  # Initialized lazily

        # Hover tracking state
        self._current_element_id: Optional[str] = None
        self._hover_start_time: Optional[float] = None
        self._element_rect: Optional[pygame.Rect] = None
        self._tooltip_text: str = ""
        self._visible = False

        # Frame-based tracking to handle clear/register cycle
        self._frame_element_id: Optional[str] = None
        self._frame_element_rect: Optional[pygame.Rect] = None
        self._frame_tooltip_text: str = ""

    def _get_font(self) -> pygame.font.Font:
        """Lazily initialize font (pygame must be initialized first)."""
        if self.font is None:
            self.font = pygame.font.Font(None, 18)
        return self.font

    def update_screen_size(self, width: int, height: int) -> None:
        """Update screen dimensions for boundary checking."""
        self.screen_width = width
        self.screen_height = height

    def register_hover(
        self,
        element_id: str,
        element_rect: pygame.Rect,
        tooltip_text: str,
    ) -> None:
        """
        Register that the mouse is hovering over an element.
        Call this for each hovered element during the render loop.
        """
        if not tooltip_text:
            return

        # Store what's being hovered THIS frame
        self._frame_element_id = element_id
        self._frame_element_rect = element_rect
        self._frame_tooltip_text = tooltip_text

    def clear_hover(self) -> None:
        """Reset frame state at the start of each frame."""
        self._frame_element_id = None
        self._frame_element_rect = None
        self._frame_tooltip_text = ""

    def update(self) -> None:
        """Update tooltip visibility based on hover duration."""
        # Compare this frame's hover to the tracked element
        if self._frame_element_id is None:
            # Nothing hovered this frame - clear state
            self._current_element_id = None
            self._hover_start_time = None
            self._element_rect = None
            self._tooltip_text = ""
            self._visible = False
            return

        if self._frame_element_id != self._current_element_id:
            # Switched to a new element - reset timer
            self._current_element_id = self._frame_element_id
            self._hover_start_time = time.time()
            self._visible = False

        # Update rect and text from this frame
        self._element_rect = self._frame_element_rect
        self._tooltip_text = self._frame_tooltip_text

        # Check if delay has passed
        if self._hover_start_time is not None:
            elapsed_ms = (time.time() - self._hover_start_time) * 1000
            self._visible = elapsed_ms >= self.DELAY_MS

    def render(self, screen: pygame.Surface) -> None:
        """Render the tooltip if visible."""
        if not self._visible or not self._tooltip_text or not self._element_rect:
            return

        font = self._get_font()
        text_surface = font.render(self._tooltip_text, True, self.TEXT_COLOR)
        text_width = text_surface.get_width()
        text_height = text_surface.get_height()

        # Calculate tooltip dimensions
        tooltip_width = text_width + self.PADDING * 2
        tooltip_height = text_height + self.PADDING * 2

        # Position tooltip ABOVE the element
        tooltip_x = self._element_rect.centerx - tooltip_width // 2
        tooltip_y = self._element_rect.top - tooltip_height - self.VERTICAL_OFFSET

        # Boundary checking - keep tooltip on screen
        tooltip_x = max(4, min(tooltip_x, self.screen_width - tooltip_width - 4))

        # If tooltip would go off top of screen, position below element instead
        if tooltip_y < 4:
            tooltip_y = self._element_rect.bottom + self.VERTICAL_OFFSET

        # Final vertical clamping
        tooltip_y = max(4, min(tooltip_y, self.screen_height - tooltip_height - 4))

        # Create tooltip rectangle
        tooltip_rect = pygame.Rect(tooltip_x, tooltip_y, tooltip_width, tooltip_height)

        # Draw background with alpha
        tooltip_surface = pygame.Surface((tooltip_width, tooltip_height), pygame.SRCALPHA)
        tooltip_surface.fill(self.BACKGROUND_COLOR)
        screen.blit(tooltip_surface, tooltip_rect.topleft)

        # Draw border
        pygame.draw.rect(screen, self.BORDER_COLOR, tooltip_rect, self.BORDER_WIDTH)

        # Draw text
        text_x = tooltip_x + self.PADDING
        text_y = tooltip_y + self.PADDING
        screen.blit(text_surface, (text_x, text_y))


# Tooltip text dictionaries for various UI elements
OVERLAY_ICON_TOOLTIPS: Dict[str, str] = {
    'delete': "Delete (Del)",
    'move': "Move",
    'rotate': "Rotate",
    'waypoint': "Add/Edit Waypoints",
    'autoroute': "Auto-route to Destination",
    'ego_destination': "Set Ego Destination",
    'scale': "Adjust Trigger Radius",
    'add_trigger': "Add Trigger",
    'remove_trigger': "Remove Trigger",
}

INFO_PANEL_BUTTON_TOOLTIPS: Dict[str, str] = {
    'add_traffic_light_step': "Add a new sequence step",
    'clear_traffic_light_steps': "Remove all sequence steps",
}

TOP_UI_BUTTON_TOOLTIPS: Dict[str, str] = {
    'map': "Change Map",
    'connection': "Switch Connection Mode",
    'resolution': "Change Resolution",
    'fps': "Adjust Frame Rate",
    'manual_tick': "Toggle Drive Clock",
    'scenario': "Scenario Menu",
    'play': "Start Playback",
    'stop': "Stop Playback",
    'agent': "Set Autopilot Agent",
    'weather': "Weather Controls",
}

MODE_BUTTON_TOOLTIPS: Dict[str, str] = {
    'VEHICLE': "Spawn NPC Vehicles",
    'PEDESTRIAN': "Spawn Pedestrians",
    'EGO': "Spawn Ego Vehicle",
    'TRIGGER': "Place/Edit Triggers",
}


############################################################
# Connection Profiles
############################################################


@dataclass
class ConnectionProfile:
    """Describe how VSE should talk to a CARLA server."""

    name: str
    host: str
    port: int
    manage_server: bool
    display_name: str
    description: str = ""
    map_hint: Optional[str] = None

    @property
    def is_remote(self) -> bool:
        return not self.manage_server


@dataclass(frozen=True)
class WeatherParameterSpec:
    """Describe a single adjustable weather parameter."""

    name: str
    display_name: str
    min_value: float
    max_value: float
    step: float
    decimals: int = 1


WEATHER_PARAMETER_SPECS: Tuple[WeatherParameterSpec, ...] = (
    WeatherParameterSpec("cloudiness", "Cloudiness", 0.0, 100.0, 1.0),
    WeatherParameterSpec("precipitation", "Precipitation", 0.0, 100.0, 1.0),
    WeatherParameterSpec("precipitation_deposits", "Precipitation Deposits", 0.0, 100.0, 1.0),
    WeatherParameterSpec("wind_intensity", "Wind Intensity", 0.0, 100.0, 1.0),
    WeatherParameterSpec("sun_azimuth_angle", "Sun Azimuth (°)", 0.0, 360.0, 1.0, 0),
    WeatherParameterSpec("sun_altitude_angle", "Sun Altitude (°)", -90.0, 90.0, 1.0, 1),
    WeatherParameterSpec("fog_density", "Fog Density", 0.0, 100.0, 1.0),
    WeatherParameterSpec("fog_distance", "Fog Distance (m)", 0.0, 500.0, 5.0, 0),
    WeatherParameterSpec("fog_falloff", "Fog Falloff", 0.0, 5.0, 0.05, 2),
    WeatherParameterSpec("wetness", "Wetness", 0.0, 100.0, 1.0),
    WeatherParameterSpec("scattering_intensity", "Scattering Intensity", 0.0, 100.0, 1.0),
    WeatherParameterSpec("mie_scattering_scale", "Mie Scattering Scale", 0.0, 1.0, 0.01, 2),
    WeatherParameterSpec("rayleigh_scattering_scale", "Rayleigh Scattering Scale", 0.0, 1.0, 0.001, 3),
    WeatherParameterSpec("dust_storm", "Dust Storm", 0.0, 100.0, 1.0),
)

REMOTE_STREAM_RESOLUTIONS: Tuple[Tuple[int, int], ...] = (
    (320, 180),
    (480, 270),
    (640, 360),
    (800, 450),
    (960, 540),
    (1280, 720),
    (1600, 900),
    (1920, 1080),
    (2560, 1440),
)

_WALKER_COLOR_PALETTE: List[Tuple[int, int, int]] = [
    (0, 255, 0),
    (0, 0, 255),
    (255, 255, 0),
    (255, 0, 255),
    (0, 255, 255),
    (255, 165, 0),
    (255, 105, 180),
]

NO_CAMERA_STREAM_RESOLUTIONS: Tuple[Tuple[int, int], ...] = (
    (1, 1),   # Try a 1x1 placeholder feed first to keep integrations alive
    (2, 2),   # Fallback if CARLA rejects the tiny resolution
)


@dataclass
class TrafficLightGroupData:
    """Bundle multiple overlapping traffic lights into a single selectable unit."""

    lights: List[carla.TrafficLight]
    ids: Set[int]
    reference_ids: Optional[Set[int]] = None
    location_fingerprint: Optional[Tuple[Tuple[int, int, int], ...]] = None
    center_location: Optional[Tuple[float, float, float]] = None
    screen_polygon: Optional[List[Tuple[float, float]]] = None
    screen_center: Optional[Tuple[float, float]] = None
    trigger_center: Optional[Dict[str, float]] = None
    trigger_radius: Optional[float] = None
    sequence: List[Dict[str, Union[str, float, int]]] = field(default_factory=list)
    cached_size: int = 0

    @property
    def reference_light(self) -> Optional[carla.TrafficLight]:
        return self.lights[0] if self.lights else None

    def has_trigger(self) -> bool:
        return self.trigger_center is not None and self.trigger_radius is not None

TRAFFIC_LIGHT_FINGERPRINT_SCALE = 4.0  # Quantize to ~0.25m resolution for matching stability
TRAFFIC_LIGHT_CENTROID_MATCH_THRESHOLD = 2.0  # Max distance (m) to treat centroids as identical
DEFAULT_PERSONAL_TRIGGER_RADIUS = 2.0
MIN_PERSONAL_TRIGGER_RADIUS = DEFAULT_PERSONAL_TRIGGER_RADIUS

############################################################
# Utility Functions
############################################################

def is_shift_pressed(keys=None):
    """Return True if either Shift key is currently pressed."""
    keys = pygame.key.get_pressed() if keys is None else keys
    return keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]


def is_ctrl_pressed(keys=None):
    """Return True if either Ctrl key is currently pressed."""
    keys = pygame.key.get_pressed() if keys is None else keys
    return keys[pygame.K_LCTRL] or keys[pygame.K_RCTRL]


def is_large_map_name(map_name: Optional[str]) -> bool:
    """Heuristic detection for CARLA large maps (streamed tiles)."""
    if os.environ.get("VSE_FORCE_LARGE_MAP") == "1":
        return True
    try:
        name = str(map_name or "").lower()
    except Exception:
        return False
    return "large" in name


# CARLA large-map raycast note:
# Some large maps (composed of streamed tiles) can produce `world.cast_ray()` hits in a
# tile-local XY frame. This manifests as hit locations that do not lie on the input ray
# segment (often an XY translation of ~hundreds of meters, e.g. +/-250m). VSE compensates
# by detecting the mismatch and re-casting the ray with an inferred XY offset.
_RAYCAST_TILE_OFFSET_GUESS: Tuple[float, float] = (0.0, 0.0)


def _shift_location_xy(location: carla.Location, dx: float, dy: float) -> carla.Location:
    return carla.Location(float(location.x) + float(dx), float(location.y) + float(dy), float(location.z))


def _compute_expected_xy_on_ray_at_z(
    ray_start: carla.Location,
    ray_end: carla.Location,
    hit_z: float,
) -> Optional[Tuple[float, float, float]]:
    dz = float(ray_end.z) - float(ray_start.z)
    if abs(dz) <= 1e-6:
        return None
    t = (float(hit_z) - float(ray_start.z)) / dz
    x = float(ray_start.x) + (float(ray_end.x) - float(ray_start.x)) * t
    y = float(ray_start.y) + (float(ray_end.y) - float(ray_start.y)) * t
    return x, y, t


def cast_ray_with_tile_offset_compensation(
    world: carla.World,
    ray_start: carla.Location,
    ray_end: carla.Location,
    *,
    cached_map: Optional[carla.Map] = None,
    probe_on_miss: bool = True,
    debug: bool = False,
) -> Tuple[List[object], Dict[str, object]]:
    """
    Cast a ray with automatic compensation for CARLA large-map tile XY offsets.

    Returns a tuple ``(hits, meta)`` where ``hits`` is the same list as returned by
    ``world.cast_ray`` and ``meta`` includes information about any correction:
      - offset_guess_xy: (dx, dy) used for the accepted cast
      - corrected: bool
      - attempts: int
      - misalignment_m: float (distance from hit XY to expected XY on the ray)
    """
    global _RAYCAST_TILE_OFFSET_GUESS

    map_name = getattr(cached_map, 'name', None) or '<unknown>'
    base_offset = _RAYCAST_TILE_OFFSET_GUESS

    def _cast(dx: float, dy: float) -> List[object]:
        return world.cast_ray(_shift_location_xy(ray_start, dx, dy), _shift_location_xy(ray_end, dx, dy))

    def _measure(hit_location: carla.Location) -> Optional[Tuple[float, float, float]]:
        expected = _compute_expected_xy_on_ray_at_z(ray_start, ray_end, float(hit_location.z))
        if expected is None:
            return None
        expected_x, expected_y, _t = expected
        dx = expected_x - float(hit_location.x)
        dy = expected_y - float(hit_location.y)
        return dx, dy, math.hypot(dx, dy)

    def _offset_key(dx: float, dy: float) -> Tuple[int, int]:
        return int(round(float(dx))), int(round(float(dy)))

    attempts = 0
    attempted_offsets: Set[Tuple[int, int]] = set()

    accept_threshold_m = 1.0
    recast_threshold_m = 5.0

    def _attempt_offset(guess_dx: float, guess_dy: float) -> Optional[Tuple[List[object], Dict[str, object]]]:
        nonlocal attempts
        global _RAYCAST_TILE_OFFSET_GUESS

        key = _offset_key(guess_dx, guess_dy)
        if key in attempted_offsets:
            return None
        attempted_offsets.add(key)

        attempts += 1
        hits = _cast(guess_dx, guess_dy)
        if not hits:
            return None

        hit = hits[0]
        measurement = _measure(hit.location)
        if measurement is None:
            accepted_offset = (guess_dx, guess_dy)
            corrected = abs(guess_dx) > 1e-6 or abs(guess_dy) > 1e-6
            _RAYCAST_TILE_OFFSET_GUESS = accepted_offset
            return hits, {
                'map_name': map_name,
                'offset_guess_xy': accepted_offset,
                'corrected': corrected,
                'attempts': attempts,
                'misalignment_m': 0.0,
            }

        corr_dx, corr_dy, misalignment = measurement
        misalignment_m = float(misalignment)
        if misalignment_m <= accept_threshold_m:
            accepted_offset = (guess_dx, guess_dy)
            corrected = abs(guess_dx) > 1e-6 or abs(guess_dy) > 1e-6
            _RAYCAST_TILE_OFFSET_GUESS = accepted_offset
            return hits, {
                'map_name': map_name,
                'offset_guess_xy': accepted_offset,
                'corrected': corrected,
                'attempts': attempts,
                'misalignment_m': misalignment_m,
            }

        if misalignment_m < recast_threshold_m:
            return None

        inferred_dx = float(guess_dx) + float(corr_dx)
        inferred_dy = float(guess_dy) + float(corr_dy)

        key2 = _offset_key(inferred_dx, inferred_dy)
        if key2 in attempted_offsets:
            return None
        attempted_offsets.add(key2)

        attempts += 1
        hits2 = _cast(inferred_dx, inferred_dy)
        if not hits2:
            if debug:
                print(
                    f"[Raycast] Tile offset compensation failed (map={map_name}) "
                    f"guess=({guess_dx:.2f},{guess_dy:.2f}) inferred=({inferred_dx:.2f},{inferred_dy:.2f}) "
                    f"misalign={misalignment_m:.2f}m"
                )
            return None

        hit2 = hits2[0]
        measurement2 = _measure(hit2.location)
        if measurement2 is None:
            accepted_offset = (inferred_dx, inferred_dy)
            _RAYCAST_TILE_OFFSET_GUESS = accepted_offset
            if debug:
                print(
                    f"[Raycast] Tile offset compensation accepted (map={map_name}) "
                    f"offset=({accepted_offset[0]:.2f},{accepted_offset[1]:.2f})"
                )
            return hits2, {
                'map_name': map_name,
                'offset_guess_xy': accepted_offset,
                'corrected': True,
                'attempts': attempts,
                'misalignment_m': misalignment_m,
            }

        _, _, misalignment2 = measurement2
        if float(misalignment2) <= accept_threshold_m:
            accepted_offset = (inferred_dx, inferred_dy)
            _RAYCAST_TILE_OFFSET_GUESS = accepted_offset
            if debug:
                print(
                    f"[Raycast] Tile offset compensation accepted (map={map_name}) "
                    f"offset=({accepted_offset[0]:.2f},{accepted_offset[1]:.2f}) "
                    f"misalign={float(misalignment2):.2f}m attempts={attempts}"
                )
            return hits2, {
                'map_name': map_name,
                'offset_guess_xy': accepted_offset,
                'corrected': True,
                'attempts': attempts,
                'misalignment_m': float(misalignment2),
            }

        if debug:
            print(
                f"[Raycast] Tile offset compensation failed (map={map_name}) "
                f"guess=({guess_dx:.2f},{guess_dy:.2f}) inferred=({inferred_dx:.2f},{inferred_dy:.2f}) "
                f"misalign={misalignment_m:.2f}m"
            )

        return None

    offsets_to_try: List[Tuple[float, float]] = []
    if abs(base_offset[0]) > 1e-6 or abs(base_offset[1]) > 1e-6:
        offsets_to_try.append(base_offset)
    offsets_to_try.append((0.0, 0.0))

    for guess_dx, guess_dy in offsets_to_try:
        result = _attempt_offset(guess_dx, guess_dy)
        if result is not None:
            return result

    def _gcd_step_from_offset(offset: Tuple[float, float]) -> int:
        dx = int(round(abs(float(offset[0]))))
        dy = int(round(abs(float(offset[1]))))
        if dx == 0 and dy == 0:
            return 0
        step = math.gcd(dx, dy)
        return step if step > 0 else (dx or dy)

    # If we got no hits at all, we likely need a different tile-origin offset (e.g., Town11/Town12).
    # Probing can be expensive, so callers may disable it (e.g., for camera navigation); the mismatch-based
    # correction above still applies whenever we get a hit.
    if not probe_on_miss:
        return [], {
            'map_name': map_name,
            'offset_guess_xy': (0.0, 0.0),
            'corrected': False,
            'attempts': attempts,
            'misalignment_m': 0.0,
        }

    # Probe a small grid of candidate offsets to find any hit, then the usual mismatch logic will infer the exact offset.
    base_step = _gcd_step_from_offset(base_offset)
    candidate_steps: List[int] = []
    for step in (base_step, 1000, 2000, 250, 500):
        if step and step not in candidate_steps:
            candidate_steps.append(step)

    # Fast-path guess: for streaming large maps, the correct tile-origin shift is often close to a rounded
    # multiple of a common step size (e.g., 1000m/2000m). Try a small set of quantized offsets first to
    # avoid a full grid scan.
    ref_x = float(ray_start.x)
    ref_y = float(ray_start.y)
    for step in candidate_steps:
        step_f = float(step)
        if step_f <= 0:
            continue

        def _quantized_choices(v: float) -> List[float]:
            q = v / step_f
            return sorted({
                -math.floor(q) * step_f,
                -math.ceil(q) * step_f,
                -round(q) * step_f,
            })

        for qdx in _quantized_choices(ref_x):
            for qdy in _quantized_choices(ref_y):
                if abs(qdx) > 20000.0 or abs(qdy) > 20000.0:
                    continue
                result = _attempt_offset(qdx, qdy)
                if result is not None:
                    return result

    candidate_centers: List[Tuple[float, float]] = []
    if abs(base_offset[0]) > 1e-6 or abs(base_offset[1]) > 1e-6:
        candidate_centers.append(base_offset)
    candidate_centers.append((0.0, 0.0))

    radius_steps = 8
    max_abs_offset_m = 20000.0
    index_pairs = [(ix, iy) for ix in range(-radius_steps, radius_steps + 1) for iy in range(-radius_steps, radius_steps + 1)]
    index_pairs.sort(key=lambda pair: (max(abs(pair[0]), abs(pair[1])), abs(pair[0]) + abs(pair[1])))
    for center_dx, center_dy in candidate_centers:
        for step in candidate_steps:
            step_f = float(step)
            for ix, iy in index_pairs:
                probe_dx = float(center_dx) + float(ix) * step_f
                probe_dy = float(center_dy) + float(iy) * step_f
                if abs(probe_dx) > max_abs_offset_m or abs(probe_dy) > max_abs_offset_m:
                    continue
                result = _attempt_offset(probe_dx, probe_dy)
                if result is not None:
                    if debug and (abs(float(probe_dx)) > 1e-6 or abs(float(probe_dy)) > 1e-6):
                        print(
                            f"[Raycast] Tile offset probe accepted (map={map_name}) "
                            f"probe=({probe_dx:.0f},{probe_dy:.0f}) attempts={attempts}"
                        )
                    return result

    return [], {
        'map_name': map_name,
        'offset_guess_xy': (0.0, 0.0),
        'corrected': False,
        'attempts': attempts,
        'misalignment_m': 0.0,
    }


def get_ground_height(world, location, debug=False, cached_map=None, *, return_metadata=False, probe_on_miss=True):
    """
    Get the actual ground height at a location using raycast.
    Tries raycasting first, then falls back to waypoint height, then original Z if all else fails.

    For large maps with tiles, automatically detects and compensates for tile-local coordinate offsets.

    Args:
        world: CARLA world object
        location: carla.Location to check
        debug: bool - Enable debug logging for coordinate testing (default False)
        probe_on_miss: bool - Whether to probe grid of offsets when raycast misses (default True, can be slow on large maps)
    Returns:
        float: Detected ground height (Z coordinate)
    """
    try:
        # Cast a ray from high above down to the ground, covering elevated actors
        vertical_buffer_up = 200.0
        vertical_search_down = max(400.0, abs(location.z) + 200.0)
        start_location = carla.Location(
            location.x,
            location.y,
            location.z + vertical_buffer_up,
        )
        end_location = carla.Location(
            location.x,
            location.y,
            location.z - vertical_search_down,
        )

        # Perform raycast to detect ground
        raycast_result, raycast_meta = cast_ray_with_tile_offset_compensation(
            world,
            start_location,
            end_location,
            cached_map=cached_map,
            probe_on_miss=probe_on_miss,
            debug=debug,
        )

        if raycast_result:
            # Found ground, use that height directly
            hit = raycast_result[0]

            ground_height = hit.location.z

            if debug:
                offset_guess = raycast_meta.get('offset_guess_xy', (0.0, 0.0))
                corrected = bool(raycast_meta.get('corrected', False))
                attempts = int(raycast_meta.get('attempts', 0) or 0)
                misalignment = float(raycast_meta.get('misalignment_m', 0.0) or 0.0)

                print(f"\n{'='*60}")
                print("RAYCAST DEBUG - Ground Height Sample")
                print(f"{'='*60}")
                print(f"Map name: {raycast_meta.get('map_name', '<unknown>')}")
                print(f"Input location (X, Y, Z): ({location.x:.2f}, {location.y:.2f}, {location.z:.2f})")
                print(f"Ray start (X, Y, Z):      ({start_location.x:.2f}, {start_location.y:.2f}, {start_location.z:.2f})")
                print(f"Ray end (X, Y, Z):        ({end_location.x:.2f}, {end_location.y:.2f}, {end_location.z:.2f})")
                print(f"Hit location (X, Y, Z):   ({hit.location.x:.2f}, {hit.location.y:.2f}, {hit.location.z:.2f})")
                print(f"Hit label: {hit.label}")
                print(f"Ground height: {ground_height:.2f}")
                print(f"Tile compensation: {'YES' if corrected else 'no'}")
                print(f"Offset guess (dx, dy): ({float(offset_guess[0]):.2f}, {float(offset_guess[1]):.2f})")
                print(f"Misalignment (m): {misalignment:.2f} (attempts={attempts})")
                print(f"{'='*60}\n")

            result = {'height': ground_height, 'source': 'raycast', 'raycast_meta': raycast_meta}
            return result if return_metadata else ground_height
        else:
            # No ground found, try to use waypoint height (project to road) if map data is available
            waypoint = None
            if cached_map is not None:
                try:
                    waypoint = cached_map.get_waypoint(location, project_to_road=True)
                except Exception as e:
                    if debug:
                        print(f"[DEBUG] Waypoint lookup failed: {e}")
                    waypoint = None
            if waypoint:
                waypoint_height = waypoint.transform.location.z
                if debug:
                    print(f"[DEBUG] Raycast failed, using waypoint height: {waypoint_height:.2f}")
                result = {'height': waypoint_height, 'source': 'waypoint'}
                return result if return_metadata else waypoint_height

            # Fallback to original height if all else fails
            fallback_height = location.z
            if debug:
                print(f"[DEBUG] Raycast and waypoint failed, using original Z: {fallback_height:.2f}")
            result = {'height': fallback_height, 'source': 'fallback'}
            return result if return_metadata else fallback_height

    except Exception as e:
        # On error, fallback to original Z
        if debug:
            print(f"[DEBUG ERROR] Exception in get_ground_height: {e}")
        fallback_height = location.z
        result = {'height': fallback_height, 'source': 'fallback'}
        return result if return_metadata else fallback_height

############################################################
# Data Models & Clone Helpers
############################################################

WaypointIndex = Union[int, str]


class WaypointDataRequired(TypedDict):
    x: float
    y: float
    z: float
    index: WaypointIndex
    snapped: bool
    speed_km_h: float
    idle_time_s: float
    turn_time_s: float
    is_destination: bool


class WaypointData(WaypointDataRequired, total=False):
    yaw: Optional[float]
    auto_generated: bool
    speed_deviation_km_h: float


class VehicleIgnoreFlags(TypedDict):
    traffic_lights: bool
    stop_signs: bool
    vehicles: bool


def clone_waypoint_data(waypoint: WaypointData) -> WaypointData:
    """Return a shallow copy of a waypoint payload with consistent typing."""
    return cast(WaypointData, dict(waypoint))


def clone_waypoint_sequence(waypoints: List[WaypointData]) -> List[WaypointData]:
    """Return a cloned waypoint sequence to avoid mutating original lists."""
    return [clone_waypoint_data(waypoint) for waypoint in waypoints]


def ensure_ignore_flags(flags: Optional[Dict[str, bool]]) -> VehicleIgnoreFlags:
    """Normalize ignore flag dictionaries with default True for vehicles."""
    base: VehicleIgnoreFlags = {
        'traffic_lights': False,
        'stop_signs': False,
        'vehicles': True,
    }
    if not flags:
        return base
    base.update({
        'traffic_lights': bool(flags.get('traffic_lights', False)),
        'stop_signs': bool(flags.get('stop_signs', False)),
        'vehicles': bool(flags.get('vehicles', True)),
    })
    return base

############################################################
# Overlay Renderer Helpers
############################################################


class WaypointOverlayRenderer:
    """Render helper for waypoint overlays."""

    @staticmethod
    def _project_to_screen(cp, x, y, z, *, rounded=True):
        """Project a world point to screen coordinates via the shared detector."""
        result = cp.coordinate_detector.world_to_screen_coordinates(x, y, z)
        if not result.get('success'):
            return None
        if rounded:
            return int(result['x']), int(result['y'])
        return result['x'], result['y']

    @staticmethod
    def render_creation_overlay(processor, screen):
        """Render waypoint creation mode overlay with green circle and line."""
        cp = processor
        if not (cp.creating_waypoint and cp.waypoint_vehicle and cp.waypoint_vehicle.is_alive):
            return

        mouse_x, mouse_y = pygame.mouse.get_pos()
        waypoints = cp.get_vehicle_waypoints(cp.waypoint_vehicle.id)

        if waypoints:
            last_waypoint = waypoints[-1]
            connection = WaypointOverlayRenderer._project_to_screen(
                cp, last_waypoint['x'], last_waypoint['y'], last_waypoint['z'] + 1.0
            )
        else:
            vehicle_location = cp.waypoint_vehicle.get_location()
            connection = WaypointOverlayRenderer._project_to_screen(
                cp, vehicle_location.x, vehicle_location.y, vehicle_location.z + 1.0
            )

        if not connection:
            return

        connection_x, connection_y = connection
        waypoint_green = (255, 215, 0) if cp.waypoint_vehicle and cp.is_ego_vehicle(cp.waypoint_vehicle.id) else (0, 255, 0)

        pygame.draw.line(
            screen,
            waypoint_green,
            (connection_x, connection_y),
            (mouse_x, mouse_y),
            3,
        )
        pygame.draw.circle(screen, waypoint_green, (connection_x, connection_y), 8, 2)

    @staticmethod
    def render_destination_overlay(processor, screen):
        """Render destination creation mode overlay with yellow circle cursor."""
        cp = processor
        if not (cp.creating_destination and cp.selected_vehicle and cp.selected_vehicle.is_alive):
            return

        mouse_x, mouse_y = pygame.mouse.get_pos()
        destination_yellow = (255, 215, 0)

        pygame.draw.circle(screen, destination_yellow, (mouse_x, mouse_y), 25, 3)
        pygame.draw.circle(screen, destination_yellow, (mouse_x, mouse_y), 5)

        vehicle_location = cp.selected_vehicle.get_location()
        vehicle_screen = WaypointOverlayRenderer._project_to_screen(
            cp, vehicle_location.x, vehicle_location.y, vehicle_location.z + 1.0
        )

        if not vehicle_screen:
            return

        vehicle_x, vehicle_y = vehicle_screen
        WaypointOverlayRenderer._draw_dashed_line(
            screen,
            destination_yellow,
            (vehicle_x, vehicle_y),
            (mouse_x, mouse_y),
            2,
            5,
        )
        pygame.draw.circle(screen, destination_yellow, (vehicle_x, vehicle_y), 8, 2)

    @staticmethod
    def render_waypoints_overlay(processor, screen):
        """
        Render hover feedback for waypoints while deferring primary drawing to CARLA debug helpers.
        """
        cp = processor
        if not cp.waypoint_display_vehicle_id:
            cp.waypoint_hover_index = None
            return

        mouse_x, mouse_y = pygame.mouse.get_pos()
        if mouse_y <= 80:
            cp.waypoint_hover_index = None
            return

        vehicle_id = cp.waypoint_display_vehicle_id
        waypoints = cp.get_vehicle_waypoints(vehicle_id)
        if not waypoints:
            return

        vehicle = next((v for v in cp.spawned_vehicles if v.id == vehicle_id and v.is_alive), None)
        if not vehicle:
            cp.waypoint_hover_index = None
            return

        cp.waypoint_hover_index = None

        for i, waypoint in enumerate(waypoints):
            screen_pos = WaypointOverlayRenderer._project_to_screen(
                cp, waypoint['x'], waypoint['y'], waypoint['z'] + 1.0
            )
            if not screen_pos:
                continue
            marker_x, marker_y = screen_pos
            distance = ((marker_x - mouse_x) ** 2 + (marker_y - mouse_y) ** 2) ** 0.5
            if distance <= cp.waypoint_marker_radius + 5:
                cp.waypoint_hover_index = (vehicle_id, i)
                break

    @staticmethod
    def _draw_dashed_line(surface, color, start_pos, end_pos, width=1, dash_length=5):
        """Draw a dashed line between two points."""
        x1, y1 = start_pos
        x2, y2 = end_pos
        distance = math.hypot(x2 - x1, y2 - y1)
        if distance == 0:
            return

        dashes = int(distance / dash_length)
        for i in range(0, dashes, 2):
            start = i * dash_length / distance
            end = min((i + 1) * dash_length / distance, 1)
            start_x = int(x1 + (x2 - x1) * start)
            start_y = int(y1 + (y2 - y1) * start)
            end_x = int(x1 + (x2 - x1) * end)
            end_y = int(y1 + (y2 - y1) * end)
            pygame.draw.line(surface, color, (start_x, start_y), (end_x, end_y), width)

    @staticmethod
    def draw_finish_line(processor, screen, marker_x, marker_y, waypoints, waypoint_index, is_selected, is_hovered):
        """Draw a finish-line pattern for the last waypoint (legacy overlay helper)."""
        cp = processor
        if waypoint_index > 0:
            prev_waypoint = waypoints[waypoint_index - 1]
            current_waypoint = waypoints[waypoint_index]
            prev_screen = WaypointOverlayRenderer._project_to_screen(
                cp, prev_waypoint['x'], prev_waypoint['y'], prev_waypoint['z'], rounded=False
            )
            current_screen = WaypointOverlayRenderer._project_to_screen(
                cp, current_waypoint['x'], current_waypoint['y'], current_waypoint['z'], rounded=False
            )
            if prev_screen and current_screen:
                px, py = prev_screen
                cx, cy = current_screen
                dx = cx - px
                dy = cy - py
                trajectory_angle = math.atan2(dy, dx)
                perpendicular_angle = trajectory_angle + math.pi / 2
            else:
                perpendicular_angle = 0
        else:
            perpendicular_angle = 0

        line_length = 30 if is_selected or is_hovered else 25
        line_width = 4
        half_length = line_length / 2
        start_x = marker_x - half_length * math.cos(perpendicular_angle)
        start_y = marker_y - half_length * math.sin(perpendicular_angle)
        end_x = marker_x + half_length * math.cos(perpendicular_angle)
        end_y = marker_y + half_length * math.sin(perpendicular_angle)
        num_segments = 8
        segment_length = line_length / num_segments

        for i in range(num_segments):
            color = (255, 255, 255) if i % 2 == 0 else (0, 0, 0)
            t1 = i / num_segments
            t2 = (i + 1) / num_segments
            seg_start_x = start_x + t1 * (end_x - start_x)
            seg_start_y = start_y + t1 * (end_y - start_y)
            seg_end_x = start_x + t2 * (end_x - start_x)
            seg_end_y = start_y + t2 * (end_y - start_y)
            pygame.draw.line(screen, color, (seg_start_x, seg_start_y), (seg_end_x, seg_end_y), line_width)

        if is_selected or is_hovered:
            outline_color = (255, 255, 0) if is_selected else (255, 200, 0)
            pygame.draw.line(screen, outline_color, (start_x, start_y), (end_x, end_y), line_width + 2)
            for i in range(num_segments):
                color = (255, 255, 255) if i % 2 == 0 else (0, 0, 0)
                t1 = i / num_segments
                t2 = (i + 1) / num_segments
                seg_start_x = start_x + t1 * (end_x - start_x)
                seg_start_y = start_y + t1 * (end_y - start_y)
                seg_end_x = start_x + t2 * (end_x - start_x)
                seg_end_y = start_y + t2 * (end_y - start_y)
                pygame.draw.line(screen, color, (seg_start_x, seg_start_y), (seg_end_x, seg_end_y), line_width)


class TriggerOverlayRenderer:
    """Render helper for trigger overlays."""

    @staticmethod
    def render_trigger_placement_overlay(processor, screen):
        """Render trigger placement cursor overlay."""
        cp = processor
        if not (cp.placing_trigger or getattr(cp, "pending_personal_trigger", None)):
            return

        try:
            mouse_pos = pygame.mouse.get_pos()
        except pygame.error:
            return

        circle_color = (0, 140, 255)
        circle_radius = max(12, int(getattr(cp, "personal_trigger_preview_radius", DEFAULT_PERSONAL_TRIGGER_RADIUS) * 6))
        pygame.draw.circle(screen, circle_color, mouse_pos, circle_radius, 2)

        pending_personal = getattr(cp, "pending_personal_trigger", None)
        if pending_personal:
            anchor = TriggerOverlayRenderer._get_personal_trigger_anchor(cp, pending_personal)
            if anchor:
                pygame.draw.line(screen, circle_color, anchor, mouse_pos, 2)

    @staticmethod
    def _get_personal_trigger_anchor(processor, pending):
        """Return the screen-space anchor for the pending personal trigger."""
        kind = pending.get('kind')
        if kind in ('vehicle', 'pedestrian'):
            actor_ref = pending.get('actor_ref')
            actor = actor_ref() if callable(actor_ref) else pending.get('actor')
            if actor and actor.is_alive:
                screen_pos = processor.coordinate_detector.world_to_screen_coordinates(
                    actor.get_location().x,
                    actor.get_location().y,
                    actor.get_location().z + 2.0,
                )
                if screen_pos.get('success'):
                    return (int(screen_pos['x']), int(screen_pos['y']))
        elif kind == 'traffic_light':
            group = pending.get('group')
            if group:
                anchor = processor._get_traffic_light_group_menu_anchor(group)
                if anchor:
                    return (int(anchor[0]), int(anchor[1]))
        return None

    @staticmethod
    def render_triggers(processor, screen):
        """Render trigger zones using CARLA debug drawing."""
        cp = processor
        if not cp.triggers:
            return

        # Hide triggers during scenario playback
        if cp.editor and cp.editor.scenario_running:
            return

        for idx, trigger in enumerate(cp.triggers):
            is_selected = idx == cp.selected_trigger_index
            if is_selected:
                marker_color = carla.Color(180, 180, 0)
                circle_color = carla.Color(180, 140, 0)
            else:
                marker_color = carla.Color(0, 50, 150)
                circle_color = carla.Color(0, 50, 150)

            draw_height = trigger['z'] + 0.3
            center_location = carla.Location(trigger['x'], trigger['y'], draw_height)
            marker_size = 0.5 if is_selected else 0.4

            cp.world.debug.draw_point(
                center_location,
                size=marker_size,
                color=marker_color,
                life_time=cp.waypoint_debug_lifetime,
            )
            cp.world.debug.draw_string(
                carla.Location(trigger['x'], trigger['y'], draw_height + 2.2),
                "TRIGGER",
                draw_shadow=True,
                color=marker_color,
                life_time=cp.waypoint_debug_lifetime,
                persistent_lines=False,
            )
            cp.world.debug.draw_string(
                carla.Location(trigger['x'], trigger['y'], draw_height + 1.2),
                f"R: {trigger['radius']:.1f}m",
                draw_shadow=True,
                color=carla.Color(150, 150, 150),
                life_time=cp.waypoint_debug_lifetime,
                persistent_lines=False,
            )

            num_points = 32
            radius = trigger['radius']
            for i in range(num_points):
                angle1 = 2.0 * math.pi * i / num_points
                angle2 = 2.0 * math.pi * (i + 1) / num_points
                point1 = carla.Location(
                    trigger['x'] + radius * math.cos(angle1),
                    trigger['y'] + radius * math.sin(angle1),
                    draw_height,
                )
                point2 = carla.Location(
                    trigger['x'] + radius * math.cos(angle2),
                    trigger['y'] + radius * math.sin(angle2),
                    draw_height,
                )
                cp.world.debug.draw_line(
                    point1,
                    point2,
                    thickness=0.1,
                    color=circle_color,
                    life_time=cp.waypoint_debug_lifetime,
                    persistent_lines=False,
                )

            north = carla.Location(trigger['x'], trigger['y'] + radius, draw_height)
            south = carla.Location(trigger['x'], trigger['y'] - radius, draw_height)
            cp.world.debug.draw_line(
                north,
                south,
                thickness=0.05,
                color=circle_color,
                life_time=cp.waypoint_debug_lifetime,
                persistent_lines=False,
            )

            east = carla.Location(trigger['x'] + radius, trigger['y'], draw_height)
            west = carla.Location(trigger['x'] - radius, trigger['y'], draw_height)
            cp.world.debug.draw_line(
                east,
                west,
                thickness=0.05,
                color=circle_color,
                life_time=cp.waypoint_debug_lifetime,
                persistent_lines=False,
            )


class OverlayMenuRenderer:
    """Shared renderer for floating action menus anchored to world objects."""

    ICON_SIZE = 40
    ICON_SPACING = 50
    MENU_PADDING = 10
    SCREEN_MARGIN = 10

    @classmethod
    def _layout(cls, anchor, icons, screen_width, screen_height):
        if not anchor or not icons:
            return None, []
        anchor_x, anchor_y = anchor
        icon_count = len(icons)
        menu_width = icon_count * cls.ICON_SPACING + cls.MENU_PADDING * 2
        menu_height = cls.ICON_SIZE + cls.MENU_PADDING * 2

        menu_x = max(
            cls.SCREEN_MARGIN,
            min(int(anchor_x) - menu_width // 2, screen_width - menu_width - cls.SCREEN_MARGIN),
        )
        menu_y = max(
            cls.SCREEN_MARGIN,
            min(int(anchor_y) - menu_height - cls.SCREEN_MARGIN, screen_height - menu_height - cls.SCREEN_MARGIN),
        )

        menu_rect = pygame.Rect(menu_x, menu_y, menu_width, menu_height)
        icon_entries = []
        for idx, icon_name in enumerate(icons):
            center_x = menu_rect.x + cls.MENU_PADDING + idx * cls.ICON_SPACING + cls.ICON_SIZE // 2
            center_y = menu_rect.y + cls.MENU_PADDING + cls.ICON_SIZE // 2
            icon_rect = pygame.Rect(
                center_x - cls.ICON_SIZE // 2,
                center_y - cls.ICON_SIZE // 2,
                cls.ICON_SIZE,
                cls.ICON_SIZE,
            )
            icon_entries.append((icon_name, icon_rect, (center_x, center_y)))

        return menu_rect, icon_entries

    @classmethod
    def draw_menu(cls, screen, anchor, icons, screen_size, tooltip_manager=None):
        """Draw a floating action menu and return icon layout."""
        menu_rect, icon_entries = cls._layout(anchor, icons, screen_size[0], screen_size[1])
        if not icon_entries:
            return []

        menu_surface = pygame.Surface(menu_rect.size, pygame.SRCALPHA)
        menu_surface.fill((40, 40, 40, 220))
        screen.blit(menu_surface, menu_rect.topleft)
        pygame.draw.rect(screen, (100, 100, 100), menu_rect, 2)

        mouse_pos = pygame.mouse.get_pos()
        for icon_name, icon_rect, center in icon_entries:
            pygame.draw.rect(screen, (80, 80, 80), icon_rect)
            pygame.draw.rect(screen, (150, 150, 150), icon_rect, 2)
            cls._draw_icon(screen, icon_name, center)

            # Register hover for tooltip
            if tooltip_manager and icon_rect.collidepoint(mouse_pos):
                tooltip_text = OVERLAY_ICON_TOOLTIPS.get(icon_name, "")
                if tooltip_text:
                    tooltip_manager.register_hover(
                        f"overlay_icon_{icon_name}",
                        icon_rect,
                        tooltip_text,
                    )

        return icon_entries

    @classmethod
    def hit_test(cls, anchor, icons, screen_size, mouse_pos):
        """Return the icon name at the given mouse position, if any."""
        _, icon_entries = cls._layout(anchor, icons, screen_size[0], screen_size[1])
        for icon_name, icon_rect, _ in icon_entries:
            if icon_rect.collidepoint(mouse_pos):
                return icon_name
        return None

    @staticmethod
    def _draw_icon(screen, icon_name, center):
        center_x, center_y = center

        if icon_name == 'delete':
            x_size = 12
            pygame.draw.line(
                screen,
                (255, 100, 100),
                (center_x - x_size, center_y - x_size),
                (center_x + x_size, center_y + x_size),
                3,
            )
            pygame.draw.line(
                screen,
                (255, 100, 100),
                (center_x + x_size, center_y - x_size),
                (center_x - x_size, center_y + x_size),
                3,
            )
        elif icon_name == 'move':
            arrow_size = 8
            pygame.draw.polygon(
                screen,
                (100, 200, 255),
                [
                    (center_x, center_y - arrow_size),
                    (center_x - 4, center_y - 4),
                    (center_x + 4, center_y - 4),
                ],
            )
            pygame.draw.polygon(
                screen,
                (100, 200, 255),
                [
                    (center_x, center_y + arrow_size),
                    (center_x - 4, center_y + 4),
                    (center_x + 4, center_y + 4),
                ],
            )
            pygame.draw.polygon(
                screen,
                (100, 200, 255),
                [
                    (center_x - arrow_size, center_y),
                    (center_x - 4, center_y - 4),
                    (center_x - 4, center_y + 4),
                ],
            )
            pygame.draw.polygon(
                screen,
                (100, 200, 255),
                [
                    (center_x + arrow_size, center_y),
                    (center_x + 4, center_y - 4),
                    (center_x + 4, center_y + 4),
                ],
            )
        elif icon_name == 'rotate':
            radius = 12
            pygame.draw.circle(screen, (200, 200, 255), (center_x, center_y), radius, 2)
            arrow_angle = math.radians(45)
            arrow_head = (
                center_x + radius * math.cos(arrow_angle),
                center_y - radius * math.sin(arrow_angle),
            )
            pygame.draw.polygon(
                screen,
                (200, 200, 255),
                [
                    arrow_head,
                    (arrow_head[0] - 6, arrow_head[1] - 2),
                    (arrow_head[0] - 2, arrow_head[1] - 6),
                ],
            )
            inner_radius = 8
            pygame.draw.arc(
                screen,
                (200, 200, 255),
                (
                    center_x - inner_radius,
                    center_y - inner_radius,
                    inner_radius * 2,
                    inner_radius * 2,
                ),
                math.radians(-20),
                math.radians(200),
                2,
            )
            arrow_end = (
                center_x + inner_radius * math.cos(math.radians(200)),
                center_y + inner_radius * math.sin(math.radians(200)),
            )
            pygame.draw.polygon(
                screen,
                (200, 200, 255),
                [
                    arrow_end,
                    (arrow_end[0] - 4, arrow_end[1] + 2),
                    (arrow_end[0], arrow_end[1] + 6),
                ],
            )
        elif icon_name == 'waypoint':
            radius = 12
            path_points = []
            for i in range(8):
                angle = 2 * math.pi * i / 8
                x = center_x + radius * 0.7 * math.cos(angle)
                y = center_y + radius * 0.5 * math.sin(angle)
                path_points.append((x, y))
            if len(path_points) > 1:
                pygame.draw.lines(screen, (100, 255, 100), False, path_points, 2)
            waypoint_positions = [
                (center_x - 8, center_y - 4),
                (center_x, center_y - 8),
                (center_x + 8, center_y - 4),
                (center_x + 6, center_y + 6),
                (center_x - 6, center_y + 6),
            ]
            for pos in waypoint_positions:
                pygame.draw.circle(screen, (100, 255, 100), pos, 2)
        elif icon_name in ('autoroute', 'ego_destination'):
            pin_center_x = center_x
            pin_center_y = center_y + 2
            pin_radius = 9
            pygame.draw.circle(screen, (255, 215, 0), (pin_center_x, pin_center_y - 4), pin_radius)
            pygame.draw.circle(screen, (255, 255, 255), (pin_center_x, pin_center_y - 4), 4)
            pygame.draw.polygon(
                screen,
                (255, 215, 0),
                [
                    (pin_center_x, pin_center_y + 8),
                    (pin_center_x - 7, pin_center_y),
                    (pin_center_x + 7, pin_center_y),
                ],
            )
        elif icon_name == 'scale':
            arrow_size = 10
            pygame.draw.polygon(
                screen,
                (255, 200, 100),
                [
                    (center_x, center_y - arrow_size),
                    (center_x - 5, center_y - arrow_size + 5),
                    (center_x + 5, center_y - arrow_size + 5),
                ],
            )
            pygame.draw.polygon(
                screen,
                (255, 200, 100),
                [
                    (center_x, center_y + arrow_size),
                    (center_x - 5, center_y + arrow_size - 5),
                    (center_x + 5, center_y + arrow_size - 5),
                ],
            )
            pygame.draw.line(
                screen,
                (255, 200, 100),
                (center_x, center_y - arrow_size + 5),
                (center_x, center_y + arrow_size - 5),
                2,
            )
        elif icon_name == 'remove_trigger':
            ring_color = (0, 140, 255)
            plus_color = (255, 255, 255)
            pygame.draw.circle(screen, ring_color, (center_x, center_y), 10, 2)
            pygame.draw.circle(screen, ring_color, (center_x, center_y), 3, 0)
            pygame.draw.line(screen, plus_color, (center_x - 6, center_y), (center_x + 6, center_y), 2)
            pygame.draw.line(screen, plus_color, (center_x, center_y - 6), (center_x, center_y + 6), 2)

            overlay_radius = 11
            pygame.draw.circle(screen, (200, 60, 60), (center_x, center_y), overlay_radius, 2)
            offset = 7
            pygame.draw.line(
                screen,
                (230, 70, 70),
                (center_x - offset, center_y - offset),
                (center_x + offset, center_y + offset),
                3,
            )
            pygame.draw.line(
                screen,
                (230, 70, 70),
                (center_x + offset, center_y - offset),
                (center_x - offset, center_y + offset),
                3,
            )
        elif icon_name == 'add_trigger':
            ring_color = (0, 140, 255)
            plus_color = (255, 255, 255)
            pygame.draw.circle(screen, ring_color, (center_x, center_y), 10, 2)
            pygame.draw.circle(screen, ring_color, (center_x, center_y), 3, 0)
            pygame.draw.line(screen, plus_color, (center_x - 6, center_y), (center_x + 6, center_y), 2)
            pygame.draw.line(screen, plus_color, (center_x, center_y - 6), (center_x, center_y + 6), 2)

class OpenDriveOverlayRenderer:
    """Render helper for OpenDRIVE lane overlays."""

    @staticmethod
    def invalidate_cache(processor, *, drop_surfaces=False, clear_projection=True):
        """Mark cached overlay surfaces for rebuild."""
        cp = processor
        if not cp:
            return
        if hasattr(cp, 'overlay_surface_dirty'):
            cp.overlay_surface_dirty = True
        if drop_surfaces:
            if hasattr(cp, 'overlay_surface'):
                cp.overlay_surface = None
            if hasattr(cp, '_lane_overlay_surface'):
                cp._lane_overlay_surface = None
        if clear_projection and hasattr(cp, 'projection_cache'):
            cp.projection_cache.clear()

    @staticmethod
    def disable_overlay(processor, *, silent=False):
        """Turn off the OpenDRIVE overlay and drop cached surfaces."""
        cp = processor
        if not cp:
            return
        if not getattr(cp, 'lane_overlay_enabled', False):
            return
        cp.lane_overlay_enabled = False
        OpenDriveOverlayRenderer.invalidate_cache(cp, drop_surfaces=True)
        if not silent:
            print("OpenDRIVE overlay disabled")

    @staticmethod
    def render(processor, screen):
        cp = processor
        if not getattr(cp, 'lane_overlay_enabled', False):
            return
        if getattr(cp, 'opendrive_overlay_hidden_for_camera_pan', False):
            return
        if not getattr(cp, 'opendrive_lane_data', None):
            return

        camera_moved = OpenDriveOverlayRenderer._has_camera_moved_significantly(cp)

        if not hasattr(cp, '_lane_overlay_surface') or cp._lane_overlay_surface is None:
            cp._lane_overlay_surface = pygame.Surface(
                (cp.screen_width, cp.screen_height), pygame.SRCALPHA
            )
            cp._lane_overlay_surface.fill((0, 0, 0, 0))
            screen.blit(cp._lane_overlay_surface, (0, 0))
        else:
            screen.blit(cp._lane_overlay_surface, (0, 0))

        if (
            cp.overlay_surface is None
            or cp.overlay_surface.get_size() != (cp.screen_width, cp.screen_height)
        ):
            cp.overlay_surface = pygame.Surface(
                (cp.screen_width, cp.screen_height), pygame.SRCALPHA
            )
            cp.overlay_surface_dirty = True

        if camera_moved or cp.overlay_surface_dirty:
            if camera_moved:
                cp.projection_cache.clear()
                OpenDriveOverlayRenderer._update_camera_state(cp)
            cp.overlay_surface.fill((0, 0, 0, 0))
            OpenDriveOverlayRenderer._render_lanes_to_surface(cp, cp.overlay_surface)
            cp.overlay_surface_dirty = False

        screen.blit(cp.overlay_surface, (0, 0))

    @staticmethod
    def precompute_lane_data(processor):
        cp = processor
        if not getattr(cp, 'world', None):
            return

        world_map = cp._get_cached_map(refresh=False)
        if not world_map:
            return

        start_time = time.time()
        try:
            cp.opendrive_lane_data = {
                'lane_segments': [],
                'waypoints': [],
                'spawn_points': [],
            }

            topology = world_map.get_topology()
            processed_segments = set()
            for start_wp, end_wp in topology:
                segment_key = (start_wp.road_id, start_wp.lane_id, int(start_wp.s / 10))
                if segment_key in processed_segments:
                    continue
                processed_segments.add(segment_key)

                lane_points = OpenDriveOverlayRenderer.trace_lane_segment(cp, start_wp, end_wp)
                for i in range(len(lane_points) - 1):
                    start_point = lane_points[i]
                    end_point = lane_points[i + 1]
                    start_z = start_point.z + 0.5
                    end_z = end_point.z + 0.5
                    cp.opendrive_lane_data['lane_segments'].append(
                        {
                            'start': {'x': start_point.x, 'y': start_point.y, 'z': start_z},
                            'end': {'x': end_point.x, 'y': end_point.y, 'z': end_z},
                        }
                    )

            OpenDriveOverlayRenderer._build_segment_grid(cp)
            _ = time.time() - start_time  # Keep computation for potential logging
            OpenDriveOverlayRenderer.invalidate_cache(cp, drop_surfaces=True)
        except Exception:
            pass

    @staticmethod
    def trace_lane_segment(processor, start_wp, end_wp):
        cp = processor
        lane_points = []
        current = start_wp
        max_distance = start_wp.transform.location.distance(end_wp.transform.location)
        lane_points.append(current.transform.location)

        if max_distance < 10.0:
            lane_points.append(end_wp.transform.location)
            return lane_points

        step_size = min(2.0, max_distance / 20.0)
        total_distance = 0

        while total_distance < max_distance:
            try:
                next_waypoints = current.next(step_size)
                if not next_waypoints:
                    break
                next_wp = next_waypoints[0]
                next_pos = next_wp.transform.location
                distance_to_end = next_pos.distance(end_wp.transform.location)
                if distance_to_end < step_size * 1.5:
                    lane_points.append(end_wp.transform.location)
                    break

                lane_points.append(next_pos)
                current = next_wp
                total_distance += step_size

                if len(lane_points) > 200:
                    break
            except Exception:
                break

        return lane_points

    @staticmethod
    def toggle_overlay(processor):
        cp = processor
        if not hasattr(cp, 'lane_overlay_enabled'):
            cp.lane_overlay_enabled = False
        new_state = not cp.lane_overlay_enabled
        if new_state:
            cp.lane_overlay_enabled = True
            print("OpenDRIVE overlay enabled")
            if not getattr(cp, 'opendrive_lane_data', None):
                OpenDriveOverlayRenderer.precompute_lane_data(cp)
            OpenDriveOverlayRenderer.invalidate_cache(cp, drop_surfaces=True)
        else:
            OpenDriveOverlayRenderer.disable_overlay(cp)

    @staticmethod
    def _render_lanes_to_surface(processor, surface):
        cp = processor
        candidate_indices = None
        if cp.opendrive_segment_grid and cp.opendrive_segment_bboxes:
            viewport = OpenDriveOverlayRenderer._compute_viewport_bounds(cp)
            if viewport:
                minx, miny, maxx, maxy = viewport
                cell = cp.opendrive_grid_cell_size
                ix0 = int(math.floor(minx / cell))
                iy0 = int(math.floor(miny / cell))
                ix1 = int(math.floor(maxx / cell))
                iy1 = int(math.floor(maxy / cell))
                candidates = []
                for ix in range(ix0, ix1 + 1):
                    for iy in range(iy0, iy1 + 1):
                        key = (ix, iy)
                        if key in cp.opendrive_segment_grid:
                            candidates.extend(cp.opendrive_segment_grid[key])
                candidate_indices = list(set(candidates))

        segments = cp.opendrive_lane_data.get('lane_segments', [])
        if candidate_indices is None:
            iterator = range(len(segments))
            viewport = OpenDriveOverlayRenderer._compute_viewport_bounds(cp)
        else:
            viewport = OpenDriveOverlayRenderer._compute_viewport_bounds(cp)
            if viewport is None:
                iterator = candidate_indices
            else:
                iterator = [
                    i
                    for i in candidate_indices
                    if OpenDriveOverlayRenderer._bbox_intersects(
                        cp.opendrive_segment_bboxes[i], viewport
                    )
                ]

        screen_width = cp.screen_width
        screen_height = cp.screen_height
        for i in iterator:
            segment = segments[i]
            start = segment['start']
            end = segment['end']
            start_screen = cp.coordinate_detector.world_to_screen_coordinates(
                start['x'], start['y'], start['z']
            )
            end_screen = cp.coordinate_detector.world_to_screen_coordinates(
                end['x'], end['y'], end['z']
            )
            if not (start_screen['success'] and end_screen['success']):
                continue

            start_x = int(start_screen['x'])
            start_y = int(start_screen['y'])
            end_x = int(end_screen['x'])
            end_y = int(end_screen['y'])
            if (
                (start_x < -50 and end_x < -50)
                or (start_x > screen_width + 50 and end_x > screen_width + 50)
                or (start_y < -50 and end_y < -50)
                or (start_y > screen_height + 50 and end_y > screen_height + 50)
            ):
                continue
            pygame.draw.line(surface, (255, 165, 0), (start_x, start_y), (end_x, end_y), 2)

    @staticmethod
    def _compute_viewport_bounds(processor):
        cp = processor
        try:
            tl = cp.coordinate_detector.screen_to_world_coordinates_no_raycast(
                0, 0, cp.screen_width, cp.screen_height, 0.0
            )
            tr = cp.coordinate_detector.screen_to_world_coordinates_no_raycast(
                cp.screen_width, 0, cp.screen_width, cp.screen_height, 0.0
            )
            bl = cp.coordinate_detector.screen_to_world_coordinates_no_raycast(
                0, cp.screen_height, cp.screen_width, cp.screen_height, 0.0
            )
            br = cp.coordinate_detector.screen_to_world_coordinates_no_raycast(
                cp.screen_width, cp.screen_height, cp.screen_width, cp.screen_height, 0.0
            )
            if all(c['success'] for c in (tl, tr, bl, br)):
                x_coords = [tl['x'], tr['x'], bl['x'], br['x']]
                y_coords = [tl['y'], tr['y'], bl['y'], br['y']]
                return (min(x_coords), min(y_coords), max(x_coords), max(y_coords))
        except Exception as exc:
            print(f"Error computing viewport bounds: {exc}")
        return None

    @staticmethod
    def _build_segment_grid(processor):
        cp = processor
        if not cp.opendrive_lane_data or not cp.opendrive_lane_data.get('lane_segments'):
            return

        segments = cp.opendrive_lane_data['lane_segments']
        cp.opendrive_segment_grid = {}
        cp.opendrive_segment_bboxes = []
        cell_size = cp.opendrive_grid_cell_size

        for i, segment in enumerate(segments):
            start = segment['start']
            end = segment['end']
            minx = min(start['x'], end['x'])
            miny = min(start['y'], end['y'])
            maxx = max(start['x'], end['x'])
            maxy = max(start['y'], end['y'])
            cp.opendrive_segment_bboxes.append((minx, miny, maxx, maxy))

            ix0 = int(math.floor(minx / cell_size))
            iy0 = int(math.floor(miny / cell_size))
            ix1 = int(math.floor(maxx / cell_size))
            iy1 = int(math.floor(maxy / cell_size))
            for ix in range(ix0, ix1 + 1):
                for iy in range(iy0, iy1 + 1):
                    key = (ix, iy)
                    cp.opendrive_segment_grid.setdefault(key, []).append(i)

    @staticmethod
    def _bbox_intersects(bbox1, bbox2):
        minx1, miny1, maxx1, maxy1 = bbox1
        minx2, miny2, maxx2, maxy2 = bbox2
        return not (maxx1 < minx2 or maxx2 < minx1 or maxy1 < miny2 or maxy2 < miny1)

    @staticmethod
    def _has_camera_moved_significantly(processor):
        cp = processor
        current_center = (cp.camera_controller.center_x, cp.camera_controller.center_y)
        current_height = cp.camera_controller.height

        if cp.last_camera_center is None or cp.last_camera_height is None:
            return True

        dx = abs(current_center[0] - cp.last_camera_center[0])
        dy = abs(current_center[1] - cp.last_camera_center[1])
        pos_change = (dx ** 2 + dy ** 2) ** 0.5
        height_change = abs(current_height - cp.last_camera_height)
        height_ratio = height_change / current_height if current_height > 0 else 0
        return pos_change > cp.cache_tolerance or height_ratio > 0.02

    @staticmethod
    def _update_camera_state(processor):
        cp = processor
        cp.last_camera_center = (cp.camera_controller.center_x, cp.camera_controller.center_y)
        cp.last_camera_height = cp.camera_controller.height

############################################################
# Command Pattern Classes (Undo/Redo System)
############################################################

class Command:
    """
    Base class for undoable commands in the Visual Scenario Editor.
    Each command encapsulates an action (e.g., place/move/delete waypoint or vehicle)
    and provides execute, undo, and redo methods for history management.
    """
    def execute(self):
        """
        Execute the command.
        Should be overridden by subclasses to perform the action.
        """
        pass

    def undo(self):
        """
        Undo the command.
        Should be overridden by subclasses to revert the action.
        """
        pass

    def get_description(self):
        """
        Get a human-readable description of the command for history display.
        """
        return "Unknown command"

class WaypointCommandMixin:
    """Shared helpers for commands that manipulate waypoint lists."""

    def _get_waypoints_mutable(self, vehicle_id):
        """Ensure waypoint list exists and return it."""
        return self.camera_processor._ensure_waypoint_container(vehicle_id)

    def _remove_waypoint_list_if_empty(self, vehicle_id):
        """Remove waypoint list if no waypoints remain."""
        waypoints = self.camera_processor.get_vehicle_waypoints(vehicle_id)
        if not waypoints:
            self.camera_processor.clear_vehicle_waypoints(vehicle_id)

    def _assert_waypoint_index(self, vehicle_id, waypoint_index, context):
        """Validate waypoint index before mutating the sequence."""
        waypoints = self.camera_processor.get_vehicle_waypoints(vehicle_id)
        if not waypoints:
            print(f"[WARN] {context}: vehicle {vehicle_id} has no waypoints.")
            return False
        if waypoint_index < 0 or waypoint_index >= len(waypoints):
            print(f"[WARN] {context}: waypoint index {waypoint_index} invalid for vehicle {vehicle_id} (len={len(waypoints)}).")
            return False
        return True
class PlaceWaypointCommand(WaypointCommandMixin, Command):
    """
    Command to place a waypoint for a vehicle. Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle_id, waypoint_data, waypoint_index):
        self.camera_processor = camera_processor
        self.vehicle_id = vehicle_id
        self.waypoint_data = clone_waypoint_data(waypoint_data)
        self.waypoint_index = waypoint_index
    
    def execute(self):
        self.camera_processor.append_waypoint_data(self.vehicle_id, self.waypoint_data)
        self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True

    def undo(self):
        waypoints = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        if not waypoints:
            return False
        self.camera_processor.remove_waypoint_data(self.vehicle_id, len(waypoints) - 1)
        self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True
    
    def redo(self):
        return self.execute()
    
    def get_description(self):
        return f"Place waypoint #{self.waypoint_index}"

class CompositeCommand(Command):
    """
    Groups multiple commands into a single undoable unit.
    Used for operations that create multiple items at once (e.g., auto-route).
    """
    def __init__(self, commands, description="Composite command"):
        self.commands = commands  # List of Command objects
        self.description = description

    def execute(self):
        for cmd in self.commands:
            cmd.execute()
        return True

    def undo(self):
        # Undo in reverse order
        for cmd in reversed(self.commands):
            cmd.undo()
        return True

    def redo(self):
        return self.execute()

    def get_description(self):
        return self.description

class DeleteWaypointCommand(WaypointCommandMixin, Command):
    """
    Command to delete a waypoint from a vehicle's path. Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle_id, waypoint_index, waypoint_data):
        self.camera_processor = camera_processor
        self.vehicle_id = vehicle_id
        self.waypoint_index = waypoint_index
        self.waypoint_data = clone_waypoint_data(waypoint_data)
    
    def execute(self):
        context = "DeleteWaypointCommand.execute"
        if not self._assert_waypoint_index(self.vehicle_id, self.waypoint_index, context):
            return False
        removed = self.camera_processor.remove_waypoint_data(self.vehicle_id, self.waypoint_index)
        if removed is None:
            return False
        remaining = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        for index, wp in enumerate(remaining):
            wp['index'] = index + 1
        self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True

    def undo(self):
        container = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        insert_index = min(self.waypoint_index, len(container))
        inserted = self.camera_processor.insert_waypoint_data(self.vehicle_id, insert_index, self.waypoint_data)
        if inserted is None:
            return False
        waypoints = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        for index, wp in enumerate(waypoints):
            wp['index'] = index + 1
        self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True

    def redo(self):
        return self.execute()
    
    def get_description(self):
        return f"Delete waypoint #{self.waypoint_index + 1}"

class SpawnVehicleCommand(Command):
    """
    Command to spawn a vehicle at a given location and orientation. Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle_type, transform, vehicle_id=None, role="npc"):
        self.camera_processor = camera_processor
        self.vehicle_type = vehicle_type
        self.transform = transform
        self.spawned_vehicle = None
        self.original_vehicle_id = None  # Will be set after first spawn
        self.current_vehicle_id = None   # Track current ID for updates
        self.role = role
   
    def execute(self):
        # Adjust spawn location to proper ground height
        adjusted_transform = carla.Transform(self.transform.location, self.transform.rotation)
        # Add 0.1m offset above ground to avoid bounding box collision
        # Use debug flag from camera_processor if available
        debug_mode = getattr(self.camera_processor, 'debug_raycast', False)
        cached_map = self.camera_processor._get_cached_map(refresh=False)
        adjusted_transform.location.z = get_ground_height(
            self.camera_processor.world,
            self.transform.location,
            debug=debug_mode,
            cached_map=cached_map,
        ) + 0.2

        # Spawn the vehicle using CARLA API
        blueprint_library = self.camera_processor.world.get_blueprint_library()
        vehicle_bp = blueprint_library.find(self.vehicle_type)

        # Apply random color to vehicle (not pedestrians)
        if not self.vehicle_type.startswith('walker.'):
            if vehicle_bp.has_attribute('color'):
                color_attr = vehicle_bp.get_attribute('color')
                if color_attr.recommended_values:
                    color = random.choice(color_attr.recommended_values)
                    vehicle_bp.set_attribute('color', color)
                    # Store the selected color for saving
                    if not hasattr(self, 'assigned_color'):
                        self.assigned_color = color

        self.spawned_vehicle = self.camera_processor.world.try_spawn_actor(vehicle_bp, adjusted_transform)

        if self.spawned_vehicle:
            # Disable physics for scenario editing
            self.spawned_vehicle.set_simulate_physics(False)
            self.camera_processor.spawned_vehicles.append(self.spawned_vehicle)
            default_speed = 5 if self.vehicle_type.startswith('walker.') else 50
            if self.role == "ego" and not self.vehicle_type.startswith('walker.'):
                default_speed = 40
            color = getattr(self, 'assigned_color', None)
            self.camera_processor.initialize_vehicle_metadata(
                self.spawned_vehicle.id,
                speed=default_speed,
                destination_speed=None,
                idle_time=0.0,
                turn_time=0.0,
                color=color,
                ignore_flags=None,
                max_lat_acc=3.0,
            )

            if self.role == "ego":
                self.camera_processor.register_ego_vehicle(
                    self.spawned_vehicle,
                    adjusted_transform,
                    getattr(self, 'assigned_color', None)
                )

            # Track original and current vehicle IDs for undo/redo
            if self.original_vehicle_id is None:
                self.original_vehicle_id = self.spawned_vehicle.id
            self.current_vehicle_id = self.spawned_vehicle.id
            print(f"Vehicle spawned successfully at adjusted height: {adjusted_transform.location.z:.2f}")
        else:
            print(f"Failed to spawn vehicle {self.vehicle_type} - location might still be blocked")

        return self.spawned_vehicle is not None
    
    def undo(self):
        # Remove the vehicle
        if self.spawned_vehicle and self.spawned_vehicle.is_alive:
            if self.spawned_vehicle in self.camera_processor.spawned_vehicles:
                self.camera_processor.spawned_vehicles.remove(self.spawned_vehicle)
            self.camera_processor.clear_vehicle_metadata(self.spawned_vehicle.id, clear_waypoints=True)
            if self.role == "ego":
                self.camera_processor.clear_ego_vehicle(self.spawned_vehicle.id)
            self.spawned_vehicle.destroy()
            self.spawned_vehicle = None
    
    def redo(self):
        # Re-spawn the vehicle (same as execute but track ID changes)
        old_id = self.current_vehicle_id

        # Adjust spawn location to proper ground height
        adjusted_transform = carla.Transform(self.transform.location, self.transform.rotation)
        debug_mode = getattr(self.camera_processor, 'debug_raycast', False)
        cached_map = self.camera_processor._get_cached_map(refresh=False)
        adjusted_transform.location.z = get_ground_height(
            self.camera_processor.world,
            self.transform.location,
            debug=debug_mode,
            cached_map=cached_map,
        ) + 0.2

        blueprint_library = self.camera_processor.world.get_blueprint_library()
        vehicle_bp = blueprint_library.find(self.vehicle_type)

        # Apply the same color that was assigned during execute
        if not self.vehicle_type.startswith('walker.') and hasattr(self, 'assigned_color'):
            if vehicle_bp.has_attribute('color'):
                vehicle_bp.set_attribute('color', self.assigned_color)

        self.spawned_vehicle = self.camera_processor.world.try_spawn_actor(vehicle_bp, adjusted_transform)

        if self.spawned_vehicle:
            self.spawned_vehicle.set_simulate_physics(False)
            self.camera_processor.spawned_vehicles.append(self.spawned_vehicle)
            default_speed = 5 if self.vehicle_type.startswith('walker.') else 50
            if self.role == "ego" and not self.vehicle_type.startswith('walker.'):
                default_speed = 40
            color = getattr(self, 'assigned_color', None)
            self.camera_processor.initialize_vehicle_metadata(
                self.spawned_vehicle.id,
                speed=default_speed,
                destination_speed=None,
                idle_time=0.0,
                turn_time=0.0,
                color=color,
                ignore_flags=None,
                max_lat_acc=3.0,
            )

            if self.role == "ego":
                self.camera_processor.register_ego_vehicle(
                    self.spawned_vehicle,
                    adjusted_transform,
                    getattr(self, 'assigned_color', None)
                )

            # Update current vehicle ID and references if changed
            self.current_vehicle_id = self.spawned_vehicle.id
            if old_id and old_id != self.current_vehicle_id:
                self.camera_processor.update_vehicle_id_references(old_id, self.current_vehicle_id)
            print(f"Vehicle re-spawned successfully at adjusted height: {adjusted_transform.location.z:.2f}")
        else:
            print(f"Failed to re-spawn vehicle {self.vehicle_type} - location might still be blocked")
            
        return self.spawned_vehicle is not None
    
    def get_description(self):
        vehicle_label = self.vehicle_type.split('.')[-1] if self.vehicle_type else "unknown"
        if self.current_vehicle_id:
            return f"Spawn vehicle ({vehicle_label})"
        else:
            return f"Spawn vehicle ({vehicle_label})"

class DeleteVehicleCommand(Command):
    """
    Command to delete a vehicle and its waypoints. Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle, vehicle_type, transform, waypoints=None, speed=50):
        self.camera_processor = camera_processor
        self.vehicle = vehicle
        self.vehicle_type = vehicle_type
        self.transform = transform
        self.waypoints = clone_waypoint_sequence(waypoints) if waypoints else []
        self.speed = speed
        self.vehicle_id = vehicle.id if vehicle else None
        self.idle_time = camera_processor.get_actor_idle_time(vehicle.id, 0.0) if vehicle else 0.0
        self.turn_time = camera_processor.get_actor_turn_time(vehicle.id, 0.0) if vehicle else 0.0
        self.destination_speed = camera_processor.get_vehicle_destination_speed(vehicle.id) if vehicle else None
        self.color = camera_processor.get_vehicle_color(vehicle.id) if vehicle else None
        self.ignore_flags = camera_processor.get_vehicle_ignore_flags(vehicle.id) if vehicle else ensure_ignore_flags(None)
        self.was_ego = camera_processor.is_ego_vehicle(self.vehicle_id) if vehicle else False
        self.saved_trigger_center = None
        self.saved_trigger_radius = None
        self.saved_trigger_kind = None
        if vehicle:
            if vehicle.type_id.startswith('walker.'):
                center = camera_processor.pedestrian_trigger_centers.get(vehicle.id)
                radius = camera_processor.pedestrian_trigger_radii.get(vehicle.id)
                if center and radius is not None:
                    self.saved_trigger_center = dict(center)
                    self.saved_trigger_radius = float(radius)
                    self.saved_trigger_kind = 'pedestrian'
            else:
                center = camera_processor.vehicle_trigger_centers.get(vehicle.id)
                radius = camera_processor.vehicle_trigger_radii.get(vehicle.id)
                if center and radius is not None:
                    self.saved_trigger_center = dict(center)
                    self.saved_trigger_radius = float(radius)
                    self.saved_trigger_kind = 'vehicle'
    
    def execute(self):
        # Delete the vehicle
        if self.vehicle and self.vehicle.is_alive:
            self.camera_processor.assert_spawned_vehicle(self.vehicle_id, "DeleteVehicleCommand.execute")
            # Capture latest metadata before removal
            self.speed = self.camera_processor.get_vehicle_speed(self.vehicle.id, self.speed)
            self.idle_time = self.camera_processor.get_actor_idle_time(self.vehicle.id, self.idle_time)
            self.turn_time = self.camera_processor.get_actor_turn_time(self.vehicle.id, self.turn_time)
            self.destination_speed = self.camera_processor.get_vehicle_destination_speed(self.vehicle.id)
            self.color = self.camera_processor.get_vehicle_color(self.vehicle.id)
            self.ignore_flags = self.camera_processor.get_vehicle_ignore_flags(self.vehicle.id)
            self.waypoints = clone_waypoint_sequence(self.camera_processor.get_vehicle_waypoints(self.vehicle.id))
            if self.vehicle.type_id.startswith('walker.'):
                center = self.camera_processor.pedestrian_trigger_centers.get(self.vehicle.id)
                radius = self.camera_processor.pedestrian_trigger_radii.get(self.vehicle.id)
                if center and radius is not None:
                    self.saved_trigger_center = dict(center)
                    self.saved_trigger_radius = float(radius)
                    self.saved_trigger_kind = 'pedestrian'
            else:
                center = self.camera_processor.vehicle_trigger_centers.get(self.vehicle.id)
                radius = self.camera_processor.vehicle_trigger_radii.get(self.vehicle.id)
                if center and radius is not None:
                    self.saved_trigger_center = dict(center)
                    self.saved_trigger_radius = float(radius)
                    self.saved_trigger_kind = 'vehicle'

            if self.camera_processor.is_manual_control_actor(self.vehicle.id):
                self.camera_processor.disable_manual_control()

            if self.vehicle in self.camera_processor.spawned_vehicles:
                self.camera_processor.spawned_vehicles.remove(self.vehicle)
            self.camera_processor.clear_vehicle_metadata(self.vehicle.id, clear_waypoints=True)
            if self.was_ego:
                self.camera_processor.clear_ego_vehicle(self.vehicle.id)
            self.vehicle.destroy()

    def undo(self):
        # Respawn the vehicle with adjusted height
        adjusted_transform = carla.Transform(self.transform.location, self.transform.rotation)
        debug_mode = getattr(self.camera_processor, 'debug_raycast', False)
        cached_map = getattr(self.camera_processor, 'cached_map', None)
        adjusted_transform.location.z = get_ground_height(
            self.camera_processor.world,
            self.transform.location,
            debug=debug_mode,
            cached_map=cached_map,
        ) + 0.2
        
        blueprint_library = self.camera_processor.world.get_blueprint_library()
        vehicle_bp = blueprint_library.find(self.vehicle_type)
        self.vehicle = self.camera_processor.world.try_spawn_actor(vehicle_bp, adjusted_transform)

        if self.vehicle:
            self.vehicle.set_simulate_physics(False)
            self.camera_processor.spawned_vehicles.append(self.vehicle)
            old_id = self.vehicle_id
            self.camera_processor.initialize_vehicle_metadata(
                self.vehicle.id,
                speed=self.speed,
                destination_speed=self.destination_speed,
                idle_time=self.idle_time,
                turn_time=self.turn_time,
                color=self.color,
                ignore_flags=self.ignore_flags,
            )
            new_id = self.vehicle.id
            if self.vehicle.type_id.startswith('walker.'):
                if self.saved_trigger_kind == 'pedestrian' and self.saved_trigger_center and self.saved_trigger_radius is not None:
                    self.camera_processor.pedestrian_trigger_centers[new_id] = dict(self.saved_trigger_center)
                    self.camera_processor.pedestrian_trigger_radii[new_id] = max(MIN_PERSONAL_TRIGGER_RADIUS, float(self.saved_trigger_radius))
            else:
                if not self.camera_processor.is_ego_vehicle(new_id):
                    if self.saved_trigger_kind == 'vehicle' and self.saved_trigger_center and self.saved_trigger_radius is not None:
                        self.camera_processor.vehicle_trigger_centers[new_id] = dict(self.saved_trigger_center)
                        self.camera_processor.vehicle_trigger_radii[new_id] = max(MIN_PERSONAL_TRIGGER_RADIUS, float(self.saved_trigger_radius))

            if self.waypoints:
                self.camera_processor.set_vehicle_waypoints(self.vehicle.id, clone_waypoint_sequence(self.waypoints))
                self.camera_processor._cache_destination_speed(self.vehicle.id)
            else:
                self.camera_processor.clear_vehicle_waypoints(self.vehicle.id)
            if self.was_ego:
                self.camera_processor.register_ego_vehicle(self.vehicle, adjusted_transform)
            if old_id and old_id != self.vehicle.id:
                self.camera_processor.update_vehicle_id_references(old_id, self.vehicle.id)
            self.vehicle_id = self.vehicle.id
            print(f"Vehicle restored at adjusted height: {adjusted_transform.location.z:.2f}")
        else:
            print(f"Failed to restore vehicle {self.vehicle_type} - location might be blocked")
    
    def redo(self):
        # Re-execute the deletion
        if self.vehicle and self.vehicle.is_alive:
            if self.vehicle in self.camera_processor.spawned_vehicles:
                self.camera_processor.spawned_vehicles.remove(self.vehicle)
            if self.camera_processor.is_manual_control_actor(self.vehicle.id):
                self.camera_processor.disable_manual_control()
            self.camera_processor.clear_vehicle_metadata(self.vehicle.id, clear_waypoints=True)
            if self.was_ego:
                self.camera_processor.clear_ego_vehicle(self.vehicle.id)
            self.vehicle.destroy()
    
    def get_description(self):
        return f"Delete vehicle ({self.vehicle_type.split('.')[-1]})"

class MoveWaypointCommand(WaypointCommandMixin, Command):
    """
    Command to move a waypoint to a new position. Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle_id, waypoint_index, old_position, new_position):
        self.camera_processor = camera_processor
        self.vehicle_id = vehicle_id
        self.waypoint_index = waypoint_index
        self.old_position = copy.deepcopy(old_position)
        self.new_position = copy.deepcopy(new_position)
    
    def _force_waypoint_visual_refresh(self):
        """Force a visual refresh of waypoints to update colors immediately"""
        # Since waypoint colors are determined during render_waypoints_overlay based on
        # Force immediate refresh of waypoint visual state
        if hasattr(self.camera_processor, 'force_refresh'):
            self.camera_processor.force_refresh = True
        
        # Force immediate refresh of waypoint visual state
        waypoints = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        if self.waypoint_index < len(waypoints):
            waypoint = waypoints[self.waypoint_index]
            snapped_status = waypoint.get('snapped', False)
            print(f"Move command visual refresh - Vehicle {self.vehicle_id}, Waypoint {self.waypoint_index+1}, Snapped: {snapped_status}")

    def execute(self):
        # Move waypoint to new position
        context = "MoveWaypointCommand.execute"
        if not self._assert_waypoint_index(self.vehicle_id, self.waypoint_index, context):
            return False
        previous = self.camera_processor.update_waypoint_fields(
            self.vehicle_id,
            self.waypoint_index,
            self.new_position,
        )
        if previous is None:
            return False
        waypoint = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)[self.waypoint_index]
        old_snapped = previous.get('snapped', False)
        new_snapped = waypoint.get('snapped', False)
        if old_snapped != new_snapped:
            print(f"Move execute: Waypoint {self.waypoint_index+1} snapped state changed from {old_snapped} to {new_snapped}")
            self._force_waypoint_visual_refresh()
        if self.waypoint_index == 0:
            self.camera_processor._adjust_pedestrian_spawn_orientation(self.vehicle_id)
        return True

    def undo(self):
        # Move waypoint back to old position
        context = "MoveWaypointCommand.undo"
        if not self._assert_waypoint_index(self.vehicle_id, self.waypoint_index, context):
            return False
        updated = self.camera_processor.update_waypoint_fields(
            self.vehicle_id,
            self.waypoint_index,
            self.old_position,
        )
        if updated is None:
            return False
        waypoint = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)[self.waypoint_index]
        old_snapped = updated.get('snapped', False)
        new_snapped = waypoint.get('snapped', False)
        print(f"Move undo: Before update - Snapped: {old_snapped}")
        print(f"Move undo: After update - Snapped: {new_snapped}")
        if old_snapped != new_snapped:
            print(f"Move undo: Waypoint {self.waypoint_index+1} snapped state restored from {old_snapped} to {new_snapped}")
            self._force_waypoint_visual_refresh()
        if self.waypoint_index == 0:
            self.camera_processor._adjust_pedestrian_spawn_orientation(self.vehicle_id)
        return True

    def redo(self):
        # Re-execute the move (same as execute)
        context = "MoveWaypointCommand.redo"
        if not self._assert_waypoint_index(self.vehicle_id, self.waypoint_index, context):
            return False
        context = "MoveWaypointCommand.redo"
        if not self._assert_waypoint_index(self.vehicle_id, self.waypoint_index, context):
            return False
        previous = self.camera_processor.update_waypoint_fields(
            self.vehicle_id,
            self.waypoint_index,
            self.new_position,
        )
        if previous is None:
            return False
        waypoint = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)[self.waypoint_index]
        old_snapped = previous.get('snapped', False)
        new_snapped = waypoint.get('snapped', False)
        if old_snapped != new_snapped:
            print(f"Move redo: Waypoint {self.waypoint_index+1} snapped state changed from {old_snapped} to {new_snapped}")
            self._force_waypoint_visual_refresh()
        if self.waypoint_index == 0:
            self.camera_processor._adjust_pedestrian_spawn_orientation(self.vehicle_id)
        return True
    
    def get_description(self):
        return f"Move waypoint #{self.waypoint_index + 1}"

class SplitWaypointCommand(WaypointCommandMixin, Command):
    """Command that splits a waypoint into two offset copies."""

    def __init__(self, camera_processor, vehicle_id, waypoint_index, original_waypoint, offset_distance=1.5):
        self.camera_processor = camera_processor
        self.vehicle_id = vehicle_id
        self.waypoint_index = waypoint_index
        self.original_waypoint = clone_waypoint_data(original_waypoint)
        self.offset_distance = offset_distance
        self.generated_waypoints: Optional[List[WaypointData]] = None

    @staticmethod
    def _direction_and_distance(source: WaypointData, target: Optional[WaypointData]):
        if not target:
            return None, None
        dx = target['x'] - source['x']
        dy = target['y'] - source['y']
        distance = math.hypot(dx, dy)
        if distance < 1e-4:
            return None, distance
        return (dx / distance, dy / distance), distance

    def _resolve_offset(self, distance: Optional[float]) -> float:
        if distance is None or distance <= 1e-3:
            return self.offset_distance
        limited = min(self.offset_distance, distance * 0.45)
        return max(limited, 0.05)

    def _build_split_pair(self, prev_wp: Optional[WaypointData], base_wp: WaypointData, next_wp: Optional[WaypointData]):
        dir_prev, dist_prev = self._direction_and_distance(base_wp, prev_wp)
        dir_next, dist_next = self._direction_and_distance(base_wp, next_wp)

        if dir_prev is None and dir_next is not None:
            dir_prev = (-dir_next[0], -dir_next[1])
            dist_prev = dist_next
        if dir_next is None and dir_prev is not None:
            dir_next = (-dir_prev[0], -dir_prev[1])
            dist_next = dist_prev
        if dir_prev is None:
            dir_prev = (-1.0, 0.0)
        if dir_next is None:
            dir_next = (1.0, 0.0)

        offset_prev = self._resolve_offset(dist_prev)
        offset_next = self._resolve_offset(dist_next)
        origin_z = base_wp.get('z', 0.0)

        prev_split = clone_waypoint_data(base_wp)
        prev_split['x'] = base_wp['x'] + dir_prev[0] * offset_prev
        prev_split['y'] = base_wp['y'] + dir_prev[1] * offset_prev
        prev_split['z'] = origin_z
        prev_split['is_destination'] = False

        next_split = clone_waypoint_data(base_wp)
        next_split['x'] = base_wp['x'] + dir_next[0] * offset_next
        next_split['y'] = base_wp['y'] + dir_next[1] * offset_next
        next_split['z'] = origin_z
        next_split['is_destination'] = base_wp.get('is_destination', False)
        return prev_split, next_split

    def _apply_split(self, *, reuse_pair=False):
        waypoints = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        context = "SplitWaypointCommand"
        if not waypoints or self.waypoint_index < 0 or self.waypoint_index >= len(waypoints):
            print(f"[WARN] {context}: invalid waypoint index {self.waypoint_index} for vehicle {self.vehicle_id}")
            return False

        if reuse_pair:
            if not self.generated_waypoints:
                return False
            split_pair = [clone_waypoint_data(wp) for wp in self.generated_waypoints]
        else:
            prev_wp = waypoints[self.waypoint_index - 1] if self.waypoint_index > 0 else None
            next_wp = waypoints[self.waypoint_index + 1] if self.waypoint_index + 1 < len(waypoints) else None
            split_pair = list(self._build_split_pair(prev_wp, waypoints[self.waypoint_index], next_wp))
            self.generated_waypoints = [clone_waypoint_data(wp) for wp in split_pair]

        waypoints.pop(self.waypoint_index)
        waypoints.insert(self.waypoint_index, split_pair[0])
        waypoints.insert(self.waypoint_index + 1, split_pair[1])

        for index, waypoint in enumerate(waypoints):
            waypoint['index'] = index + 1
        self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True

    def execute(self):
        return self._apply_split(reuse_pair=False)

    def undo(self):
        waypoints = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        if not waypoints:
            return False
        removal_count = len(self.generated_waypoints or [])
        for _ in range(removal_count):
            if self.waypoint_index < len(waypoints):
                waypoints.pop(self.waypoint_index)
        waypoints.insert(self.waypoint_index, clone_waypoint_data(self.original_waypoint))
        for index, waypoint in enumerate(waypoints):
            waypoint['index'] = index + 1
        self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True

    def redo(self):
        return self._apply_split(reuse_pair=True)

    def get_description(self):
        return f"Split waypoint #{self.waypoint_index + 1}"

class MoveVehicleCommand(Command):
    """
    Command to move a vehicle to a new position/rotation. Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle, old_transform, new_transform):
        self.camera_processor = camera_processor
        self.vehicle_id = vehicle.id if vehicle else None
        self.old_transform = old_transform
        self.new_transform = new_transform
    
    def get_current_vehicle(self):
        """Get the current vehicle object by ID"""
        return self.camera_processor.get_spawned_vehicle(self.vehicle_id)

    def execute(self):
        # Move vehicle to new position
        vehicle = self.get_current_vehicle()
        if vehicle and self.camera_processor.assert_spawned_vehicle(self.vehicle_id, "MoveVehicleCommand.execute"):
            vehicle.set_transform(self.new_transform)
            if self.camera_processor.is_ego_vehicle(vehicle.id):
                self.camera_processor.update_editor_ego_transform(self.new_transform)
            if vehicle is self.camera_processor.selected_vehicle:
                self.camera_processor.refresh_selected_vehicle_ui()

    def undo(self):
        # Move vehicle back to old position
        vehicle = self.get_current_vehicle()
        if vehicle and self.camera_processor.assert_spawned_vehicle(self.vehicle_id, "MoveVehicleCommand.undo"):
            vehicle.set_transform(self.old_transform)
            if self.camera_processor.is_ego_vehicle(vehicle.id):
                self.camera_processor.update_editor_ego_transform(self.old_transform)
            if vehicle is self.camera_processor.selected_vehicle:
                self.camera_processor.refresh_selected_vehicle_ui()

    def redo(self):
        # Re-execute the move (same as execute)
        vehicle = self.get_current_vehicle()
        if vehicle and self.camera_processor.assert_spawned_vehicle(self.vehicle_id, "MoveVehicleCommand.redo"):
            vehicle.set_transform(self.new_transform)
            if self.camera_processor.is_ego_vehicle(vehicle.id):
                self.camera_processor.update_editor_ego_transform(self.new_transform)
            if vehicle is self.camera_processor.selected_vehicle:
                self.camera_processor.refresh_selected_vehicle_ui()
    
    def get_description(self):
        return "Move vehicle"

class UpdateWaypointPropertyCommand(WaypointCommandMixin, Command):
    """
    Command to update a property of a waypoint (e.g., position, speed, snapped state). Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle_id, waypoint_index, property_name, old_value, new_value, old_snapped=None, new_snapped=None):
        self.camera_processor = camera_processor
        self.vehicle_id = vehicle_id
        self.waypoint_index = waypoint_index
        self.property_name = property_name
        self.old_value = old_value
        self.new_value = new_value
        self.old_snapped = old_snapped  # Track snapped state changes
        self.new_snapped = new_snapped
    
    def _refresh_info_panel(self):
        """Refresh the info panel if it's showing this waypoint"""
        if (self.camera_processor.editor and 
            hasattr(self.camera_processor.editor, 'info_panel') and
            self.camera_processor.editor.info_panel.visible and
            self.camera_processor.editor.info_panel.object_type == 'waypoint' and
            self.camera_processor.editor.info_panel.waypoint_vehicle_id == self.vehicle_id and
            self.camera_processor.editor.info_panel.waypoint_index == self.waypoint_index):
            
            # Get current waypoint data
            waypoints = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
            if self.waypoint_index >= len(waypoints):
                return
            waypoint = waypoints[self.waypoint_index]
            
            # Update all relevant fields
            self.camera_processor.editor.info_panel.fields['x'] = f"{waypoint['x']:.2f}"
            self.camera_processor.editor.info_panel.fields['y'] = f"{waypoint['y']:.2f}"
            self.camera_processor.editor.info_panel.fields['z'] = f"{waypoint['z']:.2f}"
            self.camera_processor.editor.info_panel.fields['speed_km_h'] = f"{waypoint.get('speed_km_h', 50):.0f}"
            if 'speed_deviation_km_h' in self.camera_processor.editor.info_panel.fields:
                self.camera_processor.editor.info_panel.fields['speed_deviation_km_h'] = f"{waypoint.get('speed_deviation_km_h', 0):.0f}"
            if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{waypoint.get('idle_time_s', 0.0):.1f}"
            if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{waypoint.get('turn_time_s', 0.0):.1f}"
            
            # Update snapped status based on current waypoint state
            snap_status = "Snapped" if waypoint.get('snapped', False) else "Normal"
            self.camera_processor.editor.info_panel.fields['snap_status'] = snap_status
    
    def _force_waypoint_visual_refresh(self):
        """Force a visual refresh of waypoints to update colors immediately"""
        # Force immediate refresh of waypoint visual state
        if hasattr(self.camera_processor, 'force_refresh'):
            self.camera_processor.force_refresh = True
        
        # Force immediate refresh of waypoint visual state
        waypoints = self.camera_processor.get_vehicle_waypoints(self.vehicle_id)
        if self.waypoint_index < len(waypoints):
            waypoint = waypoints[self.waypoint_index]
            snapped_status = waypoint.get('snapped', False)
            print(f"Visual refresh triggered - Vehicle {self.vehicle_id}, Waypoint {self.waypoint_index+1}, Snapped: {snapped_status}")  # Debug info
    
    def execute(self):
        context = f"UpdateWaypointPropertyCommand.execute({self.property_name})"
        if not self._assert_waypoint_index(self.vehicle_id, self.waypoint_index, context):
            return False
        updates: Dict[str, Union[float, bool, str, None]] = {self.property_name: self.new_value}
        if self.new_snapped is not None:
            updates['snapped'] = self.new_snapped
        previous = self.camera_processor.update_waypoint_fields(
            self.vehicle_id,
            self.waypoint_index,
            updates,
        )
        if previous is None:
            return False
        self._refresh_info_panel()
        self._force_waypoint_visual_refresh()
        if self.waypoint_index == 0 and self.property_name in ('x', 'y', 'z'):
            self.camera_processor._adjust_pedestrian_spawn_orientation(self.vehicle_id)
        if self.property_name in ('speed_km_h', 'is_destination'):
            self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True

    def undo(self):
        context = f"UpdateWaypointPropertyCommand.undo({self.property_name})"
        if not self._assert_waypoint_index(self.vehicle_id, self.waypoint_index, context):
            return False
        updates: Dict[str, Union[float, bool, str, None]] = {self.property_name: self.old_value}
        if self.old_snapped is not None:
            updates['snapped'] = self.old_snapped
        previous = self.camera_processor.update_waypoint_fields(
            self.vehicle_id,
            self.waypoint_index,
            updates,
        )
        if previous is None:
            return False
        self._refresh_info_panel()
        self._force_waypoint_visual_refresh()
        if self.waypoint_index == 0 and self.property_name in ('x', 'y', 'z'):
            self.camera_processor._adjust_pedestrian_spawn_orientation(self.vehicle_id)
        if self.property_name in ('speed_km_h', 'is_destination'):
            self.camera_processor._cache_destination_speed(self.vehicle_id)
        return True

    def redo(self):
        # Re-execute the update
        return self.execute()
    
    def get_description(self):
        if self.old_snapped != self.new_snapped and self.property_name in ['x', 'y', 'z']:
            return f"Update waypoint {self.property_name}: {self.old_value} -> {self.new_value} (unsnapped)"
        else:
            return f"Update waypoint {self.property_name}: {self.old_value} -> {self.new_value}"

class UpdateVehiclePropertyCommand(Command):
    """
    Command to update a property of a vehicle (e.g., position, speed, yaw). Supports undo/redo.
    """
    def __init__(self, camera_processor, vehicle_id, property_name, old_value, new_value, old_transform=None, new_transform=None):
        self.camera_processor = camera_processor
        self.vehicle_id = vehicle_id
        self.property_name = property_name
        self.old_value = old_value
        self.new_value = new_value
        self.old_transform = old_transform
        self.new_transform = new_transform
    
    def get_current_vehicle(self):
        """Get the current vehicle object by ID"""
        return self.camera_processor.get_spawned_vehicle(self.vehicle_id)
    
    def _refresh_info_panel(self):
        """Refresh the info panel if it's showing this vehicle"""
        if (self.camera_processor.editor and 
            hasattr(self.camera_processor.editor, 'info_panel') and
            self.camera_processor.editor.info_panel.visible and
            self.camera_processor.editor.info_panel.object_type in ('vehicle', 'pedestrian')):
            
            vehicle = self.get_current_vehicle()
            if vehicle and self.camera_processor.editor.info_panel.selected_object == vehicle:
                # Refresh the fields to show current values
                idle = self.camera_processor.get_actor_idle_time(vehicle.id, 0.0)
                turn = self.camera_processor.get_actor_turn_time(vehicle.id, 0.0)

                if self.property_name == 'speed_km_h':
                    self.camera_processor.editor.info_panel.fields['speed_km_h'] = str(int(self.new_value))
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{idle:.1f}"
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{turn:.1f}"
                elif self.property_name == 'idle_time_s':
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{self.new_value:.1f}"
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{turn:.1f}"
                elif self.property_name == 'turn_time_s':
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{self.new_value:.1f}"
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{idle:.1f}"
                elif self.property_name == 'max_lat_acc':
                    if 'max_lat_acc' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['max_lat_acc'] = f"{self.new_value:.2f}"
                else:
                    # For coordinate updates, get current transform and update fields
                    transform = vehicle.get_transform()
                    self.camera_processor.editor.info_panel.fields['x'] = f"{transform.location.x:.2f}"
                    self.camera_processor.editor.info_panel.fields['y'] = f"{transform.location.y:.2f}"
                    self.camera_processor.editor.info_panel.fields['z'] = f"{transform.location.z:.2f}"
                    self.camera_processor.editor.info_panel.fields['yaw'] = f"{transform.rotation.yaw:.2f}"
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{idle:.1f}"
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{turn:.1f}"

    def execute(self):
        # Update vehicle property
        vehicle = self.get_current_vehicle()
        if vehicle and self.camera_processor.assert_spawned_vehicle(self.vehicle_id, f"UpdateVehiclePropertyCommand.execute({self.property_name})"):
            if self.property_name == 'speed_km_h':
                self.camera_processor.set_vehicle_speed(vehicle.id, self.new_value)
            elif self.property_name == 'idle_time_s':
                self.camera_processor.set_actor_idle_time(vehicle.id, self.new_value)
            elif self.property_name == 'turn_time_s':
                self.camera_processor.set_actor_turn_time(vehicle.id, self.new_value)
            elif self.property_name == 'max_lat_acc':
                self.camera_processor.set_vehicle_max_lat_acc(vehicle.id, self.new_value)
            elif self.new_transform:
                vehicle.set_transform(self.new_transform)
                if self.camera_processor.is_ego_vehicle(vehicle.id):
                    self.camera_processor.update_editor_ego_transform(self.new_transform)
                if vehicle is self.camera_processor.selected_vehicle:
                    self.camera_processor.refresh_selected_vehicle_ui()
            self._refresh_info_panel()

    def undo(self):
        # Restore old value
        vehicle = self.get_current_vehicle()
        if vehicle and self.camera_processor.assert_spawned_vehicle(self.vehicle_id, f"UpdateVehiclePropertyCommand.undo({self.property_name})"):
            if self.property_name == 'speed_km_h':
                self.camera_processor.set_vehicle_speed(vehicle.id, self.old_value)
            elif self.property_name == 'idle_time_s':
                self.camera_processor.set_actor_idle_time(vehicle.id, self.old_value)
            elif self.property_name == 'turn_time_s':
                self.camera_processor.set_actor_turn_time(vehicle.id, self.old_value)
            elif self.property_name == 'max_lat_acc':
                self.camera_processor.set_vehicle_max_lat_acc(vehicle.id, self.old_value)
            elif self.old_transform:
                vehicle.set_transform(self.old_transform)
                if self.camera_processor.is_ego_vehicle(vehicle.id):
                    self.camera_processor.update_editor_ego_transform(self.old_transform)
                if vehicle is self.camera_processor.selected_vehicle:
                    self.camera_processor.refresh_selected_vehicle_ui()
            
            # Update info panel to show old value
            if (self.camera_processor.editor and 
                hasattr(self.camera_processor.editor, 'info_panel') and
                self.camera_processor.editor.info_panel.visible and
                self.camera_processor.editor.info_panel.object_type in ('vehicle', 'pedestrian') and
                self.camera_processor.editor.info_panel.selected_object == vehicle):
                
                if self.property_name == 'speed_km_h':
                    self.camera_processor.editor.info_panel.fields['speed_km_h'] = str(int(self.old_value))
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        idle = self.camera_processor.get_actor_idle_time(vehicle.id, 0.0)
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{idle:.1f}"
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        turn = self.camera_processor.get_actor_turn_time(vehicle.id, 0.0)
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{turn:.1f}"
                elif self.property_name == 'idle_time_s':
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{self.old_value:.1f}"
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        turn = self.camera_processor.get_actor_turn_time(vehicle.id, 0.0)
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{turn:.1f}"
                elif self.property_name == 'turn_time_s':
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{self.old_value:.1f}"
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        idle = self.camera_processor.get_actor_idle_time(vehicle.id, 0.0)
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{idle:.1f}"
                elif self.property_name == 'max_lat_acc':
                    if 'max_lat_acc' in self.camera_processor.editor.info_panel.fields:
                        self.camera_processor.editor.info_panel.fields['max_lat_acc'] = f"{self.old_value:.2f}"
                else:
                    # For coordinate updates, show old transform values
                    self.camera_processor.editor.info_panel.fields['x'] = f"{self.old_transform.location.x:.2f}"
                    self.camera_processor.editor.info_panel.fields['y'] = f"{self.old_transform.location.y:.2f}"
                    self.camera_processor.editor.info_panel.fields['z'] = f"{self.old_transform.location.z:.2f}"
                    self.camera_processor.editor.info_panel.fields['yaw'] = f"{self.old_transform.rotation.yaw:.2f}"
                    if 'idle_time_s' in self.camera_processor.editor.info_panel.fields:
                        idle = self.camera_processor.get_actor_idle_time(vehicle.id, 0.0)
                        self.camera_processor.editor.info_panel.fields['idle_time_s'] = f"{idle:.1f}"
                    if 'turn_time_s' in self.camera_processor.editor.info_panel.fields:
                        turn = self.camera_processor.get_actor_turn_time(vehicle.id, 0.0)
                        self.camera_processor.editor.info_panel.fields['turn_time_s'] = f"{turn:.1f}"
    
    def redo(self):
        # Re-execute the update
        self.execute()
    
    def get_description(self):
        if self.property_name == 'speed_km_h':
            return f"Update vehicle speed: {self.old_value}km/h -> {self.new_value}km/h"
        else:
            return f"Update vehicle {self.property_name}: {self.old_value} -> {self.new_value}"

class MovePersonalTriggerCommand(Command):
    """Command to move a personal trigger (pedestrian, vehicle, or traffic-light)."""
    def __init__(self, camera_processor, selection, old_center, new_center, radius=None):
        self.camera_processor = camera_processor
        self.selection = dict(selection) if selection else None
        self.old_center = dict(old_center) if old_center else None
        self.new_center = dict(new_center) if new_center else None
        self.radius = float(radius) if radius is not None else None

    def _apply_center(self, center):
        if not center or not self.selection or not self.camera_processor:
            return False
        cp = self.camera_processor
        kind = self.selection.get('kind')
        if kind == 'pedestrian':
            actor_id = self.selection.get('id')
            if actor_id is None:
                return False
            cp.pedestrian_trigger_centers[actor_id] = dict(center)
        elif kind == 'vehicle':
            actor_id = self.selection.get('id')
            if actor_id is None:
                return False
            cp.vehicle_trigger_centers[actor_id] = dict(center)
        elif kind == 'traffic_light':
            group = self.selection.get('group')
            key = self.selection.get('key')
            radius = self.radius
            if radius is None:
                _, radius = cp._get_personal_trigger_payload(self.selection)
            if radius is None:
                radius = DEFAULT_PERSONAL_TRIGGER_RADIUS
            resolved_key = cp._set_traffic_light_trigger_data(
                dict(center),
                radius,
                key=key,
                group=group,
            )
            if resolved_key and resolved_key != key:
                self.selection['key'] = resolved_key
            if not group and resolved_key:
                found_group = cp._find_traffic_light_group_by_key(resolved_key)
                if found_group:
                    self.selection['group'] = found_group
        else:
            return False
        cp.update_personal_trigger_menu_position(force=True)
        return True

    def execute(self):
        return self._apply_center(self.new_center)

    def undo(self):
        return self._apply_center(self.old_center)

    def redo(self):
        return self.execute()

    def get_description(self):
        if not self.selection:
            return "Move personal trigger"
        kind = self.selection.get('kind')
        if kind in ('pedestrian', 'vehicle'):
            actor_id = self.selection.get('id', 'unknown')
            label = "pedestrian" if kind == 'pedestrian' else "vehicle"
            return f"Move {label} trigger ({actor_id})"
        if kind == 'traffic_light':
            return "Move traffic-light trigger"
        return "Move personal trigger"

class SetPersonalTriggerCommand(Command):
    """Command to create or update a personal trigger with undo/redo support."""

    def __init__(self, camera_processor, selection, new_center, new_radius, old_center=None, old_radius=None):
        self.camera_processor = camera_processor
        self.selection = dict(selection) if selection else None
        self.new_center = dict(new_center) if new_center is not None else None
        self.new_radius = float(new_radius) if new_radius is not None else None
        self.old_center = dict(old_center) if old_center is not None else None
        self.old_radius = float(old_radius) if old_radius is not None else None

    def _apply(self, center, radius):
        if not self.selection or not self.camera_processor:
            return False

        cp = self.camera_processor
        kind = self.selection.get('kind')
        radius_value = None if radius is None else max(MIN_PERSONAL_TRIGGER_RADIUS, float(radius))

        if kind == 'pedestrian':
            actor_id = self.selection.get('id')
            if actor_id is None:
                return False
            if center is None or radius_value is None:
                cp.pedestrian_trigger_centers.pop(actor_id, None)
                cp.pedestrian_trigger_radii.pop(actor_id, None)
                return True
            if not cp._ensure_pedestrian_trigger(actor_id):
                return False
            cp.pedestrian_trigger_centers[actor_id] = dict(center)
            cp.pedestrian_trigger_radii[actor_id] = radius_value
            return True

        if kind == 'vehicle':
            actor_id = self.selection.get('id')
            if actor_id is None:
                return False
            if center is None or radius_value is None:
                cp.vehicle_trigger_centers.pop(actor_id, None)
                cp.vehicle_trigger_radii.pop(actor_id, None)
                return True
            if not cp._ensure_vehicle_trigger(actor_id):
                return False
            cp.vehicle_trigger_centers[actor_id] = dict(center)
            cp.vehicle_trigger_radii[actor_id] = radius_value
            return True

        if kind == 'traffic_light':
            group = self.selection.get('group')
            key = self.selection.get('key')
            if center is None or radius_value is None:
                return cp._delete_traffic_light_trigger_data(key=key, group=group)
            resolved_key = cp._set_traffic_light_trigger_data(
                dict(center),
                radius_value,
                key=key,
                group=group,
            )
            if resolved_key and resolved_key != key:
                self.selection['key'] = resolved_key
            return True

        return False

    def execute(self):
        return self._apply(self.new_center, self.new_radius)

    def undo(self):
        return self._apply(self.old_center, self.old_radius)

    def redo(self):
        return self.execute()

    def get_description(self):
        if not self.selection:
            return "Update trigger"

        kind = self.selection.get('kind')
        action = "Update"
        if self.old_center is None and self.old_radius is None:
            action = "Place"

        if kind == 'pedestrian':
            actor_id = self.selection.get('id', 'unknown')
            return f"{action} pedestrian trigger ({actor_id})"
        if kind == 'vehicle':
            actor_id = self.selection.get('id', 'unknown')
            return f"{action} vehicle trigger ({actor_id})"
        if kind == 'traffic_light':
            return f"{action} traffic-light trigger"
        return f"{action} trigger"

class SetGlobalTriggerCommand(Command):
    """Command to create/update/delete the single global trigger with undo/redo support."""

    def __init__(self, camera_processor, old_trigger, new_trigger, *, preserve_selection=False, description=None):
        self.camera_processor = camera_processor
        self.old_trigger = copy.deepcopy(old_trigger) if old_trigger else None
        self.new_trigger = copy.deepcopy(new_trigger) if new_trigger else None
        self.preserve_selection = preserve_selection
        self.description = description or "Update trigger"

    def _apply(self, trigger_payload):
        cp = self.camera_processor
        if not cp:
            return False
        cp.triggers.clear()
        cp.selected_trigger_index = None
        cp.trigger_action_menu_position = None
        cp.trigger_menu_hidden_for_camera_pan = False

        if trigger_payload:
            cp.triggers.append(copy.deepcopy(trigger_payload))
            if self.preserve_selection:
                cp.selected_trigger_index = 0
                screen_pos = cp.coordinate_detector.world_to_screen_coordinates(
                    trigger_payload['x'],
                    trigger_payload['y'],
                    trigger_payload['z'],
                )
                if screen_pos.get('success'):
                    cp.trigger_action_menu_position = (int(screen_pos['x']), int(screen_pos['y']))
        return True

    def execute(self):
        return self._apply(self.new_trigger)

    def undo(self):
        return self._apply(self.old_trigger)

    def redo(self):
        return self.execute()

    def get_description(self):
        return self.description

class WeatherEditCommand(Command):
    """Command to mutate weather keyframes/state with undo/redo support."""

    def __init__(
        self,
        editor,
        old_keyframes,
        new_keyframes,
        old_active_index,
        new_active_index,
        old_pending_pct,
        new_pending_pct,
        description: str = "Update weather",
    ):
        self.editor = editor
        self.old_keyframes = copy.deepcopy(old_keyframes) if old_keyframes is not None else []
        self.new_keyframes = copy.deepcopy(new_keyframes) if new_keyframes is not None else []
        self.old_active_index = int(old_active_index) if old_active_index is not None else 0
        self.new_active_index = int(new_active_index) if new_active_index is not None else 0
        self.old_pending_pct = float(old_pending_pct) if old_pending_pct is not None else 0.0
        self.new_pending_pct = float(new_pending_pct) if new_pending_pct is not None else 0.0
        self.description = description
        self._noop = (
            self.old_keyframes == self.new_keyframes
            and self.old_active_index == self.new_active_index
            and abs(self.old_pending_pct - self.new_pending_pct) < 1e-6
        )

    def _apply(self, keyframes, active_index, pending_pct):
        ed = self.editor
        if not ed:
            return False
        try:
            sanitized = ed._sanitize_weather_keyframes_payload(keyframes)
        except Exception:
            sanitized = []
        if not sanitized:
            return False

        active_index = max(0, min(active_index, len(sanitized) - 1))
        ed._weather_keyframes = sanitized
        ed._active_weather_index = active_index
        ed._pending_weather_pct = float(max(0.0, min(100.0, pending_pct)))

        weather = None
        try:
            weather = ed._weather_params_from_dict(sanitized[active_index])
            if ed.world:
                ed.world.set_weather(weather)
            ed._update_weather_state(weather, keyframe_index=active_index)
        except Exception as exc:
            print(f"[Weather] Failed to apply weather during undo/redo: {exc}")
        ed._refresh_weather_window_metadata()
        if ed.weather_window and ed.weather_window.alive():
            try:
                ed.weather_window.apply_weather(ed.world.get_weather() if ed.world else weather)
            except Exception:
                pass
        return True

    def execute(self):
        if self._noop:
            return False
        return self._apply(self.new_keyframes, self.new_active_index, self.new_pending_pct)

    def undo(self):
        return self._apply(self.old_keyframes, self.old_active_index, self.old_pending_pct)

    def redo(self):
        return self.execute()

    def get_description(self):
        return self.description

class UpdateTrafficLightSequenceCommand(Command):
    """Command to update a traffic-light group's sequence with undo/redo support."""

    def __init__(self, camera_processor, group, old_sequence, new_sequence):
        self.camera_processor = camera_processor
        self.old_sequence = copy.deepcopy(old_sequence) if old_sequence is not None else []
        self.new_sequence = copy.deepcopy(new_sequence) if new_sequence is not None else []
        self.group_key = None
        self.group_ids = None
        if group:
            self.group_key = camera_processor._traffic_light_trigger_key(group=group)
            try:
                self.group_ids = tuple(sorted(group.ids))
            except Exception:
                self.group_ids = None

    def _resolve_group(self):
        cp = self.camera_processor
        if not cp:
            return None
        if self.group_key:
            group = cp._find_traffic_light_group_by_key(self.group_key)
            if group:
                return group
        if self.group_ids:
            for group in cp.traffic_light_groups:
                try:
                    if tuple(sorted(group.ids)) == self.group_ids:
                        return group
                except Exception:
                    continue
        return None

    def _apply(self, sequence_payload):
        group = self._resolve_group()
        if not group:
            return False
        group.sequence = copy.deepcopy(sequence_payload)
        if self.camera_processor:
            self.camera_processor._cache_traffic_light_sequence(group)
        return True

    def execute(self):
        return self._apply(self.new_sequence)

    def undo(self):
        return self._apply(self.old_sequence)

    def redo(self):
        return self.execute()

    def get_description(self):
        return "Update traffic-light sequence"

############################################################
# World Coordinate Utilities
############################################################

class WorldCoordinateDetector:
    """
    Handles conversion between screen and world coordinates, lane snapping, and click detection for vehicles and waypoints.
    """

    def __init__(self, world, camera_controller):
        self.world = world
        self.world_map = None  # Lazy-load to avoid OpenDRIVE segfault after map changes
        self.camera_controller = camera_controller
        self.editor = None
        self.traffic_lights: List[carla.Actor] = []

    def get_world_map(self):
        """Lazy-load world map with retry logic to avoid OpenDRIVE segfaults"""
        if self.world_map is not None:
            return self.world_map

        editor_cached = getattr(self, 'editor', None)
        if editor_cached is not None:
            cached_map = getattr(editor_cached, 'cached_map', None)
            if cached_map is not None:
                self.world_map = cached_map
                return self.world_map
            if getattr(editor_cached, '_map_refresh_disabled', False):
                return None

        # Try to get map with retries
        max_attempts = 3
        for attempt in range(max_attempts):
            try:
                self.world_map = self.world.get_map()
                return self.world_map
            except Exception as e:
                if attempt < max_attempts - 1:
                    print(f"Failed to get map (attempt {attempt + 1}/{max_attempts}): {e}")
                    time.sleep(2)
                else:
                    print(f"WARNING: Could not load world map after {max_attempts} attempts")
                    return None
        return None
        
    def build_projection_matrix(self, w, h, fov):
        """Build the camera intrinsic matrix K following CARLA's conventions"""
        focal = w / (2.0 * np.tan(fov * np.pi / 360.0))
        K = np.identity(3)
        K[0, 0] = K[1, 1] = focal
        K[0, 2] = w / 2.0
        K[1, 2] = h / 2.0
        return K
    
    def get_image_point(self, loc, K, w2c):
        """Project 3D world point to 2D image coordinates (for verification)"""
        # Format the input coordinate
        point = np.array([loc.x, loc.y, loc.z, 1])
        
        # Transform to camera coordinates
        point_camera = np.dot(w2c, point)
        
        # CRITICAL: Change from UE4's coordinate system to standard camera coordinates
        # (x, y, z) -> (y, -z, x)
        point_camera = np.array([point_camera[1], -point_camera[2], point_camera[0]])
        
        # Project 3D->2D using the camera matrix
        point_img = np.dot(K, point_camera)
        
        # Normalize
        if point_img[2] != 0:
            point_img[0] /= point_img[2]
            point_img[1] /= point_img[2]
        
        return point_img[0:2]
    
    def screen_to_world_coordinates(self, screen_x, screen_y, screen_width, screen_height):
        """Convert screen coordinates to world coordinates using proper CARLA transformations"""
        try:
            # Get camera transform
            camera_transform = self.camera_controller.get_carla_transform()
            camera_location = camera_transform.location
            debug_mode = bool(getattr(self, "debug_raycast", False))
            
            # Build the intrinsic matrix
            fov = 90.0  # Your camera FOV
            K = self.build_projection_matrix(screen_width, screen_height, fov)
            
            # Get world-to-camera transformation matrix
            world_2_camera = np.array(camera_transform.get_inverse_matrix())
            
            # For a top-down camera, we'll use raycasting with proper transformations
            # Convert screen coordinates to normalized image coordinates
            u = screen_x
            v = screen_y
            
            # Get inverse of intrinsic matrix
            K_inv = np.linalg.inv(K)
            
            # Convert pixel to normalized camera coordinates
            pixel_coords = np.array([u, v, 1.0])
            cam_coords = np.dot(K_inv, pixel_coords)
            
            # For CARLA's coordinate system, we need to reverse the UE4 transformation
            # Standard camera coords (x,y,z) to UE4 coords needs reverse of (y,-z,x)
            # So: cam(x,y,z) -> UE4(z, x, -y)
            ue4_ray_dir = np.array([cam_coords[2], cam_coords[0], -cam_coords[1], 0])
            
            # Get camera-to-world transformation (inverse of world-to-camera)
            camera_2_world = np.linalg.inv(world_2_camera)
            
            # Transform ray direction to world space
            world_ray = np.dot(camera_2_world, ue4_ray_dir)
            
            # Normalize the direction (ignore the homogeneous coordinate)
            ray_dir = world_ray[:3]
            ray_length = np.linalg.norm(ray_dir)
            if ray_length > 0:
                ray_dir = ray_dir / ray_length
            
            # Cast ray from camera position
            ray_start = camera_location
            ray_distance = abs(camera_location.z) + 100  # Ensure we reach the ground
            
            ray_end = carla.Location(
                camera_location.x + ray_dir[0] * ray_distance,
                camera_location.y + ray_dir[1] * ray_distance,
                camera_location.z + ray_dir[2] * ray_distance
            )
            
            # Perform raycast
            hit_result, hit_meta = cast_ray_with_tile_offset_compensation(
                self.world,
                ray_start,
                ray_end,
                cached_map=self.get_world_map() if debug_mode else None,
                probe_on_miss=False,
                debug=debug_mode,
            )

            def _intersect_ray_with_z(target_z: float):
                if abs(ray_dir[2]) <= 0.001:
                    return None
                t = (target_z - camera_location.z) / ray_dir[2]
                if t <= 0:
                    return None
                return (
                    camera_location.x + ray_dir[0] * t,
                    camera_location.y + ray_dir[1] * t,
                )

            if hit_result:
                hit_location = hit_result[0].location
                hit_z = float(hit_location.z)
                xy = _intersect_ray_with_z(hit_z)
                if xy is None:
                    # Fallback: use raw hit values if intersection math is degenerate.
                    xy = (float(hit_location.x), float(hit_location.y))
                if debug_mode:
                    corrected = bool(hit_meta.get('corrected', False))
                    offset_guess = hit_meta.get('offset_guess_xy', (0.0, 0.0))
                    correction_note = ""
                    if corrected:
                        correction_note = f" [tile+({float(offset_guess[0]):.0f},{float(offset_guess[1]):.0f})]"
                    print(
                        f"[Raycast] Hit: z={hit_z:.2f} "
                        f"(raw=({hit_location.x:.2f},{hit_location.y:.2f},{hit_location.z:.2f})) "
                        f"(proj=({xy[0]:.2f},{xy[1]:.2f},{hit_z:.2f})){correction_note}"
                    )
                return {
                    'x': xy[0],
                    'y': xy[1],
                    'z': hit_z,
                    'success': True,
                }

            # No ray hit: estimate ground Z (usually OpenDRIVE height), then intersect the ray
            # with that plane to avoid large-map "overshoot" when the map isn't raycastable.
            xy0 = _intersect_ray_with_z(0.0)
            if xy0 is None:
                return {'success': False, 'error': 'No intersection found'}

            estimated_z = 0.0
            world_map = self.get_world_map()
            if world_map is not None:
                try:
                    waypoint = world_map.get_waypoint(
                        carla.Location(float(xy0[0]), float(xy0[1]), 0.0),
                        project_to_road=True,
                        lane_type=carla.LaneType.Driving | carla.LaneType.Sidewalk,
                    )
                except Exception:
                    waypoint = None
                if waypoint is not None:
                    estimated_z = float(waypoint.transform.location.z)

            xy1 = _intersect_ray_with_z(estimated_z)
            if xy1 is None:
                xy1 = xy0

            # Optional one-step refinement: re-sample height at the refined XY and re-intersect.
            if world_map is not None and estimated_z != 0.0:
                try:
                    waypoint2 = world_map.get_waypoint(
                        carla.Location(float(xy1[0]), float(xy1[1]), estimated_z),
                        project_to_road=True,
                        lane_type=carla.LaneType.Driving | carla.LaneType.Sidewalk,
                    )
                except Exception:
                    waypoint2 = None
                if waypoint2 is not None:
                    refined_z = float(waypoint2.transform.location.z)
                    if abs(refined_z - estimated_z) > 0.05:
                        xy2 = _intersect_ray_with_z(refined_z)
                        if xy2 is not None:
                            xy1 = xy2
                            estimated_z = refined_z

            if debug_mode:
                print(
                    f"[Raycast] Miss: z0=0.00 -> z_est={estimated_z:.2f} "
                    f"(xy0=({xy0[0]:.2f},{xy0[1]:.2f})) "
                    f"(xy=({xy1[0]:.2f},{xy1[1]:.2f}))"
                )

            return {
                'x': float(xy1[0]),
                'y': float(xy1[1]),
                'z': float(estimated_z),
                'success': True,
                'estimated': True,
            }
                
        except Exception as e:
            print(f"Error in coordinate detection: {e}")
            traceback.print_exc()
            return {'success': False, 'error': str(e)}
    
    def screen_to_world_coordinates_no_raycast(self, screen_x, screen_y, screen_width, screen_height, fixed_z=0.0, cache=None):
        """
        Optimized: Use optional cache for camera transform and matrix calculations if called repeatedly within a frame.
        """
        try:
            if cache is None:
                cache = {}
            # Use cached camera transform and matrices if available
            if 'camera_transform' not in cache:
                cache['camera_transform'] = self.camera_controller.get_carla_transform()
            camera_transform = cache['camera_transform']
            camera_location = camera_transform.location

            if 'K' not in cache:
                fov = 90.0
                cache['K'] = self.build_projection_matrix(screen_width, screen_height, fov)
            K = cache['K']

            if 'world_2_camera' not in cache:
                cache['world_2_camera'] = np.array(camera_transform.get_inverse_matrix())
            world_2_camera = cache['world_2_camera']

            if 'K_inv' not in cache:
                cache['K_inv'] = np.linalg.inv(K)
            K_inv = cache['K_inv']

            u = screen_x
            v = screen_y
            pixel_coords = np.array([u, v, 1.0])
            cam_coords = np.dot(K_inv, pixel_coords)
            ue4_ray_dir = np.array([cam_coords[2], cam_coords[0], -cam_coords[1], 0])

            if 'camera_2_world' not in cache:
                cache['camera_2_world'] = np.linalg.inv(world_2_camera)
            camera_2_world = cache['camera_2_world']

            world_ray = np.dot(camera_2_world, ue4_ray_dir)
            ray_dir = world_ray[:3]
            ray_length = np.linalg.norm(ray_dir)
            if ray_length > 0:
                ray_dir = ray_dir / ray_length

            if abs(ray_dir[2]) > 0.001:
                t = (fixed_z - camera_location.z) / ray_dir[2]
                if t > 0:
                    world_x = camera_location.x + ray_dir[0] * t
                    world_y = camera_location.y + ray_dir[1] * t
                    return {
                        'x': world_x,
                        'y': world_y,
                        'z': fixed_z,
                        'success': True
                    }
            return {'success': False, 'error': 'Invalid ray direction'}
        except Exception as e:
            print(f"Error in fast coordinate detection: {e}")
            return {'success': False, 'error': str(e)}
    
    def find_closest_lane_point(self, x, y, z):
        """Find the closest point on a lane to the given coordinates"""
        try:
            world_map = self.get_world_map()
            if not world_map:
                return None

            location = carla.Location(x, y, z)
            waypoint = world_map.get_waypoint(location,
                                              project_to_road=True,
                                              lane_type=carla.LaneType.Driving | carla.LaneType.Sidewalk)

            if waypoint:
                # Get lane direction from waypoint
                yaw = waypoint.transform.rotation.yaw

                # Use OpenDRIVE height directly (global coordinates, works correctly on large maps)
                # This matches the OpenDRIVE overlay and avoids tile-local coordinate issues
                ground_height = waypoint.transform.location.z

                return {
                    'x': waypoint.transform.location.x,
                    'y': waypoint.transform.location.y,
                    'z': ground_height,  # Use OpenDRIVE height (global coordinates)
                    'road_id': waypoint.road_id,
                    'lane_id': waypoint.lane_id,
                    'yaw': yaw,  # Lane direction
                    'lane_width': waypoint.lane_width,
                    'success': True
                }
            else:
                return {'success': False, 'error': 'No lane found'}
        except Exception as e:
            print(f"Error finding closest lane: {e}")
            return {'success': False, 'error': str(e)}
    
    def find_closest_lane_point_fast(self, x, y, z):
        """Find the closest point on a lane without using raycast (for fast movement updates)"""
        try:
            world_map = self.get_world_map()
            if not world_map:
                return None

            location = carla.Location(x, y, z)
            waypoint = world_map.get_waypoint(location,
                                              project_to_road=True,
                                              lane_type=carla.LaneType.Driving | carla.LaneType.Sidewalk)
            
            if waypoint:
                # Get lane direction from waypoint
                yaw = waypoint.transform.rotation.yaw
                
                # Use OpenDRIVE height (fast, no raycast)
                return {
                    'x': waypoint.transform.location.x,
                    'y': waypoint.transform.location.y,
                    'z': waypoint.transform.location.z,  # Use OpenDRIVE height for fast updates
                    'road_id': waypoint.road_id,
                    'lane_id': waypoint.lane_id,
                    'yaw': yaw,  # Lane direction
                    'lane_width': waypoint.lane_width,
                    'success': True
                }
            else:
                return {'success': False, 'error': 'No lane found'}
        except Exception as e:
            print(f"Error finding closest lane (fast): {e}")
            return {'success': False, 'error': str(e)}
    
    def move_camera_to_screen_position(self, screen_x, screen_y, screen_width, screen_height):
        """Move camera to the world position corresponding to screen click"""
        try:
            # Get the world coordinates at the click position
            coordinates = self.screen_to_world_coordinates_no_raycast(
                screen_x,
                screen_y,
                screen_width,
                screen_height,
                fixed_z=0.0,
            )
            
            if coordinates['success']:
                # Move camera to be above the clicked location
                self.camera_controller.center_x = coordinates['x']
                self.camera_controller.center_y = coordinates['y']
                
                print(f"Camera moved to: ({coordinates['x']:.2f}, {coordinates['y']:.2f})")
            else:
                print("Could not determine world position for camera movement")
                
        except Exception as e:
            print(f"Error moving camera: {e}")
    
    def world_to_screen_coordinates(self, world_x, world_y, world_z):
        """Convert world coordinates to screen coordinates"""
        try:
            # Get camera transform
            camera_transform = self.camera_controller.get_carla_transform()
            
            # Build the projection matrix
            fov = 90.0
            K = self.build_projection_matrix(self.screen_width, self.screen_height, fov)
            
            # Get world-to-camera transformation matrix
            world_2_camera = np.array(camera_transform.get_inverse_matrix())
            
            # Create world point
            world_point = carla.Location(world_x, world_y, world_z)
            
            # Project to screen
            screen_point = self.get_image_point(world_point, K, world_2_camera)
            
            return {
                'x': screen_point[0],
                'y': screen_point[1],
                'success': True
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def check_vehicle_click(self, screen_x, screen_y):
        """Check if a click hits any spawned vehicle"""
        # Convert click to world coordinates
        world_coords = self.screen_to_world_coordinates(screen_x, screen_y, self.screen_width, self.screen_height)
        
        if not world_coords['success']:
            return None
        
        click_location = carla.Location(world_coords['x'], world_coords['y'], world_coords['z'])
        
        # Check each spawned vehicle
        for vehicle in self.spawned_vehicles:
            if vehicle and vehicle.is_alive:
                vehicle_location = vehicle.get_location()
                
                # Get vehicle bounding box
                bbox = vehicle.bounding_box
                vehicle_extent = bbox.extent
                
                # Check if click is within vehicle bounds (2D check with some tolerance)
                dx = abs(click_location.x - vehicle_location.x)
                dy = abs(click_location.y - vehicle_location.y)
                
                # Slightly larger tolerance to make selection easier
                tolerance = 1.0
                if (dx <= vehicle_extent.x + tolerance and 
                    dy <= vehicle_extent.y + tolerance):
                    return vehicle
        
        return None
    
    def draw_waypoints_carla_debug(self, waypoint_list, waypoint_display_vehicle_id, spawned_vehicles, 
                                   selected_vehicle_id=None, selected_waypoint_index=None, 
                                   hovered_waypoint=None, coordinate_detector=None):
        """Draw waypoints using CARLA's built-in debug drawing system with very short lifetimes"""
        if not waypoint_display_vehicle_id or waypoint_display_vehicle_id not in waypoint_list:
            return
            
        waypoints = waypoint_list[waypoint_display_vehicle_id]
        if not waypoints:
            return
            
        # Find the vehicle for this waypoint set
        vehicle = None
        for spawned_vehicle in spawned_vehicles:
            if spawned_vehicle.id == waypoint_display_vehicle_id:
                vehicle = spawned_vehicle
                break
                
        if not vehicle or not vehicle.is_alive:
            return
            
        # Draw connection lines first (so they appear behind markers)
        self._draw_waypoint_connections_carla_debug(vehicle, waypoints)
        
        # Draw starting point marker if vehicle is hidden for scenario
        start_point = self._get_start_marker_for_vehicle(vehicle)
        if start_point:
            start_location = carla.Location(start_point['x'], start_point['y'], start_point['z'] + 0.5)

            # Draw starting point marker with distinct appearance
            self.world.debug.draw_point(
                start_location,
                size=0.5,
                color=carla.Color(255, 0, 255),  # Magenta for starting point
                life_time=self.waypoint_debug_lifetime
            )
            
            # Draw "START" text above the marker
            text_location = carla.Location(start_point['x'], start_point['y'], start_point['z'] + 2.0)
            self.world.debug.draw_string(
                text_location,
                "START",
                draw_shadow=True,
                color=carla.Color(255, 0, 255),  # Magenta text
                life_time=self.waypoint_debug_lifetime,
                persistent_lines=False
            )
        
        # Draw waypoint markers
        for i, waypoint in enumerate(waypoints):
            # Determine waypoint state and colors
            is_selected = (selected_vehicle_id == waypoint_display_vehicle_id and 
                          selected_waypoint_index == i)
            is_hovered = (hovered_waypoint and hovered_waypoint[0] == waypoint_display_vehicle_id and 
                         hovered_waypoint[1] == i)
            is_finish_line = (i == len(waypoints) - 1)
            
            # Choose colors based on waypoint properties and state
            base_color = carla.Color(0, 255, 0)    # Always green for NPC waypoints
                
            # Modify color based on state
            if is_finish_line and not is_selected:
                marker_color = carla.Color(255, 50, 50)  # Red for finish line
            elif is_selected:
                marker_color = carla.Color(255, 255, 0)  # Yellow for selected
            elif is_hovered:
                marker_color = carla.Color(255, 200, 0)  # Orange for hovered
            else:
                marker_color = base_color
                
            # Create waypoint location
            location = carla.Location(waypoint['x'], waypoint['y'], waypoint['z'] + 0.5)
            
            # Draw different markers based on type
            if is_finish_line:
                self._draw_finish_line_carla_debug(location, waypoints, i, is_selected, is_hovered)
            else:
                # Draw main waypoint marker (slightly bigger for better visibility)
                marker_size = 0.4 if is_selected or is_hovered else 0.3
                self.world.debug.draw_point(
                    location,
                    size=marker_size,
                    color=marker_color,
                    life_time=self.waypoint_debug_lifetime
                )
                
                # Draw waypoint number above the marker
                text_location = carla.Location(waypoint['x'], waypoint['y'], waypoint['z'] + 2.0)
                self.world.debug.draw_string(
                    text_location,
                    str(i + 1),
                    draw_shadow=True,
                    color=carla.Color(255, 255, 255),
                    life_time=self.waypoint_debug_lifetime,
                    persistent_lines=False
                )
                
            # Direction arrows removed for cleaner appearance
    
    def _draw_waypoint_connections_carla_debug(self, vehicle, waypoints):
        """Draw connection lines between waypoints using CARLA debug drawing"""
        line_color = carla.Color(0, 255, 0)  # Green connection lines
        
        for i, waypoint in enumerate(waypoints):
            if i == 0:
                # First waypoint - connect to vehicle or starting point marker
                start_point = self._get_start_marker_for_vehicle(vehicle)
                if start_point:
                    # Use starting point marker
                    start_location = carla.Location(
                        start_point['x'], 
                        start_point['y'], 
                        start_point['z'] + 0.5
                    )
                else:
                    # Use actual vehicle location
                    vehicle_location = vehicle.get_location()
                    start_location = carla.Location(
                        vehicle_location.x, 
                        vehicle_location.y, 
                        vehicle_location.z + 0.5
                    )
            else:
                # Connect to previous waypoint
                prev_waypoint = waypoints[i - 1]
                start_location = carla.Location(
                    prev_waypoint['x'], 
                    prev_waypoint['y'], 
                    prev_waypoint['z'] + 0.5
                )
            
            # End point is current waypoint
            end_location = carla.Location(
                waypoint['x'], 
                waypoint['y'], 
                waypoint['z'] + 0.5
            )
            
            # Draw connection line
            self.world.debug.draw_line(
                start_location,
                end_location,
                thickness=0.1,
                color=line_color,
                life_time=self.waypoint_debug_lifetime
            )
    
    def _draw_finish_line_carla_debug(self, location, waypoints, waypoint_index, is_selected, is_hovered):
        """Draw a finish line pattern for the last waypoint using CARLA debug drawing"""
        # Calculate trajectory direction for perpendicular orientation
        if waypoint_index > 0:
            # Use direction from previous waypoint to this one
            prev_waypoint = waypoints[waypoint_index - 1]
            current_waypoint = waypoints[waypoint_index]
            
            # Calculate trajectory angle
            dx = current_waypoint['x'] - prev_waypoint['x']
            dy = current_waypoint['y'] - prev_waypoint['y']
            trajectory_angle = math.atan2(dy, dx)
            
            # Perpendicular angle (90 degrees rotated)
            perpendicular_angle = trajectory_angle + math.pi / 2
        else:
            perpendicular_angle = 0  # Default horizontal for single waypoint
        
        # Finish line dimensions (balanced size for close and far zoom)
        line_length = 5.0 if is_selected or is_hovered else 4.0
        line_thickness = 0.14 if is_selected or is_hovered else 0.1
        
        # Calculate finish line endpoints
        half_length = line_length / 2
        end1_x = location.x + half_length * math.cos(perpendicular_angle)
        end1_y = location.y + half_length * math.sin(perpendicular_angle)
        end2_x = location.x - half_length * math.cos(perpendicular_angle)
        end2_y = location.y - half_length * math.sin(perpendicular_angle)
        
        end1 = carla.Location(end1_x, end1_y, location.z)
        end2 = carla.Location(end2_x, end2_y, location.z)
        
        # Draw finish line (red and white checkered pattern approximated with alternating segments)
        segments = 6
        segment_color_1 = carla.Color(255, 255, 255)  # White
        segment_color_2 = carla.Color(255, 50, 50)    # Red
        
        for i in range(segments):
            t1 = i / segments
            t2 = (i + 1) / segments
            
            seg_start_x = end1_x + t1 * (end2_x - end1_x)
            seg_start_y = end1_y + t1 * (end2_y - end1_y)
            seg_end_x = end1_x + t2 * (end2_x - end1_x)
            seg_end_y = end1_y + t2 * (end2_y - end1_y)
            
            seg_start = carla.Location(seg_start_x, seg_start_y, location.z)
            seg_end = carla.Location(seg_end_x, seg_end_y, location.z)
            
            # Alternate colors
            color = segment_color_1 if i % 2 == 0 else segment_color_2
            
            self.world.debug.draw_line(
                seg_start,
                seg_end,
                thickness=line_thickness,
                color=color,
                life_time=self.waypoint_debug_lifetime
            )
    

############################################################
# CARLA Server Management
############################################################

class CarlaServerManager:
    """
    Manages the lifecycle of the CARLA server process, including starting, stopping, and port management.
    Ensures the editor can connect to a running CARLA instance or launch its own.
    """
    
    def __init__(self, carla_path=None, port=2000):
        # Use CARLA_ROOT environment variable if available
        if carla_path is None:
            carla_root = os.environ.get('CARLA_ROOT')
            if carla_root:
                self.carla_path = os.path.join(carla_root, 'CarlaUE4.sh')
            else:
                self.carla_path = "./CarlaUE4.sh"
        else:
            self.carla_path = carla_path
        self.port = port
        self.process = None
        self.use_existing_server = False
        self.allow_auto_stop = True
        self._atexit_registered = False
        self.known_server_pid = None
        self.assume_existing_server_pid = None

        env_pid = os.environ.get('VSE_SERVER_PID')
        if env_pid:
            try:
                self.assume_existing_server_pid = int(env_pid)
            except ValueError:
                self.assume_existing_server_pid = None
            os.environ.pop('VSE_SERVER_PID', None)
        
    def check_port_available(self, port):
        """Check if a port is available"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        try:
            result = sock.connect_ex(('127.0.0.1', port))
            sock.close()
            return result != 0  # Port is available if connection failed
        except Exception:
            # Socket error - assume port is available
            logger.debug("Socket error checking port %d, assuming available", port)
            sock.close()
            return True
    
    def find_available_port(self, start_port=2000, max_attempts=10):
        """Find an available port starting from start_port"""
        for i in range(max_attempts):
            port = start_port + i
            if self.check_port_available(port):
                return port
        raise Exception(f"No available ports found in range {start_port}-{start_port + max_attempts - 1}")

    def set_port(self, port):
        """Update the managed CARLA port."""
        self.port = port

    def _probe_server_health(self, client, port):
        """Validate an existing CARLA server is responsive before reusing it."""
        try:
            world = client.get_world()
            try:
                world.wait_for_tick(3.0)
            except Exception:
                pass
            world.get_settings()
            return True
        except Exception as exc:
            print(f"Existing CARLA server on port {port} failed health probe: {exc}")
            return False

    def _capture_server_pid(self, port):
        """Best-effort capture of the CARLA server PID for managed shutdowns."""
        pid = None
        try:
            result = subprocess.run(['lsof', '-t', f'-i:{port}'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = [line.strip() for line in result.stdout.splitlines() if line.strip()]
                if lines:
                    pid = int(lines[0])
        except Exception as exc:
            print(f"Warning: Unable to detect CARLA PID via lsof on port {port}: {exc}")

        if pid is None:
            try:
                result = subprocess.run(['pgrep', '-f', 'CarlaUE4'], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = [line.strip() for line in result.stdout.splitlines() if line.strip()]
                    if lines:
                        pid = int(lines[0])
            except Exception as exc:
                print(f"Warning: Unable to detect CARLA PID via pgrep: {exc}")

        if pid:
            self.known_server_pid = pid
        return pid
    
    def check_existing_carla_server(self, port):
        """Check if there's already a CARLA server running on the port"""
        try:
            client = carla.Client('127.0.0.1', port)
            client.set_timeout(2.0)
            version = client.get_server_version()
            if not self._probe_server_health(client, port):
                return False
            print(f"Found existing CARLA server on port {port}, version: {version}")
            self._capture_server_pid(port)
            return True
        except Exception:
            # No server running or connection failed - this is expected
            return False
    
    def kill_existing_carla_processes(self):
        """Kill any existing CARLA processes"""
        try:
            # Find and kill existing CARLA processes
            result = subprocess.run(['pgrep', '-f', 'CarlaUE4'], capture_output=True, text=True)
            if result.returncode == 0:
                pids = result.stdout.strip().split('\n')
                print(f"Found existing CARLA processes: {pids}")
                for pid in pids:
                    if pid.strip():
                        try:
                            print(f"Killing CARLA process {pid}")
                            os.kill(int(pid), signal.SIGTERM)
                            time.sleep(2)
                            # Force kill if still running
                            try:
                                os.kill(int(pid), signal.SIGKILL)
                            except (OSError, ProcessLookupError):
                                # Process already terminated - this is fine
                                pass
                        except Exception as e:
                            print(f"Failed to kill process {pid}: {e}")
                            
                # Wait a moment for cleanup
                time.sleep(5)  # Increased cleanup wait time
                self.known_server_pid = None
                self.use_existing_server = False
                self.process = None
        except Exception as e:
            print(f"Error checking for existing CARLA processes: {e}")

    def start_server(self):
        """Start CARLA server with RenderOffScreen"""
        if self.assume_existing_server_pid:
            pid = self.assume_existing_server_pid
            print(f"Attaching to existing CARLA server (PID: {pid})")
            if not self.check_existing_carla_server(self.port):
                raise Exception("Expected CARLA server is not available on the specified port")
            self.use_existing_server = False
            self.process = None
            self.known_server_pid = pid
            self.assume_existing_server_pid = None
            return None

        # Check if CARLA is already running on the desired port
        if self.check_existing_carla_server(self.port):
            print(f"Using existing CARLA server on port {self.port}")
            self.use_existing_server = True
            pid = self._capture_server_pid(self.port)
            if pid:
                print(f"Tracking existing CARLA server PID: {pid}")
            return None
        
        # Check if port is available
        if not self.check_port_available(self.port):
            print(f"Port {self.port} is not available, killing existing CARLA processes...")
            self.kill_existing_carla_processes()
            
            # Try to find an available port
            try:
                new_port = self.find_available_port(self.port)
                print(f"Using alternative port: {new_port}")
                self.port = new_port
            except Exception as e:
                print(f"Could not find available port: {e}")
                raise
        
        if not os.path.exists(self.carla_path):
            raise FileNotFoundError(f"CARLA executable not found at: {self.carla_path}")
        
        print(f"Starting CARLA server at: {self.carla_path}")
        
        # Launch CARLA with RenderOffScreen and other optimal settings
        cmd = [
            self.carla_path,
            "-RenderOffScreen",
            "-prefernvidia",
        ]
        
        print(f"Command: {' '.join(cmd)}")
        
        try:
            # Start without trying to monitor output to avoid interference
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,  # Don't capture output
                stderr=subprocess.DEVNULL,  # Don't capture stderr
                preexec_fn=os.setsid  # Create new process group
            )
        except Exception as e:
            raise Exception(f"Failed to start CARLA server: {e}")

        # Register cleanup handler once so we stop the server on normal exit
        if not self._atexit_registered:
            atexit.register(self._atexit_cleanup)
            self._atexit_registered = True

        print(f"CARLA server started (PID: {self.process.pid})")
        self.known_server_pid = self.process.pid

        # Give CARLA time to start up without interference.
        initial_wait = 15
        if initial_wait > 0:
            print("Waiting for CARLA to initialize...")
            time.sleep(initial_wait)
        
        # Check if process is still running
        if self.process.poll() is not None:
            raise Exception(f"CARLA server exited during startup")
        
        return self.process
    
    def wait_for_server(self, timeout=120):
        """Wait for CARLA server to be ready"""
        if self.use_existing_server:
            return True
            
        print("Waiting for CARLA server RPC to be ready...")
        
        client = carla.Client('127.0.0.1', self.port)
        client.set_timeout(5.0)  # Shorter timeout for individual attempts
        
        start_time = time.time()
        last_error = None
        attempt_count = 0
        
        while time.time() - start_time < timeout:
            # Check if server process is still running
            if self.process and self.process.poll() is not None:
                raise Exception(f"CARLA server process died during startup")
            
            try:
                attempt_count += 1
                if attempt_count % 5 == 0:  # Every 10 seconds, show progress
                    elapsed = time.time() - start_time
                    print(f"Still waiting... ({elapsed:.0f}s elapsed, attempt {attempt_count})")
                
                version = client.get_server_version()
                print(f"CARLA server ready! Version: {version}")
                
                # Give it a moment more to fully stabilize
                time.sleep(2)
                return True
                
            except Exception as e:
                last_error = str(e)
                time.sleep(2)  # Wait between attempts
                print(".", end="", flush=True)
        
        print(f"\nTimeout waiting for CARLA server (waited {timeout}s)")
        if last_error:
            print(f"Last error: {last_error}")
        
        return False

    def _atexit_cleanup(self):
        """Internal handler to stop the server when the process exits."""
        cleanup_completed = [False]

        def _do_cleanup():
            try:
                self.stop_server()
                cleanup_completed[0] = True
            except KeyboardInterrupt:
                print("Cleanup interrupted by user")
                cleanup_completed[0] = True
            except Exception as e:
                print(f"Error during CARLA server shutdown: {e}")
                cleanup_completed[0] = True

        # Run cleanup in thread with timeout
        cleanup_thread = threading.Thread(target=_do_cleanup, daemon=True)
        cleanup_thread.start()
        cleanup_thread.join(timeout=15.0)

        if not cleanup_completed[0]:
            print("WARNING: CARLA server cleanup timed out after 15 seconds")

    def set_auto_stop_enabled(self, enabled):
        """Enable/disable automatic CARLA shutdown on process exit."""
        self.allow_auto_stop = enabled

    def get_known_server_pid(self):
        """Return PID of the CARLA server process if known."""
        return self.known_server_pid

    def stop_server(self, force=False):
        """Stop CARLA server process"""
        if not force and not self.allow_auto_stop:
            print("Skipping CARLA server shutdown (handoff in progress)")
            return

        target_pid = None
        if self.process:
            target_pid = self.process.pid
        elif self.known_server_pid:
            target_pid = self.known_server_pid

        if target_pid:
            print("Stopping CARLA server...")
            try:
                os.killpg(os.getpgid(target_pid), signal.SIGTERM)
                if self.process:
                    try:
                        self.process.wait(timeout=10)
                    except subprocess.TimeoutExpired:
                        raise
                    except KeyboardInterrupt:
                        print("Interrupted during CARLA server shutdown")
                        raise
                else:
                    # Give process time to exit when we don't have handle
                    time.sleep(3)
            except (subprocess.TimeoutExpired, OSError, ProcessLookupError) as e:
                # SIGTERM failed or timed out - try force kill
                logger.debug("SIGTERM failed for server (pid=%s): %s, trying SIGKILL", target_pid, e)
                try:
                    os.killpg(os.getpgid(target_pid), signal.SIGKILL)
                    time.sleep(0.5)
                except (OSError, ProcessLookupError):
                    # Process already terminated or doesn't exist
                    logger.debug("Force kill failed - process may already be terminated")
            except KeyboardInterrupt:
                print("CARLA server shutdown interrupted by user")
                raise
            self.process = None
            self.known_server_pid = None
            self.use_existing_server = False
            self.allow_auto_stop = True
            print("CARLA server stopped")
        else:
            if self.use_existing_server:
                print("Leaving existing CARLA server running")

    def restart_server(self):
        """Restart CARLA server to clear corrupted map state"""
        if self.use_existing_server:
            print("WARNING: Cannot restart an existing server that we don't manage")
            print("Map changes may have issues. Please restart CARLA manually if needed.")
            return True  # Pretend success to continue

        print("Restarting CARLA server...")

        # Stop the current server
        self.stop_server(force=True)

        # Wait for port to be released
        time.sleep(3)

        # Start a new server instance
        self.start_server()

        # Wait for it to be ready
        if self.wait_for_server(timeout=120):
            print("CARLA server restarted successfully")
            return True
        else:
            print("ERROR: Failed to restart CARLA server")
            return False

############################################################
# CARLA Server & Connection Management
############################################################

############################################################
# Camera & Image Processing
############################################################
class TopDownCamera:
    """
    Controls the top-down camera position, zoom, and navigation for the map viewer.
    Provides transformation for CARLA camera sensor placement.
    """
    
    def __init__(self, initial_x=0, initial_y=0, initial_height=200):
        self.center_x = initial_x
        self.center_y = initial_y
        self.height = initial_height

        # Navigation settings
        self.pan_speed = 5.0
        self.zoom_speed = 5.0
        self.min_height = 40.0
        self.max_height = 1000.0
        self.navigation_height_floor = 38.0  # Maintain consistent navigation speed when zoomed in

        # Debug: Track camera movement for raycast after stop
        self.is_moving = False
        self.world = None  # Will be set by CameraImageProcessor

        # Terrain-aware zoom cache
        self._cached_ground_height = None
        self._cached_ground_height_time = 0.0
        self._ground_height_cache_duration = 0.2  # seconds

    def get_carla_transform(self):
        """Get CARLA transform for the camera looking straight down"""
        location = carla.Location(self.center_x, self.center_y, self.height)
        rotation = carla.Rotation(pitch=-90.0, yaw=270.0, roll=0.0)
        return carla.Transform(location, rotation)

    def start_moving(self):
        """Mark that camera is moving"""
        self.is_moving = True

    def stop_moving(self, *, debug_raycast: bool = True):
        """Mark that camera stopped (prototype: no raycast on stop)."""
        if self.is_moving:
            self.is_moving = False

    def get_navigation_height(self):
        """Get the height value used for camera navigation responsiveness."""
        return max(self.height, self.navigation_height_floor)

    def pan(self, dx, dy, dt):
        """Pan the camera by world units, scaled by height"""
        height_scale = self.get_navigation_height() / 200.0
        effective_speed = self.pan_speed * height_scale

        self.center_x += dx * dt * effective_speed
        self.center_y += dy * dt * effective_speed

        # Invalidate terrain cache since we moved
        self._cached_ground_height = None

        # Mark that camera is moving
        self.start_moving()
    
    def zoom(self, zoom_delta):
        """Zoom by changing camera height. Terrain-aware minimum."""
        # Calculate effective minimum height based on terrain
        effective_min = self.min_height  # Default fallback: 40.0

        # Only do fresh raycast when zooming IN, but always use cached terrain for minimum
        if zoom_delta < 0:
            # Zooming in - do raycast (will cache result)
            ground_height = self._get_terrain_height_at_center()
            if ground_height is not None:
                terrain_min = ground_height + 5.0
                effective_min = max(terrain_min, 5.0)
        else:
            # Zooming out - use cached terrain height if available (no new raycast)
            if self._cached_ground_height is not None:
                terrain_min = self._cached_ground_height + 5.0
                effective_min = max(terrain_min, 5.0)

        # Apply zoom with terrain-aware minimum
        new_height = self.height + zoom_delta * self.zoom_speed
        self.height = max(effective_min, min(self.max_height, new_height))

    def update_min_height_from_terrain(self, world, height_buffer=5.0):
        """Prototype: terrain raycast disabled for camera navigation."""
        try:
            buffer_z = float(height_buffer)
        except Exception:
            buffer_z = 0.0

        if buffer_z > self.min_height:
            self.min_height = buffer_z
        if self.height < self.min_height:
            self.height = self.min_height

    def _get_terrain_height_at_center(self):
        """
        Get ground height at camera center, using cache if fresh.
        Returns None if raycast fails or world is unavailable.
        """
        import time

        # Check cache freshness
        now = time.time()
        if (self._cached_ground_height is not None and
                (now - self._cached_ground_height_time) < self._ground_height_cache_duration):
            return self._cached_ground_height

        # Need fresh raycast
        if self.world is None:
            return None

        try:
            location = carla.Location(self.center_x, self.center_y, 0.0)
            ground_z = get_ground_height(
                self.world,
                location,
                debug=False,
                probe_on_miss=False  # Avoid slow grid probing during zoom
            )

            # Cache the result
            self._cached_ground_height = ground_z
            self._cached_ground_height_time = now
            return ground_z

        except Exception:
            # On any error, return cached value if available, else None
            return self._cached_ground_height


class CameraImageProcessor:
    def start_auto_route_to_destination(self, vehicle):
        """Enable destination placement mode and guide the user to select a target."""
        if not vehicle or not vehicle.is_alive:
            print("No valid vehicle selected for auto-routing.")
            return

        self.creating_destination = True
        self.destination_marker_coordinates = None
        self.vehicle_menu_position = None  # Hide menu while placing destination

        print("Destination placement mode: Move the mouse and left-click to choose a destination for auto-routing.")
    """
    Manages the CARLA camera sensor, image acquisition, vehicle and waypoint management, and overlay rendering.
    Central logic for scenario editing, visualization, and interaction with CARLA world objects.
    """
    
    def __init__(self, world, camera_controller, screen_width, screen_height, editor=None, stream_resolution=None, stream_fps=None):
        self.world = world
        self.camera_controller = camera_controller
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.editor = editor
        self.large_map_active = bool(editor and getattr(editor, "large_map_active", False))
        try:
            self.large_map_ui_delay = float(getattr(editor, "large_map_ui_delay", 1.0)) if editor else 1.0
        except Exception:
            self.large_map_ui_delay = 1.0
        try:
            # Default to a short-but-tolerant timeout; values are clamped below.
            self._large_map_rpc_timeout_s = float(os.environ.get("VSE_LARGE_MAP_RPC_TIMEOUT", "2.0"))
        except ValueError:
            self._large_map_rpc_timeout_s = 0.25
        self._large_map_rpc_timeout_s = min(2.0, max(0.05, self._large_map_rpc_timeout_s))
        try:
            self._large_map_transform_retry_s = float(os.environ.get("VSE_LARGE_MAP_TRANSFORM_RETRY", "0.25"))
        except ValueError:
            self._large_map_transform_retry_s = 0.25
        self._large_map_transform_retry_s = min(5.0, max(0.05, self._large_map_transform_retry_s))
        try:
            self._large_map_focus_travel_speed = float(os.environ.get("VSE_LARGE_MAP_FOCUS_TRAVEL_SPEED", "2000.0"))
        except ValueError:
            self._large_map_focus_travel_speed = 2000.0
        self._large_map_focus_travel_speed = max(50.0, self._large_map_focus_travel_speed)
        try:
            self._large_map_focus_travel_threshold = float(os.environ.get("VSE_LARGE_MAP_FOCUS_TRAVEL_THRESHOLD", "999999.0"))
        except ValueError:
            self._large_map_focus_travel_threshold = 250.0
        self._large_map_focus_travel_threshold = max(0.0, self._large_map_focus_travel_threshold)
        if editor is not None and getattr(editor, "cached_map", None) is not None:
            self.cached_map = editor.cached_map
        else:
            self.cached_map = None
        if self.cached_map is None and self.world is not None:
            try:
                self.cached_map = self.world.get_map()
            except Exception:
                self.cached_map = None
        self.camera_sensor = None
        self.camera_active = True
        self._camera_stream_paused = False
        self.image_queue = queue.Queue()
        self.latest_image = None
        self.latest_frame_id = None
        self._scaled_image_cache = None
        self._scaled_image_frame = None
        self._scaled_image_size = None
        self.stream_fps = stream_fps
        if stream_resolution is not None:
            self.image_width, self.image_height = stream_resolution
        else:
            self.image_width = screen_width
            self.image_height = screen_height
        self.stream_resolution = (self.image_width, self.image_height)
        
        # Camera settings
        self.last_frame_time = time.time()
        self._camera_fps_display = 0.0
        self._camera_fps_smoothing = 0.8
        
        # Vehicle management
        self.spawned_vehicles = []  # Track spawned vehicles
        self.vehicle_speeds = {}  # Track vehicle speeds by vehicle ID
        self.vehicle_destination_speeds = {}  # Track destination speeds separately
        self.vehicle_colors = {}  # Track vehicle colors by vehicle ID
        self.pedestrian_colors: Dict[int, carla.Color] = {}  # Stable per-pedestrian colors for highlights
        self.selected_vehicle = None  # Currently selected vehicle
        self.selected_vehicle_is_pedestrian = False  # Track if current selection is a pedestrian
        self._actor_location_cache: Dict[int, Tuple[carla.Location, float]] = {}
        self._pending_large_map_focus_actor_id: Optional[int] = None
        self._pending_large_map_focus_next_attempt = 0.0
        self._pending_large_map_focus_failures = 0
        self._pending_large_map_transform: Optional[carla.Transform] = None
        self._pending_large_map_transform_next_attempt = 0.0
        self._pending_large_map_transform_failures = 0
        self._fast_rpc_client: Optional[carla.Client] = None
        self._fast_rpc_world = None
        self._fast_rpc_host_port: Optional[Tuple[str, int]] = None
        self._fast_rpc_spectator_id: Optional[int] = None
        self._large_map_travel_target: Optional[Tuple[float, float]] = None
        self.ego_vehicle_id = None
        self.ego_vehicle_transform = None
        self.ego_vehicle_blueprint = None
        self.ego_vehicle_color = None
        self.manual_control_enabled = False
        self.manual_control_pending = False
        self.manual_control_actor = None
        self.manual_control_state = {
            'control': None,
            'steer_cache': 0.0,
            'reverse': False,
            'auto_reverse_engaged': False,
            'hand_brake_pressed': False,
            'autopilot_enabled': False,
            'autopilot_active': False,
            'camera_follow_local_offset': (0.0, 0.0, 0.0),
        }
        self._manual_control_search_timer = 0.0
        self._manual_control_tick_subscription = None
        self._manual_control_target_transform: Optional[carla.Transform] = None
        self._manual_camera_free_look_sources: Set[str] = set()
        self._pending_free_look_restores: Dict[str, float] = {}
        self._manual_camera_restore_retry_window = 0.75

        # Playback camera follow (decoupled from manual control for ego with route)
        self.playback_camera_follow_enabled = False
        self.playback_camera_follow_pending = False
        self.playback_camera_follow_actor = None
        self._playback_camera_tick_subscription = None
        self._playback_camera_follow_search_timer = 0.0
        self._playback_camera_follow_local_offset = (0.0, 0.0, 0.0)
        self._playback_camera_target_transform: Optional[carla.Transform] = None

        # Weather state (keyframes for saving)
        self._weather_state: Dict[str, float] = {}
        self._weather_keyframes: List[Dict[str, float]] = []
        self._active_weather_index: int = 0
        self._pending_weather_pct: float = 0.0
        try:
            initial_weather = self.world.get_weather() if self.world else carla.WeatherParameters()
        except Exception:
            initial_weather = carla.WeatherParameters()
        self._weather_state = self._weather_dict_from_params(initial_weather)
        base_frame = {"route_percentage": 0.0, **dict(self._weather_state)}
        self._weather_keyframes = [
            base_frame,
            {**base_frame, "route_percentage": 100.0},
        ]
        self._weather_drag_snapshot: Optional[Dict[str, object]] = None
        self.actor_idle_times = {}  # Track idle times for actors (pedestrians)
        self.actor_turn_times = {}  # Track turn times for actors (pedestrians)
        self.vehicle_ignore_traffic_lights = {}  # Track ignore_traffic_lights by vehicle ID
        self.vehicle_ignore_stop_signs = {}     # Track ignore_stop_signs by vehicle ID
        self.vehicle_ignore_vehicles = {}        # Track ignore_vehicles by vehicle ID
        self.vehicle_max_lat_acc = {}            # Track per-vehicle lateral acceleration caps
        self._pedestrian_highlight_subscription = None
        self._pedestrian_highlight_last_draw: Dict[int, float] = {}

        # Pedestrian trigger system
        self.pedestrian_trigger_centers = {}  # Track trigger centers by pedestrian ID {x, y, z}
        self.pedestrian_trigger_radii = {}    # Track trigger radii by pedestrian ID (float)
        self.scaling_pedestrian_trigger = False  # Track if we're currently scaling a pedestrian trigger
        self._pedestrian_scaling_id = None  # ID of pedestrian whose trigger is being scaled
        self.pedestrian_trigger_scale_start_pos = (0, 0)  # Starting mouse position for scaling
        self.pedestrian_trigger_scale_start_radius = 0.0  # Starting radius for scaling

        # NPC vehicle trigger system
        self.vehicle_trigger_centers = {}   # Track trigger centers by vehicle ID {x, y, z}
        self.vehicle_trigger_radii = {}     # Track trigger radii by vehicle ID (float)
        self.scaling_vehicle_trigger = False  # Track if we're currently scaling a vehicle trigger
        self._vehicle_scaling_id = None     # ID of vehicle whose trigger is being scaled
        self.vehicle_trigger_scale_start_pos = (0, 0)  # Starting mouse position for scaling
        self.vehicle_trigger_scale_start_radius = 0.0  # Starting radius for scaling
        self.vehicle_menu_position = None  # Position for vehicle action menu
        self.vehicle_menu_hidden_for_camera_pan = False  # Hide vehicle menu while user pans the camera
        self.trigger_menu_hidden_for_camera_pan = False  # Hide trigger menu while user pans the camera
        self.traffic_light_menu_hidden_for_camera_pan = False  # Hide traffic-light menu while user pans the camera
        self.traffic_light_overlays_hidden_for_camera_pan = False  # Hide traffic-light overlays during camera motion
        self.actor_overlays_hidden_for_camera_pan = False  # Hide actor selection overlays during camera motion
        self.camera_is_moving = False  # Track if camera is currently moving
        self.camera_movement_timer = 0  # Time since last camera movement
        self.menu_update_delay = 0.2  # Delay before updating menu after camera stops (200ms)
        if self.large_map_active:
            self.menu_update_delay = max(0.0, float(self.large_map_ui_delay))
        self._server_host = '127.0.0.1'
        self._server_port = 2000

        # Vehicle rotation control
        self.rotating_vehicle = False  # Track if we're currently rotating a vehicle
        self.rotation_start_mouse_y = 0  # Starting mouse Y position for rotation
        self.rotation_start_yaw = 0  # Starting vehicle yaw for rotation
        
        # Vehicle movement control
        self.moving_vehicle = False  # Track if we're currently moving a vehicle
        self.movement_start_mouse_pos = (0, 0)  # Starting mouse position for movement
        self.movement_start_location = None  # Starting vehicle location for movement
        # Destination marker creation control
        self.creating_destination = False  # Track if we're in destination placement mode
        self.destination_marker_coordinates = None  # Store placed destination marker

        # Waypoint creation control
        self.creating_waypoint = False  # Track if we're in waypoint creation mode
        self.waypoint_vehicle = None  # Vehicle for which we're creating waypoints
        self.waypoint_list = {}  # Dictionary mapping vehicle IDs to their waypoint lists
        
        # Waypoint interaction control (NEW SYSTEM)
        self.selected_waypoint_vehicle_id = None  # Vehicle ID of selected waypoint
        self.waypoint_display_vehicle_id = None  # Vehicle ID whose waypoints should be displayed
        self.moving_waypoint = False  # Track if we're moving a waypoint
        self.selected_waypoint_index = None  # Index of currently selected waypoint for moving
        self.waypoint_movement_start_pos = (0, 0)  # Starting mouse position for movement
        self.waypoint_movement_start_coords = None  # Starting waypoint coordinates for movement
        self.waypoint_original_height = None  # Original Z height when starting to move waypoint
        self.waypoint_drag_threshold = 5  # Minimum pixels to move before starting drag operation
        self.waypoint_drag_armed = False  # Only allow dragging when the last click hit a waypoint
        self.pending_waypoint_click_action = None  # Track simple clicks on waypoints (no drag)
        self.preserve_info_panel_on_waypoint_cancel = False  # Keep waypoint info panel visible after extension cancel

        # Waypoint CARLA debug drawing system (replaces overlay rendering)
        self.waypoint_debug_refresh_timer = 0  # Timer for refreshing debug drawings
        self.waypoint_debug_refresh_interval = 0.05  # Refresh every 50ms for very responsive updates
        self.waypoint_debug_lifetime = 0.15  # 100ms lifetime for quicker updates
        self.waypoint_marker_radius = 24  # Increased radius for hover detection (bigger markers)
        self.waypoint_split_offset = 1.5  # Desired offset distance when splitting points
        self.waypoint_hover_index = None  # Index of waypoint being hovered over
        
        # OpenDRIVE lane overlay system (NEW)
        self.lane_overlay_enabled = False  # Start disabled, toggle with 'O'
        self.traffic_lights_visible = False  # Start disabled, toggle with 'T'
        self.opendrive_lane_data = None  # Precomputed lane data for overlay rendering
        # Spatial index for fast culling
        self.opendrive_grid_cell_size = 50.0  # meters
        self.opendrive_segment_grid = None  # dict[(ix,iy)] -> list[int]
        self.opendrive_segment_bboxes = None  # list of (minx, miny, maxx, maxy)
        # Camera state tracking for projection caching
        self.last_camera_center = None  # (x, y)
        self.last_camera_height = None
        self.projection_cache = {}  # Cache projected coordinates by camera state
        self.cache_tolerance = 1.0  # Camera movement tolerance for cache invalidation (reduced for snappiness)
        # Offscreen surface caching for throttled redraw
        self.overlay_surface = None  # Cached overlay surface
        self.overlay_surface_dirty = True  # Whether overlay needs redraw
        self.opendrive_overlay_hidden_for_camera_pan = False  # Hide OpenDRIVE overlay during camera motion
        
        # Trigger system (NEW) - Only one trigger allowed per scenario
        self.triggers = []  # List containing at most one trigger: [{'x': float, 'y': float, 'z': float, 'radius': float}]
        self.selected_trigger_index = None  # Index of currently selected trigger (always 0 if exists)
        self.placing_trigger = False  # Track if we're placing a new trigger
        self.moving_trigger = False  # Track if we're moving a trigger
        self.scaling_trigger = False  # Track if we're scaling a trigger
        self.trigger_action_menu_position = None  # Position of trigger action menu
        self.trigger_movement_start_pos = (0, 0)  # Starting mouse position for trigger movement
        self.trigger_movement_start_coords = None  # Starting trigger coordinates
        self.trigger_original_height = None  # Original Z height when starting to move trigger
        self.trigger_scale_start_pos = (0, 0)  # Starting mouse position for scaling
        self.trigger_scale_start_radius = 0  # Starting radius for scaling
        self._trigger_move_start_snapshot = None  # Snapshot for undo/redo when moving global trigger
        self._trigger_scale_start_snapshot = None  # Snapshot for undo/redo when scaling global trigger
        self.pending_personal_trigger = None  # Track placement mode for personal triggers
        self.personal_trigger_preview_radius = DEFAULT_PERSONAL_TRIGGER_RADIUS  # Default placement radius for personal triggers
        self.selected_personal_trigger = None  # {'type': str, 'id': int} or {'type': 'traffic_light', 'group': TrafficLightGroupData}
        self.personal_trigger_menu_position = None  # Screen coords for selected personal trigger
        self.personal_trigger_menu_hidden_for_camera_pan = False
        self.moving_personal_trigger = False
        self.personal_trigger_original_height = None
        self.personal_trigger_movement_start_pos = (0, 0)
        self.personal_trigger_scale_start_pos = (0, 0)
        self.personal_trigger_scale_start_radius = 0.0
        self._personal_trigger_move_target = None  # Cache for currently moving personal trigger selection
        self._personal_trigger_move_start_center = None  # Track original center for undo support
        self._personal_trigger_move_cache = None  # Reusable projection cache during trigger movement

        # Traffic light trigger storage (stable dictionary keyed by fingerprint/ids)
        self.traffic_light_trigger_centers: Dict[Tuple[str, Tuple], Dict[str, float]] = {}
        self.traffic_light_trigger_radii: Dict[Tuple[str, Tuple], float] = {}
        self._last_visible_traffic_light_trigger_key: Optional[Tuple[str, Tuple]] = None

        # Traffic light management
        self.traffic_lights: List[carla.TrafficLight] = []
        self.traffic_light_groups: List[TrafficLightGroupData] = []
        self.selected_traffic_light_group: Optional[TrafficLightGroupData] = None
        self._selected_traffic_light_group_ids: Set[int] = set()
        self._selected_traffic_light_group_fingerprint: Optional[Tuple[Tuple[int, int, int], ...]] = None
        self._traffic_light_group_lookup: Dict[int, TrafficLightGroupData] = {}
        self._traffic_light_rectangles: Dict[int, Tuple[List[carla.Location], Optional[carla.Location]]] = {}
        self._traffic_light_volume_bounds: Dict[int, Tuple[float, float]] = {}
        self._traffic_light_visibility: Dict[int, bool] = {}
        self._traffic_light_screen_polygons: Dict[int, List[Tuple[float, float]]] = {}
        self._traffic_light_screen_centers: Dict[int, Tuple[float, float]] = {}
        self._traffic_light_ground_cache: Dict[int, Tuple[float, float]] = {}  # id -> (ground_z, timestamp)
        self._last_connector_debug_signature: Optional[Tuple[Tuple[int, ...], Tuple[str, ...]]] = None
        self._traffic_light_refresh_timer = 0.0
        self._traffic_light_refresh_interval = 2.0  # seconds
        self._traffic_light_refresh_error_logged = False
        self._traffic_light_debug_matching = bool(int(os.environ.get("VSE_DEBUG_TRAFFIC_LIGHT_MATCH", "0")))
        self._traffic_light_debug_render = bool(int(os.environ.get("VSE_DEBUG_TRAFFIC_LIGHT_DRAW", "0")))
        self._traffic_light_render_debug_signature: Optional[Tuple[int, bool]] = None
        self._traffic_light_group_snapshots: List[Dict[str, object]] = []
        self.traffic_light_menu_position: Optional[Tuple[int, int]] = None
        self.scaling_traffic_light_trigger = False
        self._traffic_light_scaling_group: Optional[TrafficLightGroupData] = None
        self.traffic_light_scale_start_pos: Tuple[int, int] = (0, 0)
        self.traffic_light_scale_start_radius: float = 0.0
        self._scenario_active_traffic_light_trigger: Optional[Dict[str, object]] = None
        self.traffic_light_sequences: Dict[frozenset, List[Dict[str, Union[str, float, int]]]] = {}
        try:
            self._traffic_light_font = pygame.font.Font(None, 18)
        except Exception:
            self._traffic_light_font = None

        # Add coordinate detector
        self.coordinate_detector = WorldCoordinateDetector(world, camera_controller)
        self.coordinate_detector.editor = editor
        if editor is not None and getattr(editor, "cached_map", None) is not None:
            self.coordinate_detector.world_map = editor.cached_map
        self.coordinate_detector.screen_width = screen_width
        self.coordinate_detector.screen_height = screen_height
        self.coordinate_detector.spawned_vehicles = self.spawned_vehicles
        self.coordinate_detector.traffic_lights = self.traffic_lights

        # Debug flag for raycast coordinate testing (large maps)
        self.debug_raycast = False  # Set to True to enable debug logging
        self.setup_camera()
        self._refresh_traffic_lights()
        self._register_pedestrian_highlight_tick()

    def _get_cached_map(self, refresh=False):
        if self.cached_map is not None:
            return self.cached_map

        editor = getattr(self, "editor", None)
        refresh_allowed = refresh and not (
            editor and getattr(editor, "_map_refresh_disabled", False)
        )

        map_obj = None
        if editor is not None:
            map_obj = editor._safe_get_world_map(refresh=refresh_allowed)
        elif refresh_allowed and self.world:
            try:
                map_obj = self.world.get_map()
            except Exception as exc:
                print(f"[Map] Unable to refresh cached map from camera processor: {exc}")

        if map_obj is not None:
            self.cached_map = map_obj
        return self.cached_map

    def setup_camera(
        self,
        attach_to: Optional[carla.Actor] = None,
        transform: Optional[carla.Transform] = None,
        attachment_type: carla.AttachmentType = carla.AttachmentType.Rigid,
    ):
        """Create and configure the camera sensor"""
        # Get camera blueprint
        blueprint_library = self.world.get_blueprint_library()
        camera_bp = blueprint_library.find('sensor.camera.rgb')
        
        # Configure camera
        camera_bp.set_attribute('image_size_x', str(self.image_width))
        camera_bp.set_attribute('image_size_y', str(self.image_height))
        camera_bp.set_attribute('fov', '90')
        if self.stream_fps and self.stream_fps > 0:
            tick_value = max(0.001, 1.0 / float(self.stream_fps))
        else:
            tick_value = 0.0
        camera_bp.set_attribute('sensor_tick', f"{tick_value:.3f}")
        
        # Spawn camera
        if transform is None:
            transform = self.camera_controller.get_carla_transform()
        if attach_to is not None:
            self.camera_sensor = self.world.spawn_actor(
                camera_bp,
                transform,
                attach_to=attach_to,
                attachment_type=attachment_type,
            )
        else:
            self.camera_sensor = self.world.spawn_actor(camera_bp, transform)
        
        # Set up image callback
        weak_self = weakref.ref(self)
        self.camera_sensor.listen(lambda image: CameraImageProcessor._on_image_received(weak_self, image))
        self._camera_stream_paused = False
        self.frames_received = 0
        
        print("Camera sensor created and listening")
    
    def update_screen_size(self, new_width, new_height):
        """Update screen size for camera processing without changing the stream resolution."""
        if abs(self.screen_width - new_width) < 5 and abs(self.screen_height - new_height) < 5:
            return

        self.screen_width = new_width
        self.screen_height = new_height
        self.coordinate_detector.screen_width = new_width
        self.coordinate_detector.screen_height = new_height
        self._scaled_image_cache = None
        self._scaled_image_frame = None
        self._scaled_image_size = None
        stream_w, stream_h = self.stream_resolution
        print(f"Display resized to: {new_width}x{new_height} (stream {stream_w}x{stream_h})")
    
    def apply_stream_settings(self, resolution=None, fps=None):
        """Apply updated stream settings and restart the camera sensor if needed."""
        need_restart = False

        if resolution is not None:
            new_w, new_h = int(resolution[0]), int(resolution[1])
            if (new_w, new_h) != self.stream_resolution:
                self.stream_resolution = (new_w, new_h)
                self.image_width = new_w
                self.image_height = new_h
                need_restart = True

        if fps is not None:
            new_fps = max(1, int(fps)) if fps > 0 else None
            if new_fps != self.stream_fps:
                self.stream_fps = new_fps
                need_restart = True

        if not self.camera_active:
            return

        if need_restart:
            self._scaled_image_cache = None
            self._scaled_image_frame = None
            self._scaled_image_size = None
            self.restart_camera_sensor()
        else:
            self.stream_resolution = (int(self.stream_resolution[0]), int(self.stream_resolution[1]))

    def disable_camera_sensor(self):
        """Completely stop the RGB sensor and drop any buffered frames."""
        self.camera_active = False
        self._camera_stream_paused = False
        if self.camera_sensor:
            try:
                self.camera_sensor.destroy()
            except Exception as exc:
                print(f"[Camera] Warning: failed to destroy camera sensor cleanly: {exc}")
            finally:
                self.camera_sensor = None
        self.image_queue = queue.Queue()
        self.latest_image = None
        self.latest_frame_id = None
        self._scaled_image_cache = None
        self._scaled_image_frame = None
        self._scaled_image_size = None
        self.frames_received = 0

    def enable_camera_sensor(self):
        """Ensure the RGB sensor exists and is producing frames."""
        if self.camera_sensor and getattr(self, "_camera_stream_paused", False):
            self.camera_active = True
            self.resume_camera_stream()
            return
        if self.camera_active and self.camera_sensor:
            return
        self.camera_active = True
        self.restart_camera_sensor()

    def pause_camera_stream(self):
        """Stop receiving frames without destroying the sensor actor."""
        if getattr(self, "_camera_stream_paused", False):
            return
        if self.camera_sensor:
            try:
                self.camera_sensor.stop()
            except Exception as exc:
                print(f"[Camera] Warning: failed to stop camera sensor: {exc}")
        self._camera_stream_paused = True
        self.image_queue = queue.Queue()
        self.latest_image = None
        self.latest_frame_id = None
        self._scaled_image_cache = None
        self._scaled_image_frame = None
        self._scaled_image_size = None
        self.frames_received = 0

    def resume_camera_stream(self):
        """Resume receiving frames after pause_camera_stream()."""
        if not getattr(self, "_camera_stream_paused", False):
            return
        if not self.camera_sensor:
            self._camera_stream_paused = False
            self.camera_active = True
            self.restart_camera_sensor()
            return
        try:
            weak_self = weakref.ref(self)
            self.camera_sensor.listen(lambda image: CameraImageProcessor._on_image_received(weak_self, image))
        except Exception as exc:
            print(f"[Camera] Warning: failed to resume camera sensor: {exc}")
            return
        self._camera_stream_paused = False

    def is_camera_active(self) -> bool:
        return self.camera_active

    def restart_camera_sensor(
        self,
        attach_to: Optional[carla.Actor] = None,
        transform: Optional[carla.Transform] = None,
        attachment_type: carla.AttachmentType = carla.AttachmentType.Rigid,
    ):
        """Destroy and recreate the camera sensor with the current settings."""
        if not self.camera_active:
            return
        if self.camera_sensor:
            try:
                self.camera_sensor.destroy()
            except Exception as exc:
                print(f"[Camera] Warning: failed to destroy camera sensor cleanly: {exc}")
            finally:
                self.camera_sensor = None
        self.setup_camera(attach_to=attach_to, transform=transform, attachment_type=attachment_type)

    @staticmethod
    def _on_image_received(weak_self, carla_image):
        """Process received camera image"""
        self = weak_self()
        if not self:
            return
        
        # Convert CARLA image to numpy array
        array = np.frombuffer(carla_image.raw_data, dtype=np.uint8)
        array = np.reshape(array, (carla_image.height, carla_image.width, 4))
        array = array[:, :, :3]  # Remove alpha channel
        array = array[:, :, ::-1]  # Convert BGR to RGB
        
        # Convert to pygame surface
        pygame_image = pygame.surfarray.make_surface(array.swapaxes(0, 1))
        
        # Store latest image and update camera FPS estimate
        self.latest_image = pygame_image
        self.latest_frame_id = carla_image.frame
        now = time.time()
        if self.last_frame_time:
            frame_dt = now - self.last_frame_time
            if frame_dt > 0:
                instantaneous = 1.0 / frame_dt
                alpha = 1.0 - self._camera_fps_smoothing
                if self._camera_fps_display <= 0.0:
                    self._camera_fps_display = instantaneous
                else:
                    self._camera_fps_display = max(
                        0.0,
                        (self._camera_fps_display * self._camera_fps_smoothing) + (instantaneous * alpha),
                    )
        self.last_frame_time = now
        self._scaled_image_cache = None
        self._scaled_image_frame = None
        self._scaled_image_size = None
        if not hasattr(self, "_debug_printed_frames"):
            self._debug_printed_frames = 0
        self.frames_received = getattr(self, "frames_received", 0) + 1
        if self._debug_printed_frames < 5:
            print(f"[Camera] Received frame {carla_image.frame} ({carla_image.width}x{carla_image.height})")
            self._debug_printed_frames += 1

    def get_camera_fps(self) -> float:
        """Return smoothed camera FPS based on received sensor frames."""
        return max(0.0, getattr(self, "_camera_fps_display", 0.0))

    def _get_cached_actor_location(self, actor_id: int, *, max_age_s: float = 0.5) -> Optional[carla.Location]:
        """Return a cached actor location when available (used to avoid blocking RPC on large maps)."""
        cached = self._actor_location_cache.get(int(actor_id))
        if not cached:
            return None
        location, stamp = cached
        if (time.time() - float(stamp)) > float(max_age_s):
            return None
        return location

    def _cache_actor_location(self, actor_id: int, location: carla.Location) -> None:
        try:
            self._actor_location_cache[int(actor_id)] = (location, time.time())
        except Exception:
            pass

    def _get_fast_world(self) -> Optional["carla.World"]:
        """Return a short-timeout CARLA world handle for large-map safety operations."""
        host = getattr(self, "_server_host", "127.0.0.1")
        port = int(getattr(self, "_server_port", 2000))
        if not host or port <= 0:
            return None

        key = (str(host), int(port))
        if self._fast_rpc_client is None or self._fast_rpc_host_port != key:
            try:
                client = carla.Client(key[0], key[1])
                client.set_timeout(float(self._large_map_rpc_timeout_s))
            except Exception:
                self._fast_rpc_client = None
                self._fast_rpc_world = None
                self._fast_rpc_host_port = None
                self._fast_rpc_spectator_id = None
                return None
            self._fast_rpc_client = client
            self._fast_rpc_world = None
            self._fast_rpc_host_port = key
            self._fast_rpc_spectator_id = None

        if self._fast_rpc_world is None and self._fast_rpc_client is not None:
            try:
                self._fast_rpc_world = self._fast_rpc_client.get_world()
            except Exception:
                self._fast_rpc_world = None
                self._fast_rpc_spectator_id = None
                return None
        return self._fast_rpc_world

    def _get_actor_location_fast(self, actor_id: int, *, max_age_s: float = 0.5) -> Optional[carla.Location]:
        """Try to fetch an actor location with a short RPC timeout; returns cached value on failure."""
        cached = self._get_cached_actor_location(actor_id, max_age_s=max_age_s)
        if cached is not None:
            return cached

        world = self._get_fast_world()
        if world is None:
            return None

        actor = None
        try:
            actor = world.get_actor(int(actor_id))
        except Exception:
            actor = None
        if not actor:
            return None

        try:
            loc = actor.get_location()
        except Exception:
            return None
        self._cache_actor_location(actor_id, loc)
        return loc

    def _queue_large_map_transform(self, transform: carla.Transform) -> None:
        """Queue a transform apply for large maps to avoid blocking the UI thread on long RPC timeouts."""
        if self._pending_large_map_transform is None:
            self._pending_large_map_transform_failures = 0
            self._pending_large_map_transform_next_attempt = 0.0
        self._pending_large_map_transform = transform

    def _apply_large_map_transform_once(self) -> bool:
        """Attempt to apply the queued transform using a short-timeout CARLA client."""
        transform = self._pending_large_map_transform
        if not transform or not self.camera_sensor:
            self._pending_large_map_transform = None
            return True

        editor = getattr(self, "editor", None)
        if editor is not None and not getattr(editor, "camera_stream_enabled", True):
            # Keep the transform queued; we apply when the stream is enabled again.
            return False

        skip_spectator = bool(int(os.environ.get("VSE_LARGE_MAP_SKIP_SPECTATOR", "0")))

        world = self._get_fast_world()
        client = self._fast_rpc_client
        if world is None or client is None:
            return False

        if not skip_spectator and self._fast_rpc_spectator_id is None:
            try:
                spectator = world.get_spectator()
                self._fast_rpc_spectator_id = int(spectator.id) if spectator else None
            except Exception:
                self._fast_rpc_spectator_id = None

        batch = []
        try:
            batch.append(carla.command.ApplyTransform(int(self.camera_sensor.id), transform))
        except Exception:
            return False
        if not skip_spectator and self._fast_rpc_spectator_id is not None:
            try:
                batch.append(carla.command.ApplyTransform(int(self._fast_rpc_spectator_id), transform))
            except Exception:
                pass

        try:
            client.apply_batch_sync(batch, False)
        except Exception:
            return False
        return True

    def _process_large_map_transform_queue(self) -> None:
        """Retry queued camera/spectator transforms with backoff (large maps)."""
        if not self._pending_large_map_transform:
            return
        editor = getattr(self, "editor", None)
        if editor is not None and not getattr(editor, "camera_stream_enabled", True):
            return
        now = time.time()
        if now < float(self._pending_large_map_transform_next_attempt or 0.0):
            return

        ok = self._apply_large_map_transform_once()
        if ok:
            self._pending_large_map_transform = None
            self._pending_large_map_transform_failures = 0
            self._pending_large_map_transform_next_attempt = 0.0
            return

        self._pending_large_map_transform_failures += 1
        backoff = float(self._large_map_transform_retry_s) * (2.0 ** min(4, self._pending_large_map_transform_failures))
        self._pending_large_map_transform_next_attempt = now + min(3.0, backoff)

    def _process_large_map_pending_focus(self) -> None:
        """Resolve pending focus requests without blocking (large maps)."""
        actor_id = self._pending_large_map_focus_actor_id
        if actor_id is None:
            return
        now = time.time()
        if now < float(self._pending_large_map_focus_next_attempt or 0.0):
            return

        loc = self._get_actor_location_fast(actor_id, max_age_s=0.25)
        if loc is None:
            self._pending_large_map_focus_failures += 1
            backoff = 0.25 * (2.0 ** min(5, self._pending_large_map_focus_failures))
            self._pending_large_map_focus_next_attempt = now + min(3.0, backoff)
            return

        self._pending_large_map_focus_actor_id = None
        self._pending_large_map_focus_failures = 0
        self._pending_large_map_focus_next_attempt = 0.0
        try:
            self.focus_camera_on_location(loc)
        except Exception:
            pass

    def _process_large_map_travel(self, dt: float) -> None:
        """Animate long-distance camera focus to reduce streaming hitches (large maps)."""
        target = self._large_map_travel_target
        if not target or not self.camera_controller:
            return
        try:
            tx, ty = float(target[0]), float(target[1])
        except Exception:
            self._large_map_travel_target = None
            return

        cx = float(getattr(self.camera_controller, "center_x", 0.0))
        cy = float(getattr(self.camera_controller, "center_y", 0.0))
        dx = tx - cx
        dy = ty - cy
        dist = math.hypot(dx, dy)
        if dist <= 1.0:
            self.camera_controller.center_x = tx
            self.camera_controller.center_y = ty
            self._large_map_travel_target = None
            self.update_camera_position()
            return

        step = float(self._large_map_focus_travel_speed) * max(0.0, float(dt))
        if step <= 0.0:
            return
        if step >= dist:
            nx, ny = tx, ty
        else:
            scale = step / dist
            nx = cx + dx * scale
            ny = cy + dy * scale

        self.camera_controller.center_x = nx
        self.camera_controller.center_y = ny
        self.update_camera_position()
    
    def update_camera_position(self):
        """Update camera sensor position"""
        if self.camera_sensor:
            transform = self.camera_controller.get_carla_transform()
            if self.large_map_active:
                self._queue_large_map_transform(transform)
            else:
                try:
                    self.camera_sensor.set_transform(transform)
                    if self.world:
                        spectator = self.world.get_spectator()
                        spectator.set_transform(transform)
                except Exception:
                    pass

        # Mark camera as moving and reset timer
        self.camera_is_moving = True
        self.camera_movement_timer = time.time()
    
    def update_vehicle_menu_position(self):
        """Update the vehicle menu position to follow the selected vehicle"""
        if self.selected_personal_trigger:
            self.vehicle_menu_position = None
            return

        if not (self.selected_vehicle and self.selected_vehicle.is_alive):
            return
        
        # Only update menu position if camera has stopped moving for a while
        current_time = time.time()
        if self.camera_is_moving and (current_time - self.camera_movement_timer < self.menu_update_delay):
            return
        
        # Camera has stopped moving, update menu position
        self.camera_is_moving = False

        vehicle_location = None
        if self.large_map_active:
            vehicle_location = self._get_actor_location_fast(self.selected_vehicle.id, max_age_s=0.5)
        else:
            vehicle_location = self.selected_vehicle.get_location()

        if vehicle_location is None:
            return
        screen_pos = self.coordinate_detector.world_to_screen_coordinates(
            vehicle_location.x, vehicle_location.y, vehicle_location.z + 2.0  # Slightly above vehicle
        )
        
        if screen_pos['success']:
            self.vehicle_menu_position = (int(screen_pos['x']), int(screen_pos['y']))
            self.vehicle_menu_hidden_for_camera_pan = False
        else:
            self.vehicle_menu_position = None

    def suppress_vehicle_menu_for_camera_pan(self) -> None:
        """Temporarily hide actor/trigger/traffic-light menus during camera motion."""
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            self.vehicle_menu_hidden_for_camera_pan = True
        if (self.selected_trigger_index is not None
                and 0 <= self.selected_trigger_index < len(self.triggers)):
            self.trigger_menu_hidden_for_camera_pan = True
        if self.selected_personal_trigger:
            self.personal_trigger_menu_hidden_for_camera_pan = True
        if self.selected_traffic_light_group or getattr(self, '_scenario_active_traffic_light_trigger', None):
            self.traffic_light_menu_hidden_for_camera_pan = True
        self.traffic_light_overlays_hidden_for_camera_pan = True
        self.actor_overlays_hidden_for_camera_pan = True
        if self.lane_overlay_enabled:
            self.opendrive_overlay_hidden_for_camera_pan = True

    def restore_vehicle_menu_after_camera_pan(self) -> None:
        """Restore actor/trigger menus once manual camera panning stops."""
        self.vehicle_menu_hidden_for_camera_pan = False
        self.trigger_menu_hidden_for_camera_pan = False
        self.personal_trigger_menu_hidden_for_camera_pan = False
        self.traffic_light_menu_hidden_for_camera_pan = False
        self.traffic_light_overlays_hidden_for_camera_pan = False
        self.actor_overlays_hidden_for_camera_pan = False
        if self.lane_overlay_enabled:
            self.opendrive_overlay_hidden_for_camera_pan = False
            self.overlay_surface_dirty = True

        # Force an immediate position refresh so the menus snap to their actors.
        self.camera_is_moving = False
        self.camera_movement_timer = 0.0

        if self.selected_vehicle and self.selected_vehicle.is_alive:
            self.update_vehicle_menu_position()
        if (self.selected_trigger_index is not None
                and 0 <= self.selected_trigger_index < len(self.triggers)):
            self.update_trigger_menu_position()
        if self.selected_personal_trigger:
            self.update_personal_trigger_menu_position(force=True)
        if self.selected_traffic_light_group:
            self.update_traffic_light_menu_position()

    def update_trigger_menu_position(self) -> None:
        """Update the trigger action menu position to follow the selected trigger."""
        if self.selected_personal_trigger:
            self.trigger_action_menu_position = None
            return
        if self.selected_trigger_index is None:
            return
        if not (0 <= self.selected_trigger_index < len(self.triggers)):
            self.selected_trigger_index = None
            self.trigger_action_menu_position = None
            return

        current_time = time.time()
        if self.camera_is_moving and (current_time - self.camera_movement_timer < self.menu_update_delay):
            return

        self.camera_is_moving = False

        trigger = self.triggers[self.selected_trigger_index]
        screen_pos = self.coordinate_detector.world_to_screen_coordinates(
            trigger['x'], trigger['y'], trigger['z']
        )

        if screen_pos['success']:
            self.trigger_action_menu_position = (int(screen_pos['x']), int(screen_pos['y']))
            self.trigger_menu_hidden_for_camera_pan = False
        else:
            self.trigger_action_menu_position = None

    def update_traffic_light_menu_position(self) -> None:
        """Update the traffic-light action menu position after camera motion."""
        if self.selected_personal_trigger:
            self.traffic_light_menu_position = None
            return
        group = self.selected_traffic_light_group
        if not group:
            return

        current_time = time.time()
        if self.camera_is_moving and (current_time - self.camera_movement_timer < self.menu_update_delay):
            return

        self.camera_is_moving = False

        self._update_traffic_light_menu_anchor(group)
        if self.traffic_light_menu_position:
            self.traffic_light_menu_hidden_for_camera_pan = False
            self.traffic_light_overlays_hidden_for_camera_pan = False

    def refresh_selected_vehicle_ui(self):
        """Force-update menu positioning and info panel for the currently selected vehicle."""
        if not (self.selected_vehicle and self.selected_vehicle.is_alive):
            return

        # Allow immediate menu update
        self.camera_is_moving = False
        self.camera_movement_timer = 0.0
        self.update_vehicle_menu_position()

        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if (panel and panel.visible and panel.object_type in ('vehicle', 'pedestrian')
                and panel.selected_object is self.selected_vehicle):
            panel._refresh_fields()

    def clear_vehicle_selection(self, *, keep_waypoints=False, hide_info_panel=True, clear_traffic_light=True):
        """Deselect the current vehicle/pedestrian and optionally preserve waypoint display."""
        previous_personal_selection = self.selected_personal_trigger
        self.selected_vehicle = None
        self.selected_vehicle_is_pedestrian = False
        self.vehicle_menu_position = None
        if not keep_waypoints:
            self.waypoint_display_vehicle_id = None
        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if hide_info_panel and panel:
            panel.hide()
        if clear_traffic_light:
            self.clear_traffic_light_selection()
        if (previous_personal_selection
                and previous_personal_selection.get('kind') in ('vehicle', 'pedestrian')):
            self.clear_personal_trigger_selection()

    def restore_actor_selection(self, actor: Optional[carla.Actor]) -> bool:
        """Reapply selection state to a specific actor after scenario playback."""
        if not actor or not actor.is_alive:
            return False

        self.selected_vehicle = actor
        self.selected_vehicle_is_pedestrian = actor.type_id.startswith('walker.')
        self.vehicle_menu_position = None
        self.selected_waypoint_vehicle_id = None
        self.selected_waypoint_index = None
        self.waypoint_display_vehicle_id = actor.id

        try:
            self.update_vehicle_menu_position()
        except Exception:
            pass

        try:
            self.refresh_waypoints_carla_debug()
        except Exception:
            pass

        return True

    def focus_camera_on_location(self, location: Optional[carla.Location]):
        """Center the camera over a world location without changing its height."""
        if not location or not self.camera_controller:
            return

        # Preserve current height explicitly, as downstream updates may clamp values
        current_height = self.camera_controller.height

        if self.large_map_active:
            try:
                dx = float(location.x) - float(self.camera_controller.center_x)
                dy = float(location.y) - float(self.camera_controller.center_y)
                dist = math.hypot(dx, dy)
            except Exception:
                dist = 0.0
            if dist > float(self._large_map_focus_travel_threshold):
                self._large_map_travel_target = (float(location.x), float(location.y))
                self.camera_controller.height = current_height
                if hasattr(self.camera_controller, "stop_moving"):
                    self.camera_controller.stop_moving()
                self.camera_is_moving = True
                self.camera_movement_timer = time.time()
                return

        self.camera_controller.center_x = location.x
        self.camera_controller.center_y = location.y
        self.camera_controller.height = current_height

        # Apply the transform to the CARLA camera and spectator
        self.update_camera_position()
        self.notify_manual_camera_adjustment()

        # Treat focus as a camera movement so menu updates are delayed (important on large maps)
        if hasattr(self.camera_controller, "stop_moving"):
            self.camera_controller.stop_moving()
        self.camera_is_moving = True
        self.camera_movement_timer = time.time()
    
    def update(self, dt):
        """Update camera processor state (call this every frame)"""
        self._process_pending_free_look_restores()
        if self.large_map_active:
            # Large-map safety: avoid long blocking RPC in the render thread.
            self._process_large_map_pending_focus()
            self._process_large_map_travel(dt)
            self._process_large_map_transform_queue()

        current_time = time.time()
        if self.camera_is_moving and (current_time - self.camera_movement_timer >= self.menu_update_delay):
            self.camera_is_moving = False
            self.camera_movement_timer = current_time
            self.traffic_light_overlays_hidden_for_camera_pan = False
            if self.lane_overlay_enabled:
                self.opendrive_overlay_hidden_for_camera_pan = False
                self.overlay_surface_dirty = True

        # Check if camera movement has stopped and update menus if needed
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            self.update_vehicle_menu_position()
        if (self.selected_trigger_index is not None
                and 0 <= self.selected_trigger_index < len(self.triggers)):
            self.update_trigger_menu_position()
        if self.selected_personal_trigger:
            self.update_personal_trigger_menu_position()
        if self.selected_traffic_light_group and self.traffic_lights_visible:
            self.update_traffic_light_menu_position()
        
        # Update waypoint debug drawing timer
        self.waypoint_debug_refresh_timer += dt
        if self.waypoint_debug_refresh_timer >= self.waypoint_debug_refresh_interval:
            self.waypoint_debug_refresh_timer = 0
            if not (self.large_map_active and self.camera_is_moving):
                try:
                    self.refresh_waypoints_carla_debug()
                except Exception:
                    pass
        self._manual_control_update(dt)
        self._playback_camera_follow_update(dt)

        # Periodically refresh traffic light actor list
        self._traffic_light_refresh_timer += dt
        if self._traffic_light_refresh_timer >= self._traffic_light_refresh_interval:
            self._traffic_light_refresh_timer = 0.0
            if not (self.large_map_active and self.camera_is_moving):
                self._refresh_traffic_lights()

    def _refresh_traffic_lights(self) -> None:
        """Update cached traffic light actor list."""
        if not self.world:
            if self.traffic_lights:
                self.traffic_lights.clear()
            if self.traffic_light_groups:
                self.traffic_light_groups.clear()
            self._traffic_light_group_lookup.clear()
            self._traffic_light_rectangles.clear()
            self.clear_traffic_light_selection()
            return

        try:
            actor_list = self.world.get_actors().filter('traffic.traffic_light*')
            try:
                is_empty = len(actor_list) == 0
            except Exception:
                is_empty = False
            if is_empty:
                fallback_list = self.world.get_actors().filter('traffic_light*')
                try:
                    fallback_count = len(fallback_list)
                except Exception:
                    fallback_count = -1
                if self._traffic_light_debug_matching:
                    self._traffic_light_debug(
                        "Primary actor filter returned 0 results; "
                        f"fallback 'traffic_light*' count={fallback_count}"
                    )
                actor_list = fallback_list
        except Exception as exc:
            if not self._traffic_light_refresh_error_logged:
                print(f"[TrafficLights] Failed to query actors: {exc}")
                self._traffic_light_refresh_error_logged = True
            return

        self._traffic_light_refresh_error_logged = False

        def _collect_alive(actors: Iterable[carla.Actor]) -> List[carla.TrafficLight]:
            collected: List[carla.TrafficLight] = []
            for actor in actors:
                if not actor:
                    continue
                try:
                    if not actor.is_alive:
                        continue
                except Exception:
                    continue
                collected.append(cast(carla.TrafficLight, actor))
            return collected

        alive_lights = _collect_alive(actor_list)

        if not alive_lights:
            editor_world = None
            editor = getattr(self, "editor", None)
            if editor and hasattr(editor, "_get_current_world"):
                try:
                    editor_world = editor._get_current_world()
                except Exception:
                    editor_world = None

            if editor_world and editor_world is not self.world:
                if self._traffic_light_debug_matching:
                    self._traffic_light_debug("Detected world replacement; refreshing traffic-light query.")
                self.world = editor_world
                if self.coordinate_detector:
                    self.coordinate_detector.world = editor_world

            active_world = self.world or editor_world
            if active_world:
                try:
                    active_world.wait_for_tick(0.5)
                except Exception:
                    pass
                try:
                    actor_list = active_world.get_actors().filter('traffic.traffic_light*')
                    try:
                        is_empty = len(actor_list) == 0
                    except Exception:
                        is_empty = False
                    if is_empty:
                        actor_list = active_world.get_actors().filter('traffic_light*')
                except Exception:
                    actor_list = []
                alive_lights = _collect_alive(actor_list)

            if not alive_lights:
                if self._traffic_light_debug_matching:
                    self._traffic_light_debug("Actor query returned 0 lights; preserving existing cache.")
                return

        filtered_lights = [light for light in alive_lights if not self._is_traffic_light_underground(light)]
        if not filtered_lights:
            if self._traffic_light_debug_matching:
                self._traffic_light_debug("Traffic lights filtered out as underground; skipping refresh.")
            return

        # Replace list in-place so coordinate detector keeps reference
        self.traffic_lights.clear()
        self.traffic_lights.extend(filtered_lights)

        current_ids: Set[int] = {light.id for light in filtered_lights}

        # Rebuild cached trigger rectangles and overlapping groups
        self._traffic_light_rectangles.clear()
        grouping_meta = []

        for light in self.traffic_lights:
            rectangle_data = self._get_traffic_light_rectangle_points(light)
            if not rectangle_data:
                continue
            corners, _ = rectangle_data
            min_x = min(pt.x for pt in corners)
            max_x = max(pt.x for pt in corners)
            min_y = min(pt.y for pt in corners)
            max_y = max(pt.y for pt in corners)
            min_z = min(pt.z for pt in corners)
            max_z = max(pt.z for pt in corners)
            grouping_meta.append({
                "light": light,
                "bbox": (min_x, max_x, min_y, max_y, min_z, max_z),
            })

        self._build_traffic_light_groups(grouping_meta)

        # Drop selection if no lights from the previously selected group remain
        self._restore_selected_traffic_light_group(current_ids)

    @staticmethod
    def _bboxes_overlap(
        bbox1: Tuple[float, float, float, float, float, float],
        bbox2: Tuple[float, float, float, float, float, float],
        tolerance_xy: float = 0.25,
        tolerance_z: float = 1.5,
    ) -> bool:
        """Return True when two bounding boxes overlap within the tolerances."""
        min_x1, max_x1, min_y1, max_y1, min_z1, max_z1 = bbox1
        min_x2, max_x2, min_y2, max_y2, min_z2, max_z2 = bbox2
        return (
            max_x1 + tolerance_xy >= min_x2
            and max_x2 + tolerance_xy >= min_x1
            and max_y1 + tolerance_xy >= min_y2
            and max_y2 + tolerance_xy >= min_y1
            and max_z1 + tolerance_z >= min_z2
            and max_z2 + tolerance_z >= min_z1
        )

    @staticmethod
    def _compute_traffic_light_fingerprint(
        lights: List[carla.TrafficLight],
    ) -> Optional[Tuple[Tuple[int, int, int], ...]]:
        """Return a quantized, order-independent signature for the provided lights."""
        quantized_locations: List[Tuple[int, int, int]] = []
        for light in lights:
            if not light:
                continue
            try:
                location = light.get_transform().location
            except Exception:
                continue
            scale = TRAFFIC_LIGHT_FINGERPRINT_SCALE
            quantized_locations.append(
                (
                    int(round(location.x * scale)),
                    int(round(location.y * scale)),
                    int(round(location.z * scale)),
                )
            )
        if not quantized_locations:
            return None
        quantized_locations.sort()
        return tuple(quantized_locations)

    def _traffic_light_debug(self, message: str) -> None:
        """Print traffic-light debug information when enabled."""
        if self._traffic_light_debug_matching:
            print(f"[TrafficLights][Debug] {message}")

    @staticmethod
    def _compute_traffic_light_group_centroid(
        lights: List[carla.TrafficLight],
    ) -> Optional[Tuple[float, float, float]]:
        """Return centroid of traffic light transforms, or None if unavailable."""
        if not lights:
            return None
        sum_x = 0.0
        sum_y = 0.0
        sum_z = 0.0
        count = 0
        for light in lights:
            if not light:
                continue
            try:
                location = light.get_transform().location
            except Exception:
                continue
            sum_x += location.x
            sum_y += location.y
            sum_z += location.z
            count += 1
        if count == 0:
            return None
        return (sum_x / count, sum_y / count, sum_z / count)

    def _build_traffic_light_groups(self, grouping_meta: List[Dict[str, object]]) -> None:
        """Cluster overlapping traffic light trigger volumes into selection groups."""
        groups: List[TrafficLightGroupData] = []
        previous_groups: List[TrafficLightGroupData] = list(getattr(self, "traffic_light_groups", []))
        previous_records: List[Dict[str, object]] = []
        records_by_ids: Dict[frozenset, Dict[str, object]] = {}
        records_by_fp: Dict[Tuple[Tuple[int, int, int], ...], List[Dict[str, object]]] = {}

        def _add_record(
            *,
            live_ids: Set[int],
            reference_ids: Optional[Set[int]],
            fingerprint: Optional[Tuple[Tuple[int, int, int], ...]],
            centroid: Optional[Tuple[float, float, float]],
            trigger_payload: Optional[Tuple[Dict[str, float], float]],
            sequence_payload: Optional[List[Dict[str, Union[str, float, int]]]],
            size: int,
            group_obj: Optional[TrafficLightGroupData],
            source: str,
        ) -> None:
            ids_key = frozenset(live_ids) if live_ids else None
            record = {
                "live_ids": set(live_ids),
                "ids_key": ids_key,
                "reference_ids": set(reference_ids) if reference_ids else None,
                "fingerprint": fingerprint,
                "centroid": centroid,
                "trigger": trigger_payload,
                "sequence": sequence_payload,
                "size": size,
                "group_obj": group_obj,
                "used": False,
                "source": source,
            }
            previous_records.append(record)
            if ids_key:
                # Prefer live group data over snapshots
                if ids_key not in records_by_ids or group_obj is not None:
                    records_by_ids[ids_key] = record
            if fingerprint:
                bucket = records_by_fp.setdefault(fingerprint, [])
                if group_obj is not None:
                    bucket.insert(0, record)
                else:
                    bucket.append(record)

        for existing_group in previous_groups:
            ids_set = set(existing_group.ids)
            if existing_group.reference_ids is None:
                existing_group.reference_ids = set(ids_set)
            fingerprint = existing_group.location_fingerprint
            if fingerprint is None:
                fingerprint = self._compute_traffic_light_fingerprint(existing_group.lights)
                existing_group.location_fingerprint = fingerprint
            centroid = existing_group.center_location
            if centroid is None:
                centroid = self._compute_traffic_light_group_centroid(existing_group.lights)
                existing_group.center_location = centroid

            trigger_payload = None
            if existing_group.has_trigger():
                trigger_payload = (
                    dict(existing_group.trigger_center or {}),
                    float(existing_group.trigger_radius or 0.0),
                )

            sequence_payload: Optional[List[Dict[str, Union[str, float, int]]]] = None
            ids_key = frozenset(ids_set) if ids_set else None
            if existing_group.sequence:
                sequence_payload = copy.deepcopy(existing_group.sequence)
            elif ids_key:
                seq_from_cache = self.traffic_light_sequences.get(ids_key)
                if seq_from_cache:
                    sequence_payload = copy.deepcopy(seq_from_cache)

            size_hint = existing_group.cached_size or len(existing_group.lights) or len(ids_set)
            _add_record(
                live_ids=ids_set,
                reference_ids=set(existing_group.reference_ids) if existing_group.reference_ids else set(ids_set),
                fingerprint=fingerprint,
                centroid=centroid,
                trigger_payload=trigger_payload,
                sequence_payload=sequence_payload,
                size=size_hint,
                group_obj=existing_group,
                source="live",
            )

        if not previous_records and self._traffic_light_group_snapshots:
            for snapshot in self._traffic_light_group_snapshots:
                legacy_live_ids = snapshot.get("ids_live")
                legacy_ids = snapshot.get("ids")
                snapshot_ids = set(cast(Set[int], legacy_live_ids if legacy_live_ids is not None else legacy_ids or set()))
                snapshot_reference_ids = set(cast(Set[int], snapshot.get("reference_ids", snapshot_ids)))
                fingerprint = cast(Optional[Tuple[Tuple[int, int, int], ...]], snapshot.get("fingerprint"))
                centroid = cast(Optional[Tuple[float, float, float]], snapshot.get("centroid"))
                trigger_payload = snapshot.get("trigger")
                sequence_payload = snapshot.get("sequence")
                size_hint = int(snapshot.get("size", len(snapshot_ids)))
                _add_record(
                    live_ids=snapshot_ids,
                    reference_ids=snapshot_reference_ids,
                    fingerprint=fingerprint,
                    centroid=centroid,
                    trigger_payload=cast(Optional[Tuple[Dict[str, float], float]], trigger_payload),
                    sequence_payload=cast(Optional[List[Dict[str, Union[str, float, int]]]], copy.deepcopy(sequence_payload)),
                    size=size_hint,
                    group_obj=None,
                    source="snapshot",
                )

        self._traffic_light_debug(
            "Rebuilding traffic light groups: "
            f"prev_groups={len(previous_groups)}, new_candidates={len(grouping_meta)}"
        )
        if self._traffic_light_debug_matching:
            preview_limit = 12
            for index, record in enumerate(previous_records):
                if index >= preview_limit:
                    remaining = len(previous_records) - preview_limit
                    if remaining > 0:
                        self._traffic_light_debug(
                            f"  ... truncated {remaining} additional cached group record(s)"
                        )
                    break
                ids_list = sorted(cast(Set[int], record["live_ids"]))
                self._traffic_light_debug(
                    f"  Prev group ids={ids_list} "
                    f"size={record['size']} "
                    f"fp={record['fingerprint']} "
                    f"centroid={record['centroid']} "
                    f"source={record['source']}"
                )

        assigned: Set[int] = set()
        tolerance_xy = 0.25
        tolerance_z = 1.5
        new_sequence_cache: Dict[frozenset, List[Dict[str, Union[str, float, int]]]] = {}

        for entry in grouping_meta:
            light = cast(carla.TrafficLight, entry["light"])
            light_id = light.id
            if light_id in assigned:
                continue

            stack = [entry]
            group_entries: List[Dict[str, object]] = []

            while stack:
                current = stack.pop()
                current_light = cast(carla.TrafficLight, current["light"])
                current_id = current_light.id
                if current_id in assigned:
                    continue
                assigned.add(current_id)
                group_entries.append(current)

                current_bbox = cast(Tuple[float, float, float, float, float, float], current["bbox"])
                for other in grouping_meta:
                    other_light = cast(carla.TrafficLight, other["light"])
                    other_id = other_light.id
                    if other_id in assigned:
                        continue
                    other_bbox = cast(Tuple[float, float, float, float, float, float], other["bbox"])
                    if self._bboxes_overlap(
                        current_bbox,
                        other_bbox,
                        tolerance_xy=tolerance_xy,
                        tolerance_z=tolerance_z,
                    ):
                        stack.append(other)

            if not group_entries:
                continue

            group_entries.sort(key=lambda item: cast(carla.TrafficLight, item["light"]).id)
            group_lights = [cast(carla.TrafficLight, item["light"]) for item in group_entries]
            group_ids = {light.id for light in group_lights}
            group_data = TrafficLightGroupData(
                lights=group_lights,
                ids=group_ids,
                reference_ids=None,
            )
            fingerprint = self._compute_traffic_light_fingerprint(group_lights) or None
            group_data.location_fingerprint = fingerprint
            group_centroid = self._compute_traffic_light_group_centroid(group_lights)
            group_data.center_location = group_centroid
            group_data.cached_size = len(group_lights)
            cache_key = frozenset(group_ids)
            matched_record: Optional[Dict[str, object]] = None
            match_reason: Optional[str] = None

            # Prefer fingerprint to survive ID churn
            if matched_record is None and fingerprint:
                for candidate in records_by_fp.get(fingerprint, []):
                    if not candidate.get("used"):
                        matched_record = candidate
                        match_reason = "fingerprint"
                        break

            # Next, exact live ids
            if matched_record is None and cache_key in records_by_ids:
                candidate = records_by_ids[cache_key]
                if not candidate.get("used"):
                    matched_record = candidate
                    match_reason = "id"

            # Next, reference ids if present
            if matched_record is None:
                for candidate in previous_records:
                    if candidate.get("used"):
                        continue
                    ref_ids = candidate.get("reference_ids")
                    if not ref_ids:
                        continue
                    try:
                        if frozenset(cast(Set[int], ref_ids)) == cache_key:
                            matched_record = candidate
                            match_reason = "reference_id"
                            break
                    except Exception:
                        continue

            # Finally, centroid-based fallback
            if matched_record is None and group_centroid is not None:
                best_record = None
                best_distance = float("inf")
                for candidate in previous_records:
                    if candidate.get("used"):
                        continue
                    if candidate.get("size") != len(group_lights):
                        continue
                    prev_centroid = candidate.get("centroid")
                    if prev_centroid is None:
                        continue
                    distance = math.dist(group_centroid, prev_centroid)
                    if distance < best_distance:
                        best_distance = distance
                        best_record = candidate
                if best_record and best_distance <= TRAFFIC_LIGHT_CENTROID_MATCH_THRESHOLD:
                    matched_record = best_record
                    match_reason = f"centroid(d={best_distance:.2f})"

            if matched_record:
                matched_record["used"] = True
                match_fp = matched_record.get("fingerprint")
                if match_fp and group_data.location_fingerprint is None:
                    group_data.location_fingerprint = cast(Tuple[Tuple[int, int, int], ...], match_fp)
                if group_data.center_location is None:
                    prev_centroid = cast(Optional[Tuple[float, float, float]], matched_record.get("centroid"))
                    if prev_centroid:
                        group_data.center_location = prev_centroid
                if not group_data.cached_size:
                    group_data.cached_size = int(matched_record.get("size", len(group_lights)))

                trigger_payload = matched_record.get("trigger")
                if trigger_payload:
                    center_payload, radius_value = cast(Tuple[Dict[str, float], float], trigger_payload)
                    if center_payload:
                        group_data.trigger_center = dict(center_payload)
                        group_data.trigger_radius = float(max(MIN_PERSONAL_TRIGGER_RADIUS, radius_value))
                        self._set_traffic_light_trigger_data(
                            group_data.trigger_center,
                            group_data.trigger_radius,
                            group=group_data,
                            mark_visible=False,
                        )
                else:
                    stored_center, stored_radius, _ = self._get_traffic_light_trigger_data(group=group_data)
                    if stored_center and stored_radius is not None:
                        group_data.trigger_center = dict(stored_center)
                        group_data.trigger_radius = float(stored_radius)

                sequence_payload = matched_record.get("sequence")
                if sequence_payload:
                    preserved_sequence = copy.deepcopy(
                        cast(List[Dict[str, Union[str, float, int]]], sequence_payload)
                    )
                    group_data.sequence = self._normalize_traffic_light_sequence(preserved_sequence)
                    new_sequence_cache[cache_key] = copy.deepcopy(group_data.sequence)
                reference_ids_record = matched_record.get("reference_ids")
                if reference_ids_record:
                    group_data.reference_ids = set(cast(Set[int], reference_ids_record))
                else:
                    group_data.reference_ids = set(group_ids)
                prev_ids = sorted(cast(Set[int], matched_record.get("live_ids", set())))
                self._traffic_light_debug(
                    f"Matched new group ids={sorted(group_ids)} size={len(group_lights)} "
                    f"to prev ids={prev_ids} via {match_reason}"
                )
            else:
                group_data.reference_ids = set(group_ids)
                cached_sequence = self.traffic_light_sequences.get(cache_key)
                if cached_sequence:
                    group_data.sequence = self._normalize_traffic_light_sequence(cached_sequence)
                    new_sequence_cache[cache_key] = copy.deepcopy(group_data.sequence)
                if not group_data.has_trigger():
                    stored_center, stored_radius, _ = self._get_traffic_light_trigger_data(group=group_data)
                    if stored_center and stored_radius is not None:
                        group_data.trigger_center = dict(stored_center)
                        group_data.trigger_radius = float(stored_radius)
                self._traffic_light_debug(
                    f"No match for new group ids={sorted(group_ids)} size={len(group_lights)} "
                    f"fp={fingerprint} centroid={group_centroid}"
                )

            groups.append(group_data)

        groups.sort(key=lambda data: min(data.ids) if data.ids else 0)
        self.traffic_light_groups = groups

        self._rebuild_traffic_light_group_lookup()
        if groups:
            self.traffic_light_sequences = new_sequence_cache

        if groups:
            self._snapshot_traffic_light_groups(groups)
        elif self._traffic_light_debug_matching:
            self._traffic_light_debug(
                "Traffic light groups empty after rebuild; retaining previous snapshot for future matching."
            )

        if (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'traffic_light'):
            key = self.selected_personal_trigger.get('key')
            if key:
                refreshed_group = self._find_traffic_light_group_by_key(key)
                if refreshed_group:
                    self.selected_personal_trigger['group'] = refreshed_group

    def _snapshot_traffic_light_groups(self, groups: List[TrafficLightGroupData]) -> None:
        """Cache a snapshot of current traffic light groups for future matching."""
        snapshots: List[Dict[str, object]] = []
        for group in groups:
            if group.has_trigger():
                self._set_traffic_light_trigger_data(
                    group.trigger_center or {},
                    group.trigger_radius or 0.0,
                    group=group,
                    mark_visible=False,
                )
            trigger_payload = None
            if group.has_trigger():
                trigger_payload = (
                    dict(group.trigger_center or {}),
                    float(group.trigger_radius or 0.0),
                )
            snapshots.append(
                {
                    "ids_live": set(group.ids),
                    "reference_ids": set(group.reference_ids or set(group.ids)),
                    "fingerprint": group.location_fingerprint,
                    "centroid": group.center_location,
                    "trigger": trigger_payload,
                    "sequence": copy.deepcopy(group.sequence) if group.sequence else None,
                    "size": group.cached_size or len(group.lights) or len(group.ids),
                }
            )
        self._traffic_light_group_snapshots = snapshots

    def _rebuild_traffic_light_group_lookup(self) -> None:
        """Refresh lookup from light id to its owning group."""
        self._traffic_light_group_lookup.clear()
        for group in self.traffic_light_groups:
            for light in group.lights:
                self._traffic_light_group_lookup[light.id] = group

    def _restore_selected_traffic_light_group(self, alive_ids: Set[int]) -> None:
        """Restore previously selected group if all of its members are still alive."""
        if not self._selected_traffic_light_group_ids and not self._selected_traffic_light_group_fingerprint:
            self.selected_traffic_light_group = None
            self._traffic_light_debug("Restore selection: no prior group ids/fingerprint recorded")
            return

        def _apply_restoration(target_group: TrafficLightGroupData) -> None:
            self.selected_traffic_light_group = target_group
            self._selected_traffic_light_group_ids = set(target_group.ids)
            self._selected_traffic_light_group_fingerprint = target_group.location_fingerprint
            self._update_traffic_light_menu_anchor(target_group)

            if self.scaling_traffic_light_trigger and self._traffic_light_scaling_group:
                if self._traffic_light_scaling_group.ids == target_group.ids:
                    self._traffic_light_scaling_group = target_group

            panel = getattr(getattr(self, "editor", None), "info_panel", None)
            if panel and panel.object_type == 'traffic_light' and panel.selected_object:
                if panel.selected_object.ids == target_group.ids:
                    panel.selected_object = target_group
            self._traffic_light_debug(
                f"Restored traffic light selection to ids={sorted(target_group.ids)} "
                f"fp={target_group.location_fingerprint}"
            )

        fingerprint = self._selected_traffic_light_group_fingerprint
        ids_valid = (
            self._selected_traffic_light_group_ids
            and self._selected_traffic_light_group_ids.issubset(alive_ids)
        )

        if not alive_ids:
            self.selected_traffic_light_group = None
            self._selected_traffic_light_group_ids.clear()
            self._traffic_light_debug(
                "No alive traffic lights detected; preserving selection fingerprint for future restoration."
            )
            return

        # Prefer fingerprint-based restore to survive ID changes
        if fingerprint:
            for group in self.traffic_light_groups:
                if group.location_fingerprint == fingerprint:
                    _apply_restoration(group)
                    return

        if ids_valid:
            for group in self.traffic_light_groups:
                if group.ids == self._selected_traffic_light_group_ids:
                    _apply_restoration(group)
                    return

        self._traffic_light_debug(
            "Failed to restore traffic light selection. "
            f"stored_ids={sorted(self._selected_traffic_light_group_ids)} "
            f"stored_fp={self._selected_traffic_light_group_fingerprint} "
            f"alive_ids_sample={sorted(list(alive_ids))[:6]}"
        )
        self.clear_traffic_light_selection()

    def _is_traffic_light_underground(self, light: carla.TrafficLight) -> bool:
        """
        Check if traffic light is underground (more than 1m below ground level).
        Uses road waypoint height instead of raycast to avoid hitting structures above
        or the traffic light pole itself.

        Uses caching to avoid expensive waypoint lookups on every refresh.

        Args:
            light: Traffic light to check

        Returns:
            True if light is underground, False otherwise
        """
        if not self.world:
            return False

        light_id = light.id
        loc = light.get_location()
        current_time = time.time()

        # Check cache (expire after 60 seconds)
        if light_id in self._traffic_light_ground_cache:
            ground_z, timestamp = self._traffic_light_ground_cache[light_id]
            if current_time - timestamp < 60.0:  # Cache valid for 60 seconds
                return loc.z < (ground_z - 1.0)

        # Cache miss or expired - get ground height using waypoint (road level)
        # This avoids raycasting issues where it hits structures above the light
        # or the traffic light pole itself
        cached_map = self._get_cached_map(refresh=False)
        ground_z = loc.z  # Fallback to light's own Z if waypoint fails

        if cached_map is not None:
            try:
                waypoint = cached_map.get_waypoint(loc, project_to_road=True)
                if waypoint:
                    ground_z = waypoint.transform.location.z
            except Exception:
                # If waypoint lookup fails, fall back to raycast
                ground_z = get_ground_height(self.world, loc, debug=False, cached_map=cached_map)

        # Update cache
        self._traffic_light_ground_cache[light_id] = (ground_z, current_time)

        # Check if underground (more than 1m below ground)
        return loc.z < (ground_z - 1.0)

    def refresh_waypoints_carla_debug(self):
        """Refresh waypoint visualization using CARLA debug drawing system"""
        # Hide waypoints during scenario playback
        if self.editor and self.editor.scenario_running:
            return

        # Get hovered waypoint from mouse position
        hovered_waypoint = self.get_hovered_waypoint()
        
        # Draw waypoints using CARLA debug drawing
        if hasattr(self, 'world') and self.world:
            # Use the existing marker system's debug drawing function
            if hasattr(self, 'world') and hasattr(self.world, 'debug'):
                # We need to create a temporary marker system instance to access the drawing function
                # Or add this functionality directly here
                self.draw_waypoints_carla_debug_local()

    def _get_start_marker_for_vehicle_id(self, vehicle_id: Optional[int]) -> Optional[dict]:
        """Return stored spawn marker data for a vehicle ID while it is hidden during scenario playback."""
        if vehicle_id is None:
            return None

        info_panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if info_panel:
            markers = getattr(info_panel, "scenario_starting_points", {}) or {}
            marker = markers.get(vehicle_id)
            if marker:
                return marker
            legacy = getattr(info_panel, "scenario_starting_point", None)
            if legacy and legacy.get("vehicle_id") == vehicle_id:
                return legacy

        editor = getattr(self, "editor", None)
        if editor:
            for entry in getattr(editor, "saved_scene_vehicles", []):
                actor = entry.get("actor")
                if actor and actor.id == vehicle_id:
                    transform = entry.get("transform")
                    if transform:
                        loc = transform.location
                        return {
                            "x": loc.x,
                            "y": loc.y,
                            "z": loc.z,
                            "vehicle_id": vehicle_id,
                        }
        return None

    def _get_start_marker_for_vehicle(self, vehicle: Optional[carla.Actor]) -> Optional[dict]:
        """Backward-compatible helper that uses actor ID to resolve start markers."""
        vehicle_id = getattr(vehicle, "id", None) if vehicle else None
        return self._get_start_marker_for_vehicle_id(vehicle_id)

    def register_ego_vehicle(
        self,
        actor: carla.Actor,
        transform: carla.Transform,
        color: Optional[str] = None,
        preserve_waypoints: bool = False,
    ) -> None:
        """Track the currently placed ego vehicle metadata."""
        if not actor:
            return
        self.ego_vehicle_id = actor.id
        self.ego_vehicle_transform = carla.Transform(transform.location, transform.rotation)
        self.ego_vehicle_blueprint = actor.type_id
        self.ego_vehicle_color = color
        if not preserve_waypoints:
            self.clear_vehicle_waypoints(actor.id)
        if self.manual_control_enabled and self.manual_control_actor and self.manual_control_actor.id != actor.id:
            self.disable_manual_control()

    def update_editor_ego_transform(self, transform: Optional[carla.Transform]) -> None:
        """Persist editor ego transform metadata when the actor is moved."""
        if transform is None:
            return
        self.ego_vehicle_transform = carla.Transform(transform.location, transform.rotation)

    def clear_ego_vehicle(self, actor_id: Optional[int] = None) -> None:
        """Clear ego vehicle tracking data."""
        if actor_id is not None and self.ego_vehicle_id != actor_id:
            return
        if self.ego_vehicle_id:
            self.clear_vehicle_waypoints(self.ego_vehicle_id)
        self.ego_vehicle_id = None
        self.ego_vehicle_transform = None
        self.ego_vehicle_blueprint = None
        self.ego_vehicle_color = None

    def request_manual_control(self) -> None:
        """Begin watching for an ego vehicle to attach for manual control."""
        self.manual_control_pending = True
        self.manual_control_enabled = False
        self.manual_control_actor = None
        self._manual_control_search_timer = 0.0
        self._manual_control_debug_printed = False
        self.manual_control_state.update({
            'control': None,
            'steer_cache': 0.0,
            'reverse': False,
            'auto_reverse_engaged': False,
            'hand_brake_pressed': False,
            'autopilot_enabled': False,
            'autopilot_active': False,
            'camera_follow_local_offset': (0.0, 0.0, 0.0),
        })
        self._manual_control_unregister_tick_callback()
        self._manual_control_target_transform = None
        self._manual_camera_free_look_sources.clear()
        self._pending_free_look_restores.clear()

    def disable_manual_control(self) -> None:
        """Detach manual control from the ego vehicle."""
        self._manual_control_stop_camera_follow()
        self._stop_playback_camera_follow()
        final_transform = None
        if self.manual_control_enabled and self.manual_control_actor and self.manual_control_actor.is_alive:
            try:
                if self.manual_control_state.get('autopilot_active'):
                    self.manual_control_actor.set_autopilot(False)
            except Exception:
                pass
            try:
                self.manual_control_actor.apply_control(carla.VehicleControl(throttle=0.0, brake=1.0))
            except Exception:
                pass
            try:
                final_transform = self.manual_control_actor.get_transform()
            except Exception:
                final_transform = None
            should_destroy = self.manual_control_actor.id != self.ego_vehicle_id
            if should_destroy:
                try:
                    self.manual_control_actor.destroy()
                except Exception:
                    pass
        if final_transform is None and self.ego_vehicle_transform is not None:
            final_transform = self.ego_vehicle_transform

        if final_transform:
            self.update_editor_ego_transform(final_transform)
            if self.editor and hasattr(self.editor, 'saved_scene_vehicles') and self.editor.saved_scene_vehicles:
                for actor_data in self.editor.saved_scene_vehicles:
                    actor = actor_data.get('actor')
                    if actor and actor.id == self.ego_vehicle_id:
                        actor_data['transform'] = carla.Transform(final_transform.location, final_transform.rotation)
                        break
        self.manual_control_enabled = False
        self.manual_control_pending = False
        self.manual_control_actor = None
        self.manual_control_state.update({
            'control': None,
            'steer_cache': 0.0,
            'reverse': False,
            'auto_reverse_engaged': False,
            'hand_brake_pressed': False,
            'autopilot_enabled': False,
            'autopilot_active': False,
            'camera_follow_local_offset': (0.0, 0.0, 0.0),
        })
        self._manual_control_target_transform = None
        self._manual_control_debug_printed = False
        self._manual_camera_free_look_sources.clear()
        self._pending_free_look_restores.clear()

    def handle_manual_control_key(self, key: int, is_pressed: bool) -> bool:
        """Route arrow-key input to manual control when active. Returns True if the key was consumed."""
        if not (self.manual_control_enabled or self.manual_control_pending):
            return False

        state = self.manual_control_state
        arrow_keys = (pygame.K_UP, pygame.K_DOWN, pygame.K_LEFT, pygame.K_RIGHT)
        if key in arrow_keys:
            return True
        if key == pygame.K_SPACE:
            state['hand_brake_pressed'] = is_pressed
            return True
        if key == pygame.K_q:
            if is_pressed:
                state['reverse'] = not state.get('reverse', False)
                state['auto_reverse_engaged'] = False
            return True
        if key == pygame.K_p:
            if is_pressed:
                state['autopilot_enabled'] = not state.get('autopilot_enabled', False)
            return True
        return False

    def _manual_control_update(self, dt: float) -> None:
        """Attach manual control when ready and send controls to the ego vehicle."""
        if self.manual_control_enabled:
            actor = self.manual_control_actor
            if not actor or not actor.is_alive:
                self.disable_manual_control()
                return
            self._apply_manual_control(dt)
            return

        if not self.manual_control_pending:
            return

        self._manual_control_search_timer += dt
        if self._manual_control_search_timer < 0.25:
            return
        self._manual_control_search_timer = 0.0

        actor = self._find_manual_control_actor()
        if actor is None:
            return

        # Attach to the ego actor
        try:
            actor.set_simulate_physics(True)
        except Exception:
            pass
        self.manual_control_actor = actor
        self.manual_control_enabled = True
        self.manual_control_pending = False
        self.manual_control_state.update({
            'control': carla.VehicleControl(),
            'steer_cache': 0.0,
            'reverse': False,
            'auto_reverse_engaged': False,
            'autopilot_active': False,
            'camera_follow_local_offset': (0.0, 0.0, 0.0),
        })
        self._manual_control_start_camera_follow(actor)
        self._manual_control_register_tick_callback()
        print("Manual ego control enabled. Arrow keys now steer the ego vehicle.")

    def _find_manual_control_actor(self) -> Optional[carla.Actor]:
        """Search the world for an ego vehicle spawned by ScenarioRunner."""
        world = self.world
        if world is None and hasattr(self, 'get_world'):
            try:
                world = self.get_world()
            except Exception:
                world = None
        if world is None:
            editor = getattr(self, 'editor', None)
            if editor and hasattr(editor, '_get_current_world'):
                try:
                    world = editor._get_current_world()
                except Exception:
                    world = None
        if world is None:
            return None

        try:
            if self.ego_vehicle_id:
                actor = world.get_actor(self.ego_vehicle_id)
                if actor and actor.is_alive and actor.get_location().z > -100.0:
                    return actor
        except Exception:
            pass

        try:
            actors = list(world.get_actors().filter('vehicle.*'))
        except RuntimeError:
            return None

        preferred_roles = {'hero', 'ego_vehicle', 'ego', 'player'}
        for actor in actors:
            if not actor.is_alive:
                continue
            if actor.get_location().z < -100.0:
                continue
            role_name = actor.attributes.get('role_name', '').lower()
            if role_name in preferred_roles:
                return actor

        blueprint_id = getattr(self, 'ego_vehicle_blueprint', None)
        transform_ref = getattr(self, 'ego_vehicle_transform', None)
        expected_blueprints = []
        if blueprint_id:
            expected_blueprints.append(blueprint_id)

        scenario_transform = None
        scenario_blueprint = None
        scenario_data = getattr(self, 'loaded_scenario_data', None)
        if isinstance(scenario_data, dict):
            ego_meta = scenario_data.get('ego_vehicle')
            if isinstance(ego_meta, dict):
                scenario_blueprint = ego_meta.get('type')
                if scenario_blueprint and scenario_blueprint not in expected_blueprints:
                    expected_blueprints.append(scenario_blueprint)
                if transform_ref is None:
                    loc_meta = ego_meta.get('location') or {}
                    rot_meta = ego_meta.get('rotation') or {}
                    scenario_transform = carla.Transform(
                        carla.Location(
                            loc_meta.get('x', 0.0),
                            loc_meta.get('y', 0.0),
                            loc_meta.get('z', 0.0),
                        ),
                        carla.Rotation(
                            rot_meta.get('pitch', 0.0),
                            rot_meta.get('yaw', 0.0),
                            rot_meta.get('roll', 0.0),
                        ),
                    )

        if transform_ref is None and scenario_transform is not None:
            transform_ref = scenario_transform

        if not expected_blueprints and scenario_blueprint:
            expected_blueprints.append(scenario_blueprint)
        if not expected_blueprints:
            # Fallback to the default Lexus blueprint used by the editor when no info is cached.
            expected_blueprints.append('vehicle.lexus.utlexus')

        fallback_candidates = []
        for actor in actors:
            if not actor:
                continue
            if not actor.is_alive:
                refreshed = None
                try:
                    refreshed = world.get_actor(actor.id)
                except Exception:
                    refreshed = None
                if refreshed and refreshed.is_alive:
                    actor = refreshed
                else:
                    continue
            try:
                location = actor.get_location()
            except Exception:
                continue
            if location.z < -100.0:
                continue
            blueprint_match = actor.type_id in expected_blueprints
            if not blueprint_match and actor.type_id == 'vehicle.lexus.utlexus':
                blueprint_match = True
            if not blueprint_match:
                continue
            fallback_candidates.append(actor)

        if not fallback_candidates:
            return None

        if transform_ref:
            best_actor = None
            best_distance = float('inf')
            for actor in fallback_candidates:
                try:
                    distance = actor.get_location().distance(transform_ref.location)
                except Exception:
                    continue
                if distance < best_distance:
                    best_distance = distance
                    best_actor = actor
            if best_actor:
                return best_actor

        actor = fallback_candidates[0] if fallback_candidates else None
        return actor

    def _apply_manual_control(self, dt: float) -> None:
        """Gradually apply user steering/throttle inputs to the ego vehicle."""
        actor = self.manual_control_actor
        if not actor or not actor.is_alive:
            self.disable_manual_control()
            return

        self._manual_control_apply_target_transform()

        state = self.manual_control_state
        control = state.get('control')
        if control is None:
            control = carla.VehicleControl()
            state['control'] = control

        requested_autopilot = state.get('autopilot_enabled', False)
        active_autopilot = state.get('autopilot_active', False)
        if requested_autopilot != active_autopilot:
            try:
                actor.set_autopilot(requested_autopilot)
                state['autopilot_active'] = requested_autopilot
            except Exception:
                pass
            active_autopilot = state.get('autopilot_active', False)

        if active_autopilot:
            return

        keys = pygame.key.get_pressed()
        steer_cache = state.get('steer_cache', 0.0)
        steer_increment = 0.5 * dt
        left_pressed = keys[pygame.K_LEFT]
        right_pressed = keys[pygame.K_RIGHT]
        up_pressed = keys[pygame.K_UP]
        down_pressed = keys[pygame.K_DOWN]
        if left_pressed and not right_pressed:
            steer_cache -= steer_increment
        elif right_pressed and not left_pressed:
            steer_cache += steer_increment
        else:
            steer_cache = 0.0
        steer_cache = max(-0.7, min(0.7, steer_cache))
        state['steer_cache'] = steer_cache

        auto_reverse_engaged = state.get('auto_reverse_engaged', False)
        reverse_enabled = state.get('reverse', False)
        auto_reverse_stop_speed = 0.35
        try:
            velocity = actor.get_velocity()
            speed = math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2)
        except Exception:
            speed = 0.0
        is_stopped = speed < auto_reverse_stop_speed

        if not auto_reverse_engaged and not reverse_enabled:
            if down_pressed and not up_pressed and is_stopped:
                reverse_enabled = True
                auto_reverse_engaged = True
        elif auto_reverse_engaged and up_pressed and is_stopped:
            reverse_enabled = False
            auto_reverse_engaged = False

        state['reverse'] = reverse_enabled
        state['auto_reverse_engaged'] = auto_reverse_engaged

        if auto_reverse_engaged:
            control.throttle = 1.0 if down_pressed else 0.0
            control.brake = 1.0 if up_pressed else 0.0
        else:
            control.throttle = 1.0 if up_pressed else 0.0
            control.brake = 1.0 if down_pressed else 0.0
        control.steer = round(steer_cache, 1)
        control.hand_brake = state.get('hand_brake_pressed', False)
        control.reverse = reverse_enabled

        try:
            actor.apply_control(control)
            self.update_editor_ego_transform(actor.get_transform())
        except Exception:
            self.disable_manual_control()

    def _manual_control_compute_local_offset(
        self,
        actor_transform: carla.Transform,
        controller: Optional["TopDownCamera"],
    ) -> Tuple[float, float, float]:
        """Return the camera offset expressed in the actor's local frame."""
        if controller is None:
            return (0.0, 0.0, 0.0)
        actor_loc = actor_transform.location
        actor_rot = actor_transform.rotation

        dx = controller.center_x - actor_loc.x
        dy = controller.center_y - actor_loc.y
        dz = controller.height - actor_loc.z

        yaw_rad = math.radians(actor_rot.yaw)
        cos_yaw = math.cos(yaw_rad)
        sin_yaw = math.sin(yaw_rad)

        local_x = cos_yaw * dx + sin_yaw * dy
        local_y = -sin_yaw * dx + cos_yaw * dy
        return (local_x, local_y, dz)

    @staticmethod
    def _manual_control_build_world_transform(
        actor_transform: carla.Transform,
        local_offset: Tuple[float, float, float],
    ) -> carla.Transform:
        """Convert a local offset into a world-space transform with fixed orientation."""
        local_x, local_y, local_z = local_offset
        actor_loc = actor_transform.location
        actor_rot = actor_transform.rotation

        yaw_rad = math.radians(actor_rot.yaw)
        cos_yaw = math.cos(yaw_rad)
        sin_yaw = math.sin(yaw_rad)

        world_x = actor_loc.x + cos_yaw * local_x - sin_yaw * local_y
        world_y = actor_loc.y + sin_yaw * local_x + cos_yaw * local_y
        world_z = actor_loc.z + local_z

        world_location = carla.Location(x=world_x, y=world_y, z=world_z)
        world_rotation = carla.Rotation(pitch=-90.0, yaw=270.0, roll=0.0)
        return carla.Transform(world_location, world_rotation)

    def _manual_control_apply_target_transform(self, *, force: bool = False) -> None:
        """Apply the cached target transform to the controller and sensor."""
        transform = self._manual_control_target_transform
        controller = self.camera_controller
        if transform is None or not controller:
            return
        if self.manual_camera_free_look_active and not force:
            return
        controller.center_x = transform.location.x
        controller.center_y = transform.location.y
        controller.height = transform.location.z
        if hasattr(controller, "stop_moving"):
            controller.stop_moving()
        try:
            if self.camera_sensor:
                self.camera_sensor.set_transform(transform)
            if self.world:
                spectator = self.world.get_spectator()
                spectator.set_transform(transform)
        except Exception:
            pass
        self.camera_is_moving = False
        self.camera_movement_timer = time.time()

    def _manual_control_start_camera_follow(self, actor: Optional[carla.Actor]) -> None:
        """Begin free-camera following for manual control."""
        controller = self.camera_controller
        if not actor or not controller:
            self.manual_control_state['camera_follow_local_offset'] = (0.0, 0.0, 0.0)
            self._manual_control_target_transform = None
            return
        try:
            if not actor.is_alive:
                self.manual_control_state['camera_follow_local_offset'] = (0.0, 0.0, 0.0)
                self._manual_control_target_transform = None
                return
            actor_transform = actor.get_transform()
        except Exception:
            self.manual_control_state['camera_follow_local_offset'] = (0.0, 0.0, 0.0)
            self._manual_control_target_transform = None
            return

        local_offset = self._manual_control_compute_local_offset(actor_transform, controller)
        self.manual_control_state['camera_follow_local_offset'] = local_offset
        self._manual_control_target_transform = self._manual_control_build_world_transform(actor_transform, local_offset)
        self._manual_control_apply_target_transform()

    def _manual_control_stop_camera_follow(self) -> None:
        """Stop camera following and clear tick-based updates."""
        self._manual_control_unregister_tick_callback()
        self._manual_control_target_transform = None
        self.manual_control_state['camera_follow_local_offset'] = (0.0, 0.0, 0.0)

    @property
    def manual_camera_free_look_active(self) -> bool:
        """Return True while user temporarily detaches the camera from the ego follow."""
        return bool(self._manual_camera_free_look_sources)

    def begin_manual_camera_free_look(self, source: str) -> None:
        """Pause camera follow updates while ``source`` (mouse/keyboard) holds free-look."""
        if not self.manual_control_enabled:
            return
        key = source or "unknown"
        self._manual_camera_free_look_sources.add(key)
        self._pending_free_look_restores.pop(key, None)

    def end_manual_camera_free_look(self, source: str) -> None:
        """Resume follow once all free-look sources have released."""
        key = source or "unknown"
        if key not in self._manual_camera_free_look_sources:
            return
        if len(self._manual_camera_free_look_sources) > 1:
            self._manual_camera_free_look_sources.remove(key)
            self._pending_free_look_restores.pop(key, None)
            return
        if self._restore_camera_follow_after_free_look():
            self._manual_camera_free_look_sources.remove(key)
            self._pending_free_look_restores.pop(key, None)
            return
        self._pending_free_look_restores[key] = time.time() + self._manual_camera_restore_retry_window

    def _restore_camera_follow_after_free_look(self) -> bool:
        """Snap the camera back onto the ego vehicle using the cached offset."""
        if not self.manual_control_enabled:
            return False
        actor = self.manual_control_actor
        controller = self.camera_controller
        if not actor or not controller:
            return False
        try:
            if not actor.is_alive:
                return False
            actor_transform = actor.get_transform()
        except Exception:
            return False

        local_offset = self._manual_control_compute_local_offset(actor_transform, controller)
        self.manual_control_state['camera_follow_local_offset'] = local_offset
        self._manual_control_target_transform = self._manual_control_build_world_transform(
            actor_transform, local_offset
        )
        self._manual_control_apply_target_transform(force=True)
        return True

    def notify_manual_camera_adjustment(self) -> None:
        """Recalculate camera offset when the user manually moves the view."""
        if not self.manual_control_enabled:
            return
        if self.manual_camera_free_look_active:
            return
        actor = self.manual_control_actor
        controller = self.camera_controller
        if not actor or not controller:
            return
        try:
            if not actor.is_alive:
                return
            actor_transform = actor.get_transform()
        except Exception:
            return

        local_offset = self._manual_control_compute_local_offset(actor_transform, controller)
        self.manual_control_state['camera_follow_local_offset'] = local_offset
        self._manual_control_target_transform = self._manual_control_build_world_transform(actor_transform, local_offset)
        self._manual_control_apply_target_transform()

    def _process_pending_free_look_restores(self) -> None:
        """Retry deferred camera snapping once the ego transform is available."""
        if not self._pending_free_look_restores:
            return
        now = time.time()
        pending_items = list(self._pending_free_look_restores.items())
        for key, deadline in pending_items:
            if key not in self._manual_camera_free_look_sources:
                self._pending_free_look_restores.pop(key, None)
                continue
            if not self.manual_control_enabled:
                self._manual_camera_free_look_sources.discard(key)
                self._pending_free_look_restores.pop(key, None)
                continue
            if self._restore_camera_follow_after_free_look():
                self._manual_camera_free_look_sources.discard(key)
                self._pending_free_look_restores.pop(key, None)
                continue
            if now >= deadline:
                self._manual_camera_free_look_sources.discard(key)
                self._pending_free_look_restores.pop(key, None)

    def _manual_control_register_tick_callback(self) -> None:
        """Subscribe to CARLA world ticks to keep the camera in sync."""
        if not self.world or self._manual_control_tick_subscription is not None:
            return
        try:
            self._manual_control_tick_subscription = self.world.on_tick(self._manual_control_on_world_tick)
        except Exception:
            self._manual_control_tick_subscription = None

    def _manual_control_unregister_tick_callback(self) -> None:
        """Remove any active manual-control tick subscription."""
        if self._manual_control_tick_subscription is None:
            return
        try:
            if self.world:
                self.world.remove_on_tick(self._manual_control_tick_subscription)
        except Exception:
            pass
        finally:
            self._manual_control_tick_subscription = None

    def _manual_control_on_world_tick(self, _snapshot) -> None:
        """Snap the camera to the ego offset each simulator tick."""
        if not self.manual_control_enabled:
            self._manual_control_unregister_tick_callback()
            return
        actor = self.manual_control_actor
        if not actor:
            return
        try:
            if not actor.is_alive:
                return
            actor_transform = actor.get_transform()
        except Exception:
            return

        local_offset = self.manual_control_state.get('camera_follow_local_offset', (0.0, 0.0, 0.0))
        self._manual_control_target_transform = self._manual_control_build_world_transform(actor_transform, local_offset)
        self._manual_control_apply_target_transform()

    # -------------------------------------------------------------------------
    # Playback Camera Follow (for local ego with route, decoupled from manual control)
    # -------------------------------------------------------------------------

    def request_playback_camera_follow(self) -> None:
        """Begin watching for an ego vehicle to follow during playback (no keyboard control)."""
        self.playback_camera_follow_pending = True
        self.playback_camera_follow_enabled = False
        self.playback_camera_follow_actor = None
        self._playback_camera_follow_search_timer = 0.0
        self._playback_camera_follow_local_offset = (0.0, 0.0, 0.0)
        self._playback_camera_target_transform = None

    def _stop_playback_camera_follow(self) -> None:
        """Stop playback camera following and clear tick-based updates."""
        self._playback_camera_unregister_tick_callback()
        self.playback_camera_follow_enabled = False
        self.playback_camera_follow_pending = False
        self.playback_camera_follow_actor = None
        self._playback_camera_follow_local_offset = (0.0, 0.0, 0.0)
        self._playback_camera_target_transform = None

    def _start_playback_camera_follow(self, actor: carla.Actor) -> None:
        """Begin camera following for the given actor during playback."""
        controller = self.camera_controller
        if not actor or not controller:
            self._playback_camera_follow_local_offset = (0.0, 0.0, 0.0)
            self._playback_camera_target_transform = None
            return
        try:
            if not actor.is_alive:
                self._playback_camera_follow_local_offset = (0.0, 0.0, 0.0)
                self._playback_camera_target_transform = None
                return
            actor_transform = actor.get_transform()
        except Exception:
            self._playback_camera_follow_local_offset = (0.0, 0.0, 0.0)
            self._playback_camera_target_transform = None
            return

        # Reuse the manual control helper to compute local offset
        local_offset = self._manual_control_compute_local_offset(actor_transform, controller)
        self._playback_camera_follow_local_offset = local_offset
        self._playback_camera_target_transform = self._manual_control_build_world_transform(actor_transform, local_offset)
        self._playback_camera_apply_target_transform()
        self._playback_camera_register_tick_callback()

    def _playback_camera_apply_target_transform(self) -> None:
        """Apply the computed camera transform to the camera controller and spectator."""
        transform = self._playback_camera_target_transform
        if not transform:
            return
        controller = self.camera_controller
        if controller:
            try:
                controller.set_position(transform.location.x, transform.location.y, transform.location.z)
                controller.set_rotation(transform.rotation.pitch, transform.rotation.yaw, transform.rotation.roll)
            except Exception:
                pass
        try:
            spectator = self.world.get_spectator()
            if spectator:
                spectator.set_transform(transform)
        except Exception:
            pass
        self.camera_is_moving = False
        self.camera_movement_timer = time.time()

    def _playback_camera_register_tick_callback(self) -> None:
        """Subscribe to CARLA world ticks to keep the camera in sync during playback."""
        if not self.world or self._playback_camera_tick_subscription is not None:
            return
        try:
            self._playback_camera_tick_subscription = self.world.on_tick(self._playback_camera_on_world_tick)
        except Exception:
            self._playback_camera_tick_subscription = None

    def _playback_camera_unregister_tick_callback(self) -> None:
        """Remove any active playback camera tick subscription."""
        if self._playback_camera_tick_subscription is None:
            return
        try:
            if self.world:
                self.world.remove_on_tick(self._playback_camera_tick_subscription)
        except Exception:
            pass
        finally:
            self._playback_camera_tick_subscription = None

    def _playback_camera_on_world_tick(self, _snapshot) -> None:
        """Snap the camera to the ego offset each simulator tick (playback mode)."""
        if not self.playback_camera_follow_enabled:
            self._playback_camera_unregister_tick_callback()
            return
        actor = self.playback_camera_follow_actor
        if not actor:
            return
        try:
            if not actor.is_alive:
                return
            actor_transform = actor.get_transform()
        except Exception:
            return

        local_offset = self._playback_camera_follow_local_offset
        self._playback_camera_target_transform = self._manual_control_build_world_transform(actor_transform, local_offset)
        self._playback_camera_apply_target_transform()

    def _playback_camera_follow_update(self, dt: float) -> None:
        """Update playback camera follow state - find ego and start following."""
        # Already following? Just check actor is still alive
        if self.playback_camera_follow_enabled:
            actor = self.playback_camera_follow_actor
            if not actor:
                self._stop_playback_camera_follow()
            else:
                try:
                    if not actor.is_alive:
                        self._stop_playback_camera_follow()
                except Exception:
                    self._stop_playback_camera_follow()
            return

        # Not pending? Nothing to do
        if not self.playback_camera_follow_pending:
            return

        # Search for ego vehicle periodically
        self._playback_camera_follow_search_timer -= dt
        if self._playback_camera_follow_search_timer > 0:
            return
        self._playback_camera_follow_search_timer = 0.25  # Search every 250ms

        # Reuse the manual control actor finder logic
        actor = self._find_manual_control_actor()
        if actor is None:
            return

        # Found the ego - start following
        self.playback_camera_follow_actor = actor
        self.playback_camera_follow_enabled = True
        self.playback_camera_follow_pending = False
        self._start_playback_camera_follow(actor)

    def _register_pedestrian_highlight_tick(self) -> None:
        """Subscribe to CARLA world ticks to draw pedestrian rings."""
        if not self.world or self._pedestrian_highlight_subscription is not None:
            return
        try:
            self._pedestrian_highlight_subscription = self.world.on_tick(self._on_pedestrian_highlight_tick)
        except Exception:
            self._pedestrian_highlight_subscription = None

    def _unregister_pedestrian_highlight_tick(self) -> None:
        """Remove the pedestrian highlight tick subscription."""
        if self._pedestrian_highlight_subscription is None:
            return
        try:
            if self.world:
                self.world.remove_on_tick(self._pedestrian_highlight_subscription)
        except Exception:
            pass
        finally:
            self._pedestrian_highlight_subscription = None

    def _on_pedestrian_highlight_tick(self, _snapshot) -> None:
        """Draw a single world-space ring around each pedestrian (no center marker)."""
        if not self.world or not self.spawned_vehicles:
            return

        now = time.time()
        seen_ids: Set[int] = set()
        lifetime = 0.4
        radius = 1.0
        steps = 24
        thickness = 0.1
        refresh_interval = 0.25  # seconds

        for actor in self.spawned_vehicles:
            if not actor or not actor.is_alive:
                continue
            try:
                type_id = actor.type_id
            except Exception:
                continue
            if not type_id.startswith('walker.'):
                continue

            actor_id = actor.id
            seen_ids.add(actor_id)

            last_draw = self._pedestrian_highlight_last_draw.get(actor_id, 0.0)
            if (now - last_draw) < refresh_interval:
                continue

            color = self.pedestrian_colors.get(actor_id)
            if color is None:
                palette_index = len(self.pedestrian_colors) % len(_WALKER_COLOR_PALETTE)
                r, g, b = _WALKER_COLOR_PALETTE[palette_index]
                color = carla.Color(r, g, b)
                self.pedestrian_colors[actor_id] = color

            try:
                location = actor.get_location()
            except Exception:
                continue

            base_z = location.z + 0.25
            draw_height = base_z

            try:
                angle_step = 2.0 * math.pi / steps
                for i in range(steps):
                    angle1 = angle_step * i
                    angle2 = angle_step * (i + 1)
                    point1 = carla.Location(
                        location.x + radius * math.cos(angle1),
                        location.y + radius * math.sin(angle1),
                        draw_height,
                    )
                    point2 = carla.Location(
                        location.x + radius * math.cos(angle2),
                        location.y + radius * math.sin(angle2),
                        draw_height,
                    )
                    self.world.debug.draw_line(
                        point1,
                        point2,
                        thickness=thickness,
                        color=color,
                        life_time=lifetime,
                        persistent_lines=False,
                    )
                self._pedestrian_highlight_last_draw[actor_id] = now
            except Exception:
                continue

        if self.pedestrian_colors:
            stale_ids = [pid for pid in self.pedestrian_colors.keys() if pid not in seen_ids]
            for pid in stale_ids:
                self.pedestrian_colors.pop(pid, None)
                self._pedestrian_highlight_last_draw.pop(pid, None)

    def is_ego_vehicle(self, vehicle_id: Optional[int]) -> bool:
        return vehicle_id is not None and self.ego_vehicle_id == vehicle_id

    def is_ego_vehicle_active(self) -> bool:
        if self.ego_vehicle_id is None:
            return False
        actor = next((veh for veh in self.spawned_vehicles if veh.id == self.ego_vehicle_id and veh.is_alive), None)
        if actor:
            return True
        self.clear_ego_vehicle(self.ego_vehicle_id)
        return False

    def get_editor_ego_actor(self) -> Optional[carla.Actor]:
        """Return the ego actor spawned via the editor, if it is still alive."""
        ego_id = self.ego_vehicle_id
        if ego_id is None:
            return None
        return next(
            (actor for actor in self.spawned_vehicles if actor and actor.is_alive and actor.id == ego_id),
            None,
        )

    def get_ego_vehicle_actor(self) -> Optional[carla.Actor]:
        """Find a live ego-designated actor in the world, even if not tracked."""
        if not self.world:
            return None
        try:
            actors = self.world.get_actors().filter('vehicle.*')
        except RuntimeError:
            return None
        tracked = {actor.id for actor in self.spawned_vehicles if actor and actor.is_alive}
        roles = {'hero', 'ego', 'ego_vehicle', 'player'}
        for actor in actors:
            if actor.id in tracked and self.is_ego_vehicle(actor.id):
                if actor.is_alive:
                    return actor
                continue
            role_name = actor.attributes.get('role_name', '').lower()
            if role_name in roles and actor.is_alive:
                return actor
        return None

    def get_ego_vehicle_data(self) -> Optional[dict]:
        """Return serialized ego vehicle data for saving, if present."""
        if not self.is_ego_vehicle_active():
            return None
        actor = next((veh for veh in self.spawned_vehicles if veh.id == self.ego_vehicle_id and veh.is_alive), None)
        transform = None
        if actor:
            transform = actor.get_transform()
            self.update_editor_ego_transform(transform)
        elif self.ego_vehicle_transform:
            transform = self.ego_vehicle_transform

        if not transform:
            return None

        ego_data = {
            "type": self.ego_vehicle_blueprint or "vehicle.lexus.utlexus",
            "location": {
                "x": transform.location.x,
                "y": transform.location.y,
                "z": transform.location.z,
            },
            "rotation": {
                "pitch": transform.rotation.pitch,
                "yaw": transform.rotation.yaw,
                "roll": transform.rotation.roll,
            },
            "role": "ego_vehicle",
        }
        color = self.get_vehicle_color(self.ego_vehicle_id)
        if color is not None:
            ego_data["color"] = color
        ignore_flags = self.get_vehicle_ignore_flags(self.ego_vehicle_id)
        ego_data["ignore_traffic_lights"] = ignore_flags["traffic_lights"]
        ego_data["ignore_stop_signs"] = ignore_flags["stop_signs"]
        ego_data["ignore_vehicles"] = ignore_flags["vehicles"]
        ego_data["max_lat_acc"] = float(self.get_vehicle_max_lat_acc(self.ego_vehicle_id, 3.0))
        serialized_waypoints, destination_speed = self._serialize_waypoints_for_vehicle(
            self.ego_vehicle_id,
            start_location=transform,
        )
        if serialized_waypoints:
            ego_data["waypoints"] = serialized_waypoints
        if destination_speed is not None:
            ego_data["destination_speed_km_h"] = destination_speed
        return ego_data
    
    def draw_waypoints_carla_debug_local(self):
        """Local version of waypoint debug drawing"""
        if not self.waypoint_display_vehicle_id:
            return

        waypoints = self.get_vehicle_waypoints(self.waypoint_display_vehicle_id)
        if not waypoints:
            return

        if not waypoints:
            return
            
        # Find the vehicle for this waypoint set (may be missing during playback)
        vehicle = None
        for spawned_vehicle in self.spawned_vehicles:
            if spawned_vehicle.id == self.waypoint_display_vehicle_id:
                if spawned_vehicle.is_alive:
                    vehicle = spawned_vehicle
                break
            
        # Get hovered waypoint
        hovered_waypoint = self.get_hovered_waypoint()

        # Resolve any stored start marker (works even if vehicle is hidden)
        start_point = self._get_start_marker_for_vehicle_id(self.waypoint_display_vehicle_id)
        
        override_id = getattr(self, "_waypoint_ego_override_id", None)
        is_ego_path = self.is_ego_vehicle(self.waypoint_display_vehicle_id) or (
            override_id is not None and self.waypoint_display_vehicle_id == override_id
        )

        # Draw connection lines first (so they appear behind markers)
        self._draw_waypoint_connections_carla_debug_local(vehicle, start_point, waypoints, is_ego_path=is_ego_path)
        
        # Draw starting point marker if vehicle is hidden for scenario
        if start_point:
            start_location = carla.Location(start_point['x'], start_point['y'], start_point['z'] + 0.5)
            
            # Draw starting point marker with distinct appearance
            self.world.debug.draw_point(
                start_location,
                size=0.5,
                color=carla.Color(255, 0, 255),  # Magenta for starting point
                life_time=1.0
            )
            
            # Draw "START" text above the marker
            text_location = carla.Location(start_point['x'], start_point['y'], start_point['z'] + 2.0)
            self.world.debug.draw_string(
                text_location,
                "START",
                draw_shadow=True,
                color=carla.Color(255, 0, 255),  # Magenta text
                life_time=1.0,
                persistent_lines=False
            )
        
        # Draw waypoint markers
        for i, waypoint in enumerate(waypoints):
            # Determine waypoint state and colors
            is_selected = (self.selected_waypoint_vehicle_id == self.waypoint_display_vehicle_id and 
                          self.selected_waypoint_index == i)
            is_hovered = (hovered_waypoint and hovered_waypoint[0] == self.waypoint_display_vehicle_id and 
                         hovered_waypoint[1] == i)
            is_finish_line = (i == len(waypoints) - 1)
            
            # Choose colors based on waypoint properties and state
            base_color = carla.Color(255, 215, 0) if is_ego_path else carla.Color(0, 255, 0)
            selected_color = carla.Color(255, 255, 120) if is_ego_path else carla.Color(255, 255, 0)
            hovered_color = carla.Color(255, 235, 150) if is_ego_path else carla.Color(255, 200, 0)
            finish_color = carla.Color(255, 215, 0) if is_ego_path else carla.Color(255, 50, 50)
                
            # Modify color based on state
            if is_finish_line and not is_selected:
                marker_color = finish_color
            elif is_selected:
                marker_color = selected_color
            elif is_hovered:
                marker_color = hovered_color
            else:
                marker_color = base_color
                
            # Create waypoint location
            location = carla.Location(waypoint['x'], waypoint['y'], waypoint['z'] + 0.5)
            
            # Draw different markers based on type
            if is_finish_line:
                self._draw_finish_line_carla_debug_local(
                    location, waypoints, i, is_selected, is_hovered, is_ego_path=is_ego_path
                )
            else:
                # Draw main waypoint marker (slightly bigger for better visibility)
                marker_size = 0.4 if is_selected or is_hovered else 0.3
                self.world.debug.draw_point(
                    location,
                    size=marker_size,
                    color=marker_color,
                    life_time=self.waypoint_debug_lifetime
                )
                
                # Draw waypoint number above the marker
                text_location = carla.Location(waypoint['x'], waypoint['y'], waypoint['z'] + 2.0)
                self.world.debug.draw_string(
                    text_location,
                    str(i + 1),
                    draw_shadow=True,
                    color=carla.Color(255, 255, 255),
                    life_time=self.waypoint_debug_lifetime,
                    persistent_lines=False
                )
                
            # Direction arrows removed for cleaner appearance
    
    def get_hovered_waypoint(self):
        """Get the currently hovered waypoint based on screen coordinates"""
        if not hasattr(self, 'waypoint_hover_index') or not self.waypoint_hover_index:
            return None
        return self.waypoint_hover_index
    
    def _draw_waypoint_connections_carla_debug_local(self, vehicle, start_point, waypoints, *, is_ego_path=False):
        """Draw connection lines between waypoints using CARLA debug drawing"""
        line_color = carla.Color(255, 215, 0) if is_ego_path else carla.Color(0, 255, 0)  # Gold for ego, green otherwise
        
        for i, waypoint in enumerate(waypoints):
            if i == 0:
                # First waypoint - connect to vehicle or starting point marker
                if start_point:
                    # Use starting point marker
                    start_location = carla.Location(
                        start_point['x'], 
                        start_point['y'], 
                        start_point['z'] + 0.5
                    )
                elif vehicle:
                    # Use actual vehicle location
                    vehicle_location = vehicle.get_location()
                    start_location = carla.Location(
                        vehicle_location.x, 
                        vehicle_location.y, 
                        vehicle_location.z + 0.5
                    )
                else:
                    start_location = None
            else:
                # Connect to previous waypoint
                prev_waypoint = waypoints[i - 1]
                start_location = carla.Location(
                    prev_waypoint['x'], 
                    prev_waypoint['y'], 
                    prev_waypoint['z'] + 0.5
                )
            
            # End point is current waypoint
            end_location = carla.Location(
                waypoint['x'], 
                waypoint['y'], 
                waypoint['z'] + 0.5
            )
            
            # Draw connection line
            if start_location is not None:
                self.world.debug.draw_line(
                    start_location,
                    end_location,
                    thickness=0.1,
                    color=line_color,
                    life_time=self.waypoint_debug_lifetime
                )
    
    def _draw_finish_line_carla_debug_local(self, location, waypoints, waypoint_index, is_selected, is_hovered, *, is_ego_path=False):
        """Draw a finish line pattern for the last waypoint using CARLA debug drawing"""
        # Calculate trajectory direction for perpendicular orientation
        if waypoint_index > 0:
            # Use direction from previous waypoint to this one
            prev_waypoint = waypoints[waypoint_index - 1]
            current_waypoint = waypoints[waypoint_index]
            
            # Calculate trajectory angle
            dx = current_waypoint['x'] - prev_waypoint['x']
            dy = current_waypoint['y'] - prev_waypoint['y']
            trajectory_angle = math.atan2(dy, dx)
            
            # Perpendicular angle (90 degrees rotated)
            perpendicular_angle = trajectory_angle + math.pi / 2
        else:
            perpendicular_angle = 0  # Default horizontal for single waypoint
        
        # Finish line dimensions (balanced size for close and far zoom)
        line_length = 5.0 if is_selected or is_hovered else 4.0
        line_thickness = 0.14 if is_selected or is_hovered else 0.1
        
        # Calculate finish line endpoints
        half_length = line_length / 2
        end1_x = location.x + half_length * math.cos(perpendicular_angle)
        end1_y = location.y + half_length * math.sin(perpendicular_angle)
        end2_x = location.x - half_length * math.cos(perpendicular_angle)
        end2_y = location.y - half_length * math.sin(perpendicular_angle)
        
        end1 = carla.Location(end1_x, end1_y, location.z)
        end2 = carla.Location(end2_x, end2_y, location.z)
        
        # Draw finish line (red and white checkered pattern approximated with alternating segments)
        segments = 6
        if is_ego_path:
            segment_color_1 = carla.Color(255, 235, 150)  # Light gold
            segment_color_2 = carla.Color(210, 170, 0)    # Deep gold
        else:
            segment_color_1 = carla.Color(255, 255, 255)  # White
            segment_color_2 = carla.Color(255, 50, 50)    # Red
        
        for i in range(segments):
            t1 = i / segments
            t2 = (i + 1) / segments
            
            seg_start_x = end1_x + t1 * (end2_x - end1_x)
            seg_start_y = end1_y + t1 * (end2_y - end1_y)
            seg_end_x = end1_x + t2 * (end2_x - end1_x)
            seg_end_y = end1_y + t2 * (end2_y - end1_y)
            
            seg_start = carla.Location(seg_start_x, seg_start_y, location.z)
            seg_end = carla.Location(seg_end_x, seg_end_y, location.z)
            
            # Alternate colors
            color = segment_color_1 if i % 2 == 0 else segment_color_2
            
            self.world.debug.draw_line(
                seg_start,
                seg_end,
                thickness=line_thickness,
                color=color,
                life_time=self.waypoint_debug_lifetime
            )
    
    def _draw_waypoint_direction_arrow_carla_debug_local(self, location, yaw):
        """Direction arrows disabled for cleaner appearance"""
        # This function is no longer used - arrows removed for cleaner visualization
        pass
    
    def handle_map_reload_for_debug_clear(self):
        """Handle map reload to clear debug drawings while preserving vehicles"""
        try:
            print("Handling map reload to clear debug drawings...")

            if self._map_refresh_disabled:
                print("Map reload skipped: world map refresh is disabled in synchronous mode.")
                return False
            
            # Step 1: Save vehicle information
            vehicle_data = []
            if self.spawned_vehicles:
                print(f"Preserving {len(self.spawned_vehicles)} vehicles...")
                for vehicle in self.spawned_vehicles:
                    if vehicle and vehicle.is_alive:
                        transform = vehicle.get_transform()
                        blueprint_id = vehicle.type_id
                        vehicle_data.append({
                            'blueprint': blueprint_id,
                            'transform': transform,
                            'physics_enabled': False  # We know they have physics disabled
                        })
                
                # Step 2: Destroy old vehicles
                self.cleanup_all_vehicles()
            
            # Step 3: Try to reload the map using the current map name
            current_map = self._safe_get_world_map()
            if not current_map:
                print("Unable to determine current map; aborting reload.")
                return False
            current_map_name = current_map.name
            print(f"Attempting to reload map: {current_map_name}")
            
            # Extract just the map name from the full path (everything after the last '/')
            map_name_only = current_map_name.split('/')[-1]
            print(f"Using map name: {map_name_only}")
            
            # The proper way is to get client reference from somewhere...
            # Since we don't have direct access, we'll use a workaround
            # This approach creates a temporary client connection
            try:
                import carla
                
                # Determine the port from environment or use default
                port = getattr(self, '_server_port', 2000)
                host = getattr(self, '_server_host', '127.0.0.1')
                
                # Create temporary client for reload
                temp_client = carla.Client(host, port)
                temp_client.set_timeout(10.0)
                
                # Load the same map (this effectively reloads it and clears debug drawings)
                temp_client.load_world(map_name_only, map_layers=carla.MapLayer.NONE)
                
                # Get the new world reference
                new_world = temp_client.get_world()
                
                # Update all references
                self.world = new_world

                # Update coordinate detector references
                if self.coordinate_detector:
                    self.coordinate_detector.world = new_world
                    self.coordinate_detector.world_map = None  # Will lazy-load when needed
                
                print("Map reloaded successfully using temporary client")
                
            except Exception as e:
                print(f"Error with temporary client reload: {e}")
                return False

            # Step 4: Wait for reload to complete
            time.sleep(3)
            
            # Step 5: Respawn vehicles
            if vehicle_data:
                print(f"Respawning {len(vehicle_data)} vehicles...")
                blueprint_library = self.world.get_blueprint_library()
                
                respawned_count = 0
                for data in vehicle_data:
                    try:
                        vehicle_bp = blueprint_library.find(data['blueprint'])
                        
                        # Adjust vehicle spawn height
                        adjusted_transform = carla.Transform(data['transform'].location, data['transform'].rotation)
                        adjusted_transform.location.z = get_ground_height(
                            self.world,
                            data['transform'].location,
                            cached_map=self.cached_map,
                        )
                        
                        vehicle = self.world.try_spawn_actor(vehicle_bp, adjusted_transform)
                        if vehicle:
                            vehicle.set_simulate_physics(data['physics_enabled'])
                            self.spawned_vehicles.append(vehicle)
                            respawned_count += 1
                            print(f"Vehicle respawned at adjusted height: {adjusted_transform.location.z:.2f}")
                        else:
                            print(f"Failed to respawn vehicle {data['blueprint']} - location might be blocked")
                            print(f"Failed to respawn vehicle: {data['blueprint']} - location may be blocked")
                    except Exception as e:
                        print(f"Error respawning vehicle {data['blueprint']}: {e}")
                
                print(f"Successfully respawned {respawned_count}/{len(vehicle_data)} vehicles")
                
                if respawned_count < len(vehicle_data):
                    print(f"Warning: {len(vehicle_data) - respawned_count} vehicles could not be respawned")
            
            # Step 6: Reset visualization state (OpenDRIVE overlay will be recomputed when needed)
            print("Map reloaded successfully - all debug drawings cleared, vehicles preserved")
            
            return True
            
        except Exception as e:
            print(f"Error in map reload handler: {e}")
            traceback.print_exc()
            return False
    
    def check_menu_icon_click(self, mouse_x, mouse_y):
        """Check if a click hits any of the vehicle menu icons"""
        if not (self.selected_vehicle and self.vehicle_menu_position):
            return None

        is_ego = self.is_ego_vehicle(self.selected_vehicle.id)
        icon_order = ['delete', 'move']
        if not self.selected_vehicle_is_pedestrian:
            icon_order.append('rotate')
        if not is_ego:
            icon_order.append('waypoint')
        if not self.selected_vehicle_is_pedestrian and not is_ego:
            icon_order.append('autoroute')
        if is_ego and not self.selected_vehicle_is_pedestrian:
            icon_order.append('ego_destination')
        trigger_supported = False
        if self.selected_vehicle_is_pedestrian:
            trigger_supported = True
        elif not is_ego:
            trigger_supported = True

        has_personal_trigger = False
        actor_id = self.selected_vehicle.id
        if self.selected_vehicle_is_pedestrian:
            has_personal_trigger = actor_id in self.pedestrian_trigger_radii
        elif not is_ego:
            has_personal_trigger = actor_id in self.vehicle_trigger_radii

        if trigger_supported:
            icon_order.append('add_trigger')
            if has_personal_trigger:
                icon_order.append('remove_trigger')

        return OverlayMenuRenderer.hit_test(
            self.vehicle_menu_position,
            icon_order,
            (self.screen_width, self.screen_height),
            (mouse_x, mouse_y),
        )
    
    def check_vehicle_collision(self, vehicle, new_transform):
        """Check if a vehicle would collide with other vehicles at the new transform"""
        if not vehicle or not vehicle.is_alive:
            return True  # Collision if vehicle is invalid
        
        # Get the bounding box of the vehicle we're moving/rotating
        vehicle_bbox = vehicle.bounding_box
        
        # Create a temporary transform to check collision
        test_location = new_transform.location
        test_rotation = new_transform.rotation
        
        # Check collision with all other vehicles
        for other_vehicle in self.spawned_vehicles:
            if (other_vehicle and other_vehicle.is_alive and 
                other_vehicle.id != vehicle.id):
                
                other_location = other_vehicle.get_location()
                other_bbox = other_vehicle.bounding_box
                
                # Calculate 2D distance between vehicle centers
                dx = test_location.x - other_location.x
                dy = test_location.y - other_location.y
                distance_2d = math.sqrt(dx * dx + dy * dy)
                
                # Calculate combined bounding box size (approximate collision check)
                combined_extent = (vehicle_bbox.extent.x + other_bbox.extent.x +
                                 vehicle_bbox.extent.y + other_bbox.extent.y) / 2.0
                
                # Add some safety margin
                collision_threshold = combined_extent * 0.8
                
                if distance_2d < collision_threshold:
                    return True  # Collision detected
        
        return False  # No collision

    def _is_pedestrian_actor(self, actor_id):
        """Utility to determine if the given actor id belongs to a pedestrian."""
        for actor in self.spawned_vehicles:
            if actor and actor.is_alive and actor.id == actor_id:
                return actor.type_id.startswith('walker.')
        return False

    def _adjust_pedestrian_spawn_orientation(self, actor_id):
        """Rotate a pedestrian to face its first waypoint."""
        if not self._is_pedestrian_actor(actor_id):
            return

        waypoints = self.get_vehicle_waypoints(actor_id)
        if not waypoints:
            return

        first_wp = waypoints[0]
        vehicle = None
        for actor in self.spawned_vehicles:
            if actor and actor.is_alive and actor.id == actor_id:
                vehicle = actor
                break
        if vehicle is None:
            return

        vehicle_loc = vehicle.get_location()
        dx = first_wp['x'] - vehicle_loc.x
        dy = first_wp['y'] - vehicle_loc.y
        if abs(dx) < 1e-3 and abs(dy) < 1e-3:
            return

        yaw = math.degrees(math.atan2(dy, dx))
        transform = vehicle.get_transform()
        transform.rotation.yaw = yaw
        vehicle.set_transform(transform)

        if (self.editor and hasattr(self.editor, 'info_panel')):
            panel = self.editor.info_panel
            if (panel.visible and panel.object_type in ('vehicle', 'pedestrian') and
                    panel.selected_object == vehicle):
                panel.fields['yaw'] = f"{yaw:.2f}"
    
    def start_vehicle_movement(self, mouse_pos, snap_to_lane=False):
        """Start moving the selected vehicle"""
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            self.moving_vehicle = True
            self.movement_start_mouse_pos = mouse_pos
            self.movement_start_location = self.selected_vehicle.get_location()
            self.movement_snap_to_lane = snap_to_lane  # Store lane snapping preference
            
            if snap_to_lane:
                print(f"Started moving vehicle from ({self.movement_start_location.x:.2f}, {self.movement_start_location.y:.2f}) with lane snapping")
            else:
                print(f"Started moving vehicle from ({self.movement_start_location.x:.2f}, {self.movement_start_location.y:.2f})")
    
    def update_vehicle_movement(self, mouse_pos):
        """Update vehicle position based on mouse movement"""
        if not (self.moving_vehicle and self.selected_vehicle and self.selected_vehicle.is_alive):
            return
        
        # Calculate mouse delta
        mouse_dx = mouse_pos[0] - self.movement_start_mouse_pos[0]
        mouse_dy = mouse_pos[1] - self.movement_start_mouse_pos[1]
        
        # Convert screen movement to world movement
        camera_height = self.camera_controller.height
        movement_scale = camera_height / 400.0  # Scale based on camera height
        
        world_dx = mouse_dx * movement_scale * 0.1
        world_dy = mouse_dy * movement_scale * 0.1
        
        # Calculate new world position
        new_location = carla.Location(
            self.movement_start_location.x + world_dx,
            self.movement_start_location.y + world_dy,
            self.movement_start_location.z
        )
        
        # Check if lane snapping is enabled
        if hasattr(self, 'movement_snap_to_lane') and self.movement_snap_to_lane:
            # Snap to closest lane using fast method (without raycast during movement)
            lane_result = self.coordinate_detector.find_closest_lane_point_fast(
                new_location.x, new_location.y, new_location.z
            )
            
            if lane_result['success']:
                # Use lane position and orientation (with OpenDRIVE height for now)
                snapped_location = carla.Location(
                    lane_result['x'], 
                    lane_result['y'], 
                    lane_result['z'] + 0.1  # Use OpenDRIVE height + offset during movement
                )
                lane_rotation = carla.Rotation(pitch=0.0, yaw=lane_result['yaw'], roll=0.0)
                new_transform = carla.Transform(snapped_location, lane_rotation)
            else:
                # Fallback to original position if no lane found
                current_transform = self.selected_vehicle.get_transform()
                new_transform = carla.Transform(new_location, current_transform.rotation)
        else:
            # Normal movement without lane snapping
            current_transform = self.selected_vehicle.get_transform()
            new_transform = carla.Transform(new_location, current_transform.rotation)
        
        # Check for collision
        if not self.check_vehicle_collision(self.selected_vehicle, new_transform):
            # No collision, apply the movement
            self.selected_vehicle.set_transform(new_transform)
        # If collision detected, don't move the vehicle
    
    def get_ground_height_at_location(self, x, y, reference_z=None, return_metadata=False, probe_on_miss=True):
        """Return ground height metadata at (x, y) using raycast-based sampler.

        Args:
            probe_on_miss: If False, skip expensive grid search when raycast misses (faster for waypoints with known Z)
        """
        location = carla.Location(x, y, reference_z if reference_z is not None else 0.0)
        debug_mode = getattr(self, 'debug_raycast', False)
        cached_map = self._get_cached_map(refresh=False)
        result = get_ground_height(
            self.world,
            location,
            debug=debug_mode,
            cached_map=cached_map,
            return_metadata=True,
            probe_on_miss=probe_on_miss,
        )
        if return_metadata:
            return result
        return result['height']

    def stop_vehicle_movement(self):
        """Stop moving the vehicle and adjust to final position with proper height"""
        if self.moving_vehicle:
            actor = self.selected_vehicle if self.selected_vehicle and self.selected_vehicle.is_alive else None
            old_transform = None
            is_pedestrian = bool(actor and self._is_pedestrian_actor(actor.id))
            ped_height_offset = None
            if hasattr(self, 'movement_start_location') and self.movement_start_location:
                # Create original transform for undo
                reference_transform = actor.get_transform() if actor else None
                if reference_transform:
                    old_transform = carla.Transform(self.movement_start_location, reference_transform.rotation)
            
            # For pedestrians, use their bounding box height to determine the placement offset
            if actor and is_pedestrian:
                try:
                    bbox_extent_z = float(getattr(actor.bounding_box.extent, "z", 1.0))
                except Exception:
                    bbox_extent_z = 1.0
                # Keep at least a 0.2m buffer above ground
                ped_height_offset = max(0.2, bbox_extent_z + 0.2)
            
            self.moving_vehicle = False
            if actor and actor.is_alive:
                final_location = actor.get_location()

                # Determine target XY/rotation based on snapping
                corrected_x = final_location.x
                corrected_y = final_location.y
                corrected_rotation = actor.get_transform().rotation
                if hasattr(self, 'movement_snap_to_lane') and self.movement_snap_to_lane:
                    lane_result = self.coordinate_detector.find_closest_lane_point(
                        final_location.x, final_location.y, final_location.z
                    )
                    if lane_result and lane_result.get('success'):
                        corrected_x = lane_result['x']
                        corrected_y = lane_result['y']
                        corrected_rotation = carla.Rotation(pitch=0.0, yaw=lane_result['yaw'], roll=0.0)

                # Temporarily lift actor out of the raycast path
                original_transform = actor.get_transform()
                lifted_actor = False
                if original_transform:
                    try:
                        lifted_location = carla.Location(
                            original_transform.location.x,
                            original_transform.location.y,
                            original_transform.location.z + 500.0,
                        )
                        actor.set_location(lifted_location)
                        lifted_actor = True
                    except Exception:
                        lifted_actor = False

                corrected_transform = None
                try:
                    ground_sample = self.get_ground_height_at_location(
                        corrected_x,
                        corrected_y,
                        reference_z=final_location.z,
                        return_metadata=True,
                    )

                    ground_height = ground_sample.get('height', final_location.z)
                    if is_pedestrian and ped_height_offset is not None:
                        spawn_height = (ground_height if ground_height is not None else final_location.z) + ped_height_offset
                    else:
                        spawn_height = (ground_height if ground_height is not None else final_location.z) + 0.2

                    corrected_location = carla.Location(
                        corrected_x,
                        corrected_y,
                        spawn_height,
                    )
                    corrected_transform = carla.Transform(corrected_location, corrected_rotation)
                    
                    # Update vehicle position with corrected transform
                    actor.set_transform(corrected_transform)
                finally:
                    if corrected_transform is None and lifted_actor and original_transform:
                        # Restore actor if placement failed
                        try:
                            actor.set_transform(original_transform)
                        except Exception:
                            pass
                
                # Create movement command if vehicle was actually moved
                if (old_transform and 
                    (abs(old_transform.location.x - corrected_transform.location.x) > 0.1 or
                     abs(old_transform.location.y - corrected_transform.location.y) > 0.1 or
                     abs(old_transform.location.z - corrected_transform.location.z) > 0.1)):
                    
                    command = MoveVehicleCommand(
                        self,
                        actor,
                        old_transform,
                        corrected_transform
                    )
                    self.editor.execute_command(command)
                
                print(f"Finished moving vehicle to ({final_location.x:.2f}, {final_location.y:.2f}) - Height adjusted to {corrected_transform.location.z:.2f}")
            # Reset movement tracking
            self.movement_start_location = None
    

    def start_vehicle_rotation(self, mouse_y):
        """Start rotating the selected vehicle"""
        if self.selected_vehicle_is_pedestrian:
            print("Pedestrian orientation follows its first waypoint and cannot be rotated manually.")
            return
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            self.rotating_vehicle = True
            self.rotation_start_mouse_y = mouse_y
            current_transform = self.selected_vehicle.get_transform()
            self.rotation_start_yaw = current_transform.rotation.yaw
            print(f"Started rotating vehicle from yaw: {self.rotation_start_yaw:.1f}°")
    
    def update_vehicle_rotation(self, mouse_y):
        """Update vehicle rotation based on mouse movement"""
        if not (self.rotating_vehicle and self.selected_vehicle and self.selected_vehicle.is_alive):
            return
        
        # Calculate rotation based on mouse Y movement
        mouse_delta = mouse_y - self.rotation_start_mouse_y
        rotation_sensitivity = 0.5  # Degrees per pixel
        rotation_delta = mouse_delta * rotation_sensitivity
        
        # Calculate new yaw
        new_yaw = self.rotation_start_yaw + rotation_delta
        
        # Normalize yaw to 0-360 range
        while new_yaw < 0:
            new_yaw += 360
        while new_yaw >= 360:
            new_yaw -= 360
        
        # Create new transform for collision checking
        current_transform = self.selected_vehicle.get_transform()
        new_transform = carla.Transform(
            current_transform.location,
            carla.Rotation(pitch=current_transform.rotation.pitch, 
                          yaw=new_yaw, 
                          roll=current_transform.rotation.roll)
        )
        
        # Check for collision before applying rotation
        if not self.check_vehicle_collision(self.selected_vehicle, new_transform):
            # No collision, apply the rotation
            self.selected_vehicle.set_transform(new_transform)
        # If collision detected, don't rotate the vehicle
    
    def stop_vehicle_rotation(self):
        """Stop rotating the vehicle"""
        if self.rotating_vehicle:
            old_transform = None
            if hasattr(self, 'rotation_start_yaw') and self.rotation_start_yaw is not None:
                # Create original transform for undo
                current_transform = self.selected_vehicle.get_transform()
                old_rotation = carla.Rotation(
                    current_transform.rotation.pitch,
                    self.rotation_start_yaw,
                    current_transform.rotation.roll
                )
                old_transform = carla.Transform(current_transform.location, old_rotation)
            
            self.rotating_vehicle = False
            if self.selected_vehicle and self.selected_vehicle.is_alive:
                final_transform = self.selected_vehicle.get_transform()
                
                # Create rotation command if vehicle was actually rotated
                if (old_transform and 
                    abs(old_transform.rotation.yaw - final_transform.rotation.yaw) > 1.0):  # Only if rotated more than 1 degree
                    
                    command = MoveVehicleCommand(
                        self,
                        self.selected_vehicle,
                        old_transform,
                        final_transform
                    )
                    self.editor.execute_command(command)
                
                print(f"Finished rotating vehicle to yaw: {final_transform.rotation.yaw:.1f}°")
            
            # Reset rotation tracking
            self.rotation_start_yaw = None
    
    def start_waypoint_creation(self, reset_existing=True):
        """Start waypoint creation mode for the selected vehicle."""
        # Default behavior hides info panel when creation stops unless we're extending an existing path
        self.preserve_info_panel_on_waypoint_cancel = False
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            vehicle_id = self.selected_vehicle.id
            existing_waypoints = list(self.get_vehicle_waypoints(vehicle_id))

            if reset_existing and existing_waypoints:
                print(f"Clearing {len(existing_waypoints)} existing waypoints for actor {vehicle_id}")

            if reset_existing:
                # Reset waypoint data so the next placement starts a fresh path
                self.set_vehicle_waypoints(vehicle_id, [])
                self.clear_vehicle_destination_speed(vehicle_id)
                self.selected_waypoint_vehicle_id = None
                self.selected_waypoint_index = None
            else:
                # We're extending an existing path; preserve info panel after cancel
                if existing_waypoints:
                    self.preserve_info_panel_on_waypoint_cancel = True
                # Keep current waypoints and prepare to extend from the last one
                if existing_waypoints:
                    self.selected_waypoint_vehicle_id = vehicle_id
                    self.selected_waypoint_index = len(existing_waypoints) - 1
                else:
                    self.selected_waypoint_vehicle_id = None
                    self.selected_waypoint_index = None

            self.moving_waypoint = False
            self.waypoint_original_height = None
            self.waypoint_drag_armed = False
            self.pending_waypoint_click_action = None
            self.creating_destination = False

            # Hide info panel if it was showing details for the previous path
            if self.editor and hasattr(self.editor, 'info_panel'):
                self.editor.info_panel.hide()

            self.creating_waypoint = True
            self.waypoint_vehicle = self.selected_vehicle
            
            # Set waypoint display to show this vehicle's waypoints during creation
            self.waypoint_display_vehicle_id = vehicle_id
            
            # Clear menu position to hide the menu, but keep selected_vehicle for reference
            self.vehicle_menu_position = None

            # Ensure overlays stop rendering the old path immediately
            self.refresh_waypoints_carla_debug()

            location = self.waypoint_vehicle.get_location()
            if reset_existing:
                print(f"Started waypoint creation for vehicle at ({location.x:.2f}, {location.y:.2f})")
            else:
                print(f"Waypoint extension mode for vehicle at ({location.x:.2f}, {location.y:.2f})")
            print("Move mouse to desired waypoint location and click to place waypoint. ESC or right-click to cancel.")
        else:
            print("ERROR: No valid vehicle selected for waypoint creation")
    
    def stop_waypoint_creation(self, *, clear_waypoints=False):
        """Stop waypoint creation mode."""
        if not self.creating_waypoint:
            return

        vehicle_id = getattr(self.waypoint_vehicle, "id", None)
        waypoint_count = len(self.get_vehicle_waypoints(vehicle_id)) if vehicle_id else 0

        if clear_waypoints and vehicle_id is not None:
            if waypoint_count > 0:
                print(f"Clearing {waypoint_count} waypoint(s) for actor {vehicle_id}")
            self.clear_vehicle_waypoints(vehicle_id)
            self.clear_vehicle_destination_speed(vehicle_id)
            self.selected_waypoint_vehicle_id = None
            self.selected_waypoint_index = None
            waypoint_count = 0
            self.refresh_waypoints_carla_debug()

        self.creating_waypoint = False

        if clear_waypoints:
            print("Waypoint creation cancelled; new waypoints discarded.")
        else:
            print(f"Stopped waypoint creation. Vehicle has {waypoint_count} waypoints.")
            if waypoint_count > 0 and vehicle_id is not None:
                waypoints = self.get_vehicle_waypoints(vehicle_id)
                print("Waypoint path:")
                for i, wp in enumerate(waypoints):
                    print(f"  {i+1}: ({wp['x']:.2f}, {wp['y']:.2f}, {wp['z']:.2f})")

        # Clear all selection states to return to normal mode, but keep waypoint display
        waypoint_vehicle_id = vehicle_id  # Store before clearing
        preserve_panel = self.preserve_info_panel_on_waypoint_cancel
        self.waypoint_vehicle = None
        self.clear_vehicle_selection(
            keep_waypoints=True,
            hide_info_panel=not preserve_panel
        )
        self.waypoint_drag_armed = False
        # Reset preservation flag after applying it once
        self.preserve_info_panel_on_waypoint_cancel = False

        # Keep waypoint display active for the vehicle that just had waypoints created
        self.waypoint_display_vehicle_id = waypoint_vehicle_id

        print("Returned to normal editor mode")
    
    def place_waypoint_at_click(self, screen_x, screen_y):
        """Place a waypoint at the clicked location"""
        if not (self.creating_waypoint and self.waypoint_vehicle and self.waypoint_vehicle.is_alive):
            return
        
        # Get world coordinates at click position with lane snapping support
        keys = pygame.key.get_pressed()
        snap_to_lane = not is_shift_pressed(keys)  # Inverted: snap by default, shift for free movement

        if self.waypoint_vehicle and self.waypoint_vehicle.type_id.startswith('walker.'):
            snap_to_lane = False

        _t0 = time.perf_counter()
        world_coords = self.coordinate_detector.screen_to_world_coordinates(
            screen_x, screen_y, self.screen_width, self.screen_height
        )
        _t1 = time.perf_counter()
        print(f"[TIMING] screen_to_world_coordinates: {(_t1-_t0)*1000:.1f}ms")

        if not world_coords['success']:
            print("Failed to determine world coordinates for waypoint")
            return
        
        # Apply lane snapping if requested
        if snap_to_lane:
            _t2 = time.perf_counter()
            lane_result = self.coordinate_detector.find_closest_lane_point(
                world_coords['x'], world_coords['y'], world_coords['z']
            )
            _t3 = time.perf_counter()
            print(f"[TIMING] find_closest_lane_point: {(_t3-_t2)*1000:.1f}ms")
            if lane_result['success']:
                world_coords = lane_result
                world_coords['snapped'] = True
                print(f"Snapped waypoint to lane - Road ID: {lane_result['road_id']}, Lane ID: {lane_result['lane_id']}")
            else:
                print("Could not snap waypoint to lane, using original position")
                world_coords['snapped'] = False
        else:
            world_coords['snapped'] = False
        
        # Create waypoint data - ensure ground level placement
        ground_z = world_coords['z']

        # If this is lane snapping, the Z might be elevated, so get actual ground height
        if world_coords.get('snapped', False):
            # For lane-snapped waypoints, ensure we're at ground level
            # Use probe_on_miss=False since we have good reference Z from OpenDRIVE - avoids expensive grid search
            _t4 = time.perf_counter()
            ground_result = self.get_ground_height_at_location(
                world_coords['x'],
                world_coords['y'],
                reference_z=world_coords.get('z'),
                return_metadata=True,
                probe_on_miss=False,
            )
            _t5 = time.perf_counter()
            print(f"[TIMING] get_ground_height_at_location: {(_t5-_t4)*1000:.1f}ms")
            # If raycast hit, use that height; otherwise fall back to OpenDRIVE Z
            if ground_result and ground_result.get('source') == 'raycast':
                ground_z = ground_result['height']
            # else: keep ground_z from OpenDRIVE (world_coords['z'])
        
        idle_time_default = 0.0
        turn_time_default = 0.0
        speed_default = 50
        if self.waypoint_vehicle:
            if self.waypoint_vehicle.type_id.startswith('walker.'):
                speed_default = 5
            speed_default = self.get_vehicle_speed(self.waypoint_vehicle.id, speed_default)

        waypoint = {
            'x': world_coords['x'],
            'y': world_coords['y'],
            'z': ground_z,  # Use actual ground level
            'index': len(self.get_vehicle_waypoints(self.waypoint_vehicle.id)) + 1,
            'snapped': world_coords.get('snapped', False),
            'yaw': world_coords.get('yaw', None),
            'speed_km_h': speed_default,
            'idle_time_s': idle_time_default,
            'turn_time_s': turn_time_default
        }
        
        # Create and execute command to place waypoint
        command = PlaceWaypointCommand(
            self, 
            self.waypoint_vehicle.id, 
            waypoint, 
            waypoint['index']
        )
        self.editor.execute_command(command)

        if self._is_pedestrian_actor(self.waypoint_vehicle.id):
            waypoints_for_actor = self.get_vehicle_waypoints(self.waypoint_vehicle.id)
            if len(waypoints_for_actor) == 1:
                self._adjust_pedestrian_spawn_orientation(self.waypoint_vehicle.id)

        waypoint_num = len(self.get_vehicle_waypoints(self.waypoint_vehicle.id))
        waypoint_type = "Snapped" if waypoint.get('snapped', False) else "Normal"
        print(f"Placed {waypoint_type} waypoint #{waypoint_num} at ({waypoint['x']:.2f}, {waypoint['y']:.2f}, {waypoint['z']:.2f})")

    def place_destination_at_click(self, screen_x, screen_y):
        """Place a destination at the clicked location and auto-route to it"""
        if not (self.creating_destination and self.selected_vehicle and self.selected_vehicle.is_alive):
            return

        # Get world coordinates at click position with lane snapping support
        keys = pygame.key.get_pressed()
        snap_to_lane = not is_shift_pressed(keys)  # Inverted: snap by default, shift for free movement

        world_coords = self.coordinate_detector.screen_to_world_coordinates(
            screen_x, screen_y, self.screen_width, self.screen_height
        )

        if not world_coords['success']:
            print("Failed to determine world coordinates for destination")
            return

        # Apply lane snapping if requested
        if snap_to_lane:
            lane_result = self.coordinate_detector.find_closest_lane_point(
                world_coords['x'], world_coords['y'], world_coords['z']
            )
            if lane_result['success']:
                world_coords = lane_result
                world_coords['snapped'] = True
                print(f"Snapped destination to lane - Road ID: {lane_result['road_id']}, Lane ID: {lane_result['lane_id']}")
            else:
                print("Could not snap destination to lane, using original position")
                world_coords['snapped'] = False
        else:
            world_coords['snapped'] = False

        # Get ground level for destination
        ground_z = world_coords['z']
        if world_coords.get('snapped', False):
            ground_height = self.get_ground_height_at_location(
                world_coords['x'],
                world_coords['y'],
                reference_z=world_coords.get('z'),
            )
            if ground_height is not None:
                ground_z = ground_height

        # Create destination data
        destination = {
            'x': world_coords['x'],
            'y': world_coords['y'],
            'z': ground_z,
            'snapped': world_coords.get('snapped', False),
            'yaw': world_coords.get('yaw', None)
        }

        # Clear existing waypoints for this vehicle
        self.set_vehicle_waypoints(self.selected_vehicle.id, [])
        self.clear_vehicle_destination_speed(self.selected_vehicle.id)

        # Auto-route to destination
        self.auto_route_to_destination(self.selected_vehicle, destination)

        # Exit destination mode
        self.creating_destination = False
        print(f"Created auto-route to destination at ({destination['x']:.2f}, {destination['y']:.2f}, {destination['z']:.2f})")

    def _create_auto_waypoint_data(self, location: "carla.Location", waypoint_index: int,
                                    yaw: float, speed_km_h: float) -> dict:
        """Create a waypoint data dictionary for auto-generated waypoints.

        Args:
            location: The CARLA location for the waypoint
            waypoint_index: The index to assign to this waypoint
            yaw: The yaw rotation at this waypoint
            speed_km_h: The target speed at this waypoint

        Returns:
            A dictionary containing the waypoint data
        """
        return {
            'x': location.x,
            'y': location.y,
            'z': location.z,
            'index': waypoint_index,
            'snapped': True,
            'yaw': yaw,
            'speed_km_h': speed_km_h,
            'turn_time_s': 0.0,
            'auto_generated': True
        }

    def auto_route_to_destination(self, vehicle, destination):
        """Automatically create a route from vehicle's current position to destination"""
        if not vehicle or not vehicle.is_alive:
            return

        # Get vehicle's current location
        vehicle_location = vehicle.get_location()
        start_point = {
            'x': vehicle_location.x,
            'y': vehicle_location.y,
            'z': vehicle_location.z
        }

        # Check if start point is on the road
        start_lane = self.coordinate_detector.find_closest_lane_point(
            start_point['x'], start_point['y'], start_point['z']
        )

        # Check if destination is on the road
        dest_lane = self.coordinate_detector.find_closest_lane_point(
            destination['x'], destination['y'], destination['z']
        )

        waypoints_to_add = []
        default_speed = self.get_vehicle_speed(vehicle.id, 50)

        # Determine routing strategy based on destination type
        if dest_lane['success']:
            # Case 1: Destination is on-road - route directly to it
            if self.world:
                try:
                    map_obj = self._get_cached_map(refresh=not getattr(self.editor, '_map_refresh_disabled', False))
                    if not map_obj:
                        print("Warning: Could not get map object, falling back to direct path")
                        raise Exception("No map object available")

                    # Get waypoints for start and destination
                    start_wp = map_obj.get_waypoint(vehicle_location, project_to_road=True)
                    dest_wp = map_obj.get_waypoint(
                        carla.Location(x=dest_lane['x'], y=dest_lane['y'], z=dest_lane['z'])
                    )

                    if start_wp and dest_wp:
                        # Generate route on roads
                        try:
                            current_wp = start_wp
                            target_location = dest_wp.transform.location

                            # Simple waypoint following
                            distance_threshold = 5.0  # meters between waypoints
                            min_distance_from_vehicle = 5.0  # minimum distance from vehicle to prevent extra markers
                            last_added_location = None
                            max_iterations = 200  # Prevent infinite loops

                            for iteration in range(max_iterations):
                                current_location = current_wp.transform.location
                                distance_to_target = current_location.distance(target_location)

                                # Check distance from vehicle starting position
                                vehicle_distance = current_location.distance(vehicle_location)

                                # Add waypoint if we've moved enough distance AND it's far enough from vehicle
                                if (last_added_location is None or current_location.distance(last_added_location) > distance_threshold) and vehicle_distance >= min_distance_from_vehicle:
                                    waypoint_data = self._create_auto_waypoint_data(
                                        current_location,
                                        len(waypoints_to_add) + 1,
                                        current_wp.transform.rotation.yaw,
                                        default_speed
                                    )
                                    waypoints_to_add.append(waypoint_data)
                                    last_added_location = current_location

                                # Check if we've reached the destination
                                if distance_to_target < 10.0:
                                    break

                                # Get next waypoint
                                next_waypoints = current_wp.next(5.0)  # Get next waypoint 5 meters ahead
                                if next_waypoints:
                                    # Choose the waypoint that gets us closer to target
                                    best_wp = min(next_waypoints,
                                                key=lambda w: w.transform.location.distance(target_location))
                                    current_wp = best_wp
                                else:
                                    break

                            print(f"Generated {len(waypoints_to_add)} waypoints using road following to on-road destination")

                        except Exception as e:
                            print(f"Error computing route: {e}")
                            waypoints_to_add = []

                except Exception as e:
                    print(f"Error in on-road routing: {e}")

        else:
            # Case 2: Destination is off-road - route to nearest road point then connect to actual destination
            if self.world:
                try:
                    map_obj = self._get_cached_map(refresh=not getattr(self.editor, '_map_refresh_disabled', False))
                    if not map_obj:
                        print("Warning: Could not get map object, falling back to direct path")
                        raise Exception("No map object available")

                    # Get closest road point to destination
                    closest_road_wp = map_obj.get_waypoint(
                        carla.Location(x=destination['x'], y=destination['y'], z=destination['z']),
                        project_to_road=True
                    )

                    if closest_road_wp:
                        # Route from vehicle to closest road point
                        start_wp = map_obj.get_waypoint(vehicle_location, project_to_road=True)

                        if start_wp:
                            # Generate route to road point near destination
                            try:
                                current_wp = start_wp
                                target_location = closest_road_wp.transform.location

                                # Simple waypoint following
                                distance_threshold = 5.0  # meters between waypoints
                                min_distance_from_vehicle = 5.0  # minimum distance from vehicle to prevent extra markers
                                last_added_location = None
                                max_iterations = 200

                                for iteration in range(max_iterations):
                                    current_location = current_wp.transform.location
                                    distance_to_target = current_location.distance(target_location)

                                    # Check distance from vehicle starting position
                                    vehicle_distance = current_location.distance(vehicle_location)

                                    # Add waypoint if we've moved enough distance AND it's far enough from vehicle
                                    if (last_added_location is None or current_location.distance(last_added_location) > distance_threshold) and vehicle_distance >= min_distance_from_vehicle:
                                        waypoint_data = self._create_auto_waypoint_data(
                                            current_location,
                                            len(waypoints_to_add) + 1,
                                            current_wp.transform.rotation.yaw,
                                            default_speed
                                        )
                                        waypoints_to_add.append(waypoint_data)
                                        last_added_location = current_location

                                    # Check if we've reached the closest road point
                                    if distance_to_target < 10.0:
                                        break

                                    # Get next waypoint
                                    next_waypoints = current_wp.next(5.0)
                                    if next_waypoints:
                                        best_wp = min(next_waypoints,
                                                    key=lambda w: w.transform.location.distance(target_location))
                                        current_wp = best_wp
                                    else:
                                        break

                                # Add connection waypoint at the road exit point if not already there
                                if waypoints_to_add:
                                    last_wp = waypoints_to_add[-1]
                                    road_exit_dist = ((last_wp['x'] - closest_road_wp.transform.location.x)**2 +
                                                     (last_wp['y'] - closest_road_wp.transform.location.y)**2)**0.5

                                    if road_exit_dist > 5.0:  # Only add if not too close to last waypoint
                                        road_exit_point = self._create_auto_waypoint_data(
                                            closest_road_wp.transform.location,
                                            len(waypoints_to_add) + 1,
                                            closest_road_wp.transform.rotation.yaw,
                                            default_speed
                                        )
                                        waypoints_to_add.append(road_exit_point)

                                print(f"Generated {len(waypoints_to_add)} waypoints to road exit point")

                            except Exception as e:
                                print(f"Error computing route to road exit: {e}")

                except Exception as e:
                    print(f"Error in off-road routing: {e}")

        # If we couldn't generate a road route, create a direct path
        if not waypoints_to_add:
            # Don't add vehicle position as waypoint - vehicle itself is the start marker
            # Add intermediate points if needed (for long distances)
            distance = ((destination['x'] - start_point['x'])**2 +
                       (destination['y'] - start_point['y'])**2)**0.5

            if distance > 50:  # If distance is more than 50 meters, add intermediate points
                num_intermediate = int(distance / 10)  # One point every 10 meters
                for i in range(1, num_intermediate):
                    t = i / (num_intermediate + 1)
                    intermediate = {
                        'x': start_point['x'] + t * (destination['x'] - start_point['x']),
                        'y': start_point['y'] + t * (destination['y'] - start_point['y']),
                        'z': start_point['z'] + t * (destination['z'] - start_point['z']),
                        'index': len(waypoints_to_add) + 1,
                        'snapped': False,
                        'speed_km_h': default_speed,
                        'turn_time_s': 0.0,
                        'auto_generated': True
                    }
                    waypoints_to_add.append(intermediate)

        # Ensure we have at least one approach waypoint with movement before the final stop
        if not waypoints_to_add:
            vector_x = destination['x'] - start_point['x']
            vector_y = destination['y'] - start_point['y']
            vector_z = destination['z'] - start_point['z']
            direct_distance = math.sqrt(vector_x ** 2 + vector_y ** 2 + vector_z ** 2)

            if direct_distance > 1.0:  # Only add approach if destination isn't essentially the spawn point
                dir_x = vector_x / direct_distance
                dir_y = vector_y / direct_distance
                dir_z = vector_z / direct_distance

                # Place the approach point most of the way to the destination but keep at least 1m gap
                approach_distance = max(min(direct_distance - 1.0, 20.0), direct_distance * 0.5)

                approach_point = {
                    'x': start_point['x'] + dir_x * approach_distance,
                    'y': start_point['y'] + dir_y * approach_distance,
                    'z': start_point['z'] + dir_z * approach_distance,
                    'index': 1,
                    'snapped': dest_lane['success'],
                    'yaw': destination.get('yaw', None),
                    'speed_km_h': max(default_speed, 10),
                    'turn_time_s': 0.0,
                    'auto_generated': True,
                    'is_destination': False
                }
                waypoints_to_add.append(approach_point)

        # Always add the final destination at the ACTUAL clicked location (not snapped)
        final_waypoint = {
            'x': destination['x'],  # Use actual destination coordinates
            'y': destination['y'],
            'z': destination['z'],
            'index': len(waypoints_to_add) + 1,
            'snapped': False,  # Mark as off-road since it's the actual clicked point
            'yaw': destination.get('yaw', None),
            'speed_km_h': 0,  # Stop at destination
            'turn_time_s': 0.0,
            'auto_generated': True,
            'is_destination': True
        }
        waypoints_to_add.append(final_waypoint)

        # Add all waypoints to the vehicle as a single undoable operation
        waypoint_commands = []
        for waypoint in waypoints_to_add:
            command = PlaceWaypointCommand(
                self,
                vehicle.id,
                waypoint,
                waypoint['index']
            )
            waypoint_commands.append(command)

        # Execute as composite command (single undo entry)
        composite = CompositeCommand(
            waypoint_commands,
            f"Auto-route {len(waypoints_to_add)} waypoints"
        )
        self.editor.execute_command(composite)

        print(f"Auto-generated {len(waypoints_to_add)} waypoints for route to destination")

    # Old debug marker waypoint functions removed - now using overlay rendering only

    def delete_selected_vehicle(self):
        """Delete the currently selected vehicle"""
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            print(f"Deleting vehicle at ({self.selected_vehicle.get_location().x:.2f}, {self.selected_vehicle.get_location().y:.2f})")
            
            # Get vehicle data for undo command
            vehicle_transform = self.selected_vehicle.get_transform()
            vehicle_type = self.selected_vehicle.type_id
            waypoints = copy.deepcopy(self.get_vehicle_waypoints(self.selected_vehicle.id))
            vehicle_speed = self.get_vehicle_speed(self.selected_vehicle.id, 50)
            
            # Create and execute delete vehicle command
            command = DeleteVehicleCommand(
                self, 
                self.selected_vehicle, 
                vehicle_type, 
                vehicle_transform, 
                waypoints, 
                vehicle_speed
            )
            self.editor.execute_command(command)
            
            # Clear selection
            self.clear_vehicle_selection()

    ############################################################
    # Trigger Zone Management
    ############################################################

    def start_trigger_placement(self):
        """Enter trigger placement mode"""
        self.placing_trigger = True
        print("Trigger placement mode activated. Click on the map to place a trigger zone.")

    def stop_trigger_placement(self):
        """Exit trigger placement mode"""
        self.placing_trigger = False
        print("Trigger placement mode cancelled.")

    def start_personal_trigger_placement(self, kind: str, *, actor=None, group=None) -> bool:
        """Enter placement mode for a personal trigger tied to an actor or group."""
        if kind not in ('vehicle', 'pedestrian', 'traffic_light'):
            return False

        if kind in ('vehicle', 'pedestrian'):
            if not actor or not actor.is_alive:
                print("Cannot start personal trigger placement: actor is unavailable.")
                return False
            if kind == 'vehicle' and self.is_ego_vehicle(actor.id):
                print("Ego vehicles do not support personal triggers.")
                return False
            self.pending_personal_trigger = {
                'kind': kind,
                'actor_id': actor.id,
                'actor_ref': weakref.ref(actor),
            }
            actor_label = "pedestrian" if kind == 'pedestrian' else "vehicle"
            print(f"{actor_label.title()} trigger placement mode activated. Left-click on the map to place the trigger.")
        elif kind == 'traffic_light':
            if not group:
                print("Cannot start personal trigger placement: traffic light group missing.")
                return False
            self.pending_personal_trigger = {
                'kind': 'traffic_light',
                'group': group,
            }
            ids = sorted(group.ids) if getattr(group, 'ids', None) else []
            print(f"Traffic-light trigger placement mode activated for IDs {ids}. Left-click to place the trigger.")

        self.personal_trigger_preview_radius = DEFAULT_PERSONAL_TRIGGER_RADIUS
        # Cancel global trigger placement to avoid conflicts
        if self.placing_trigger:
            self.stop_trigger_placement()
        return True

    def cancel_personal_trigger_placement(self) -> None:
        """Abort any pending personal trigger placement."""
        if self.pending_personal_trigger:
            kind = self.pending_personal_trigger.get('kind', 'unknown')
            print(f"Personal trigger placement cancelled ({kind})")
        self.pending_personal_trigger = None

    def place_trigger_at_click(self, screen_x, screen_y):
        """Place a new trigger zone at the clicked location"""
        if not self.placing_trigger:
            return

        # Convert screen coordinates to world coordinates
        world_coords = self.coordinate_detector.screen_to_world_coordinates(
            screen_x, screen_y, self.screen_width, self.screen_height
        )

        if not world_coords['success']:
            print("Failed to determine world coordinates for trigger placement")
            return

        # Get ground height
        ground_z = get_ground_height(
            self.world,
            carla.Location(world_coords['x'], world_coords['y'], world_coords['z']),
            cached_map=self.cached_map,
        )

        # Create new trigger with default radius
        trigger = {
            'x': world_coords['x'],
            'y': world_coords['y'],
            'z': ground_z,
            'radius': 2.5  # Default 2.5 meter radius
        }

        old_trigger = copy.deepcopy(self.triggers[0]) if self.triggers else None
        command = SetGlobalTriggerCommand(
            self,
            old_trigger,
            trigger,
            preserve_selection=False,
            description="Place trigger",
        )
        if getattr(self, "editor", None):
            self.editor.execute_command(command)
        else:
            command.execute()

        print(f"Placed trigger at ({trigger['x']:.2f}, {trigger['y']:.2f}, {trigger['z']:.2f}) with radius {trigger['radius']:.2f}m")

        # Exit placement mode after placing one trigger
        self.placing_trigger = False

    def place_trigger_instantly(self, screen_x, screen_y):
        """Place a trigger immediately, toggling placement mode on temporarily if needed."""
        was_active = self.placing_trigger
        if not was_active:
            self.start_trigger_placement()
        try:
            self.place_trigger_at_click(screen_x, screen_y)
        finally:
            if not was_active and self.placing_trigger:
                # If placement wasn't completed (e.g., coordinate failure), restore original state.
                self.stop_trigger_placement()

    def place_personal_trigger_at_click(self, screen_x: int, screen_y: int) -> bool:
        """Place or reposition a personal trigger at the clicked location."""
        pending = self.pending_personal_trigger
        if not pending:
            return False

        world_coords = self.coordinate_detector.screen_to_world_coordinates(
            screen_x, screen_y, self.screen_width, self.screen_height
        )
        if not world_coords['success']:
            print("Failed to determine world coordinates for personal trigger placement.")
            return False

        ground_z = get_ground_height(
            self.world,
            carla.Location(world_coords['x'], world_coords['y'], world_coords['z']),
            cached_map=self.cached_map,
        )

        center = {
            'x': float(world_coords['x']),
            'y': float(world_coords['y']),
            'z': float(ground_z),
        }
        radius = DEFAULT_PERSONAL_TRIGGER_RADIUS

        kind = pending.get('kind')
        selection = None
        old_center = None
        old_radius = None
        if kind == 'pedestrian':
            actor_id = pending.get('actor_id')
            if actor_id is None:
                print("Pending pedestrian trigger is missing an actor identifier.")
                return False
            selection = {'kind': 'pedestrian', 'id': actor_id}
            old_center, old_radius = self._get_personal_trigger_payload(selection)
        elif kind == 'vehicle':
            actor_id = pending.get('actor_id')
            if actor_id is None:
                print("Pending vehicle trigger is missing an actor identifier.")
                return False
            selection = {'kind': 'vehicle', 'id': actor_id}
            old_center, old_radius = self._get_personal_trigger_payload(selection)
        elif kind == 'traffic_light':
            group = pending.get('group')
            if not group:
                print("Pending traffic-light trigger is missing its group reference.")
                return False
            selection = {
                'kind': 'traffic_light',
                'group': group,
                'key': self._traffic_light_trigger_key(group=group),
            }
            old_center, old_radius = self._get_personal_trigger_payload(selection)
        else:
            print("Unsupported personal trigger kind.")
            return False

        command = SetPersonalTriggerCommand(
            self,
            selection,
            center,
            radius,
            old_center=copy.deepcopy(old_center) if old_center else None,
            old_radius=old_radius,
        )
        if getattr(self, "editor", None):
            success = self.editor.execute_command(command)
        else:
            success = command.execute()
        if success is False:
            print("Failed to place personal trigger.")
            return False

        selection = command.selection or selection

        if kind == 'pedestrian':
            actor_id = pending.get('actor_id')
            print(f"Placed pedestrian trigger for ID {actor_id} at ({center['x']:.2f}, {center['y']:.2f}) radius {radius:.2f} m")
            panel = getattr(getattr(self, "editor", None), "info_panel", None)
            if panel and panel.object_type == 'pedestrian' and panel.visible:
                current = getattr(panel, 'selected_object', None)
                if current and getattr(current, 'id', None) == actor_id:
                    panel.show(current, 'pedestrian', self.screen_width, self.screen_height)
        elif kind == 'vehicle':
            actor_id = pending.get('actor_id')
            print(f"Placed vehicle trigger for ID {actor_id} at ({center['x']:.2f}, {center['y']:.2f}) radius {radius:.2f} m")
            panel = getattr(getattr(self, "editor", None), "info_panel", None)
            if panel and panel.object_type == 'vehicle' and panel.visible:
                current = getattr(panel, 'selected_object', None)
                if current and getattr(current, 'id', None) == actor_id:
                    panel.show(current, 'vehicle', self.screen_width, self.screen_height)
        elif kind == 'traffic_light':
            group = pending.get('group')
            key = selection.get('key')
            self._cache_traffic_light_sequence(group)
            ids = sorted(group.ids) if getattr(group, 'ids', None) else []
            print(f"Placed traffic light trigger for IDs {ids} at ({center['x']:.2f}, {center['y']:.2f}) radius {radius:.2f} m")
            panel = getattr(getattr(self, "editor", None), "info_panel", None)
            if panel and panel.object_type == 'traffic_light' and panel.visible:
                panel.show(group, 'traffic_light', self.screen_width, self.screen_height)

        if selection:
            self.select_personal_trigger(selection)
            self.update_personal_trigger_menu_position(force=True)
        self.cancel_personal_trigger_placement()
        return True

    def handle_trigger_click(self, screen_x, screen_y):
        """Handle mouse click on triggers"""
        mouse_pos = (screen_x, screen_y)

        if self.selected_personal_trigger:
            self.clear_personal_trigger_selection()

        # First check if clicking on action menu icons
        if self.selected_trigger_index is not None and self.trigger_action_menu_position:
            action = self.check_trigger_menu_icon_click(screen_x, screen_y)
            if action:
                # Keep trigger interactions exclusive with vehicle menus
                if self.selected_vehicle or self.vehicle_menu_position:
                    self.clear_vehicle_selection()
                if action == 'delete':
                    self.delete_selected_trigger()
                elif action == 'move':
                    self.start_trigger_movement(mouse_pos)
                elif action == 'scale':
                    self.start_trigger_scaling(mouse_pos)
                return True

        # Check if clicking on a trigger
        for idx, trigger in enumerate(self.triggers):
            # Convert trigger world position to screen position
            screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                trigger['x'], trigger['y'], trigger['z']
            )

            if not screen_pos['success']:
                continue

            trigger_screen_x = int(screen_pos['x'])
            trigger_screen_y = int(screen_pos['y'])

            # Calculate distance from mouse to trigger center
            distance = math.sqrt(
                (screen_x - trigger_screen_x) ** 2 +
                (screen_y - trigger_screen_y) ** 2
            )

            # Calculate screen-space radius (approximate)
            # Use a simple scaling based on camera height
            camera_height = self.camera_controller.height if self.camera_controller else 100
            screen_radius = trigger['radius'] * (500 / camera_height)  # Rough approximation

            if distance <= screen_radius + 5:  # +5 for easier clicking
                # Select this trigger
                if self.selected_vehicle or self.vehicle_menu_position:
                    self.clear_vehicle_selection()
                self.selected_trigger_index = idx
                self.trigger_action_menu_position = (trigger_screen_x, trigger_screen_y)
                self.trigger_menu_hidden_for_camera_pan = False
                print(f"Selected trigger {idx} at ({trigger['x']:.2f}, {trigger['y']:.2f}, {trigger['z']:.2f})")
                return True

        return False

    def check_trigger_menu_icon_click(self, mouse_x, mouse_y):
        """Check if a click hits any of the trigger menu icons"""
        if not (self.selected_trigger_index is not None and self.trigger_action_menu_position):
            return None

        return OverlayMenuRenderer.hit_test(
            self.trigger_action_menu_position,
            ['delete', 'move', 'scale'],
            (self.screen_width, self.screen_height),
            (mouse_x, mouse_y),
        )

    def start_trigger_movement(self, mouse_pos):
        """Start moving the selected trigger"""
        if self.selected_trigger_index is None:
            return

        self.moving_trigger = True
        self.trigger_movement_start_pos = mouse_pos
        trigger = self.triggers[self.selected_trigger_index]
        self.trigger_movement_start_coords = {
            'x': trigger['x'],
            'y': trigger['y'],
            'z': trigger['z']
        }
        self.trigger_original_height = trigger['z']  # Store original Z height
        self._trigger_move_start_snapshot = copy.deepcopy(trigger)
        print(f"Started moving trigger {self.selected_trigger_index}")

    def stop_trigger_movement(self):
        """Stop moving the trigger"""
        if not self.moving_trigger:
            return

        self.moving_trigger = False
        if self.selected_trigger_index is not None:
            trigger = self.triggers[self.selected_trigger_index]
            ground_z = get_ground_height(
                self.world,
                carla.Location(trigger['x'], trigger['y'], trigger['z']),
                cached_map=self.cached_map,
            )
            trigger['z'] = ground_z
            print(f"Stopped moving trigger {self.selected_trigger_index}, adjusted Z to {ground_z:.2f}")

            start_snapshot = self._trigger_move_start_snapshot
            self._trigger_move_start_snapshot = None
            moved = True
            if start_snapshot:
                moved = (
                    abs(start_snapshot.get('x', 0.0) - trigger['x']) > 1e-4
                    or abs(start_snapshot.get('y', 0.0) - trigger['y']) > 1e-4
                    or abs(start_snapshot.get('z', 0.0) - trigger['z']) > 1e-4
                )
            if moved:
                command = SetGlobalTriggerCommand(
                    self,
                    start_snapshot,
                    trigger,
                    preserve_selection=True,
                    description="Move trigger",
                )
                if getattr(self, "editor", None):
                    self.editor.execute_command(command)
                else:
                    command.execute()

    def update_trigger_movement(self, mouse_pos):
        """Update trigger position during movement"""
        if not self.moving_trigger or self.selected_trigger_index is None:
            return

        # Use fast coordinate conversion without raycast (like waypoints)
        world_coords = self.coordinate_detector.screen_to_world_coordinates_no_raycast(
            mouse_pos[0], mouse_pos[1], self.screen_width, self.screen_height, self.trigger_original_height
        )

        if not world_coords or not world_coords.get('success', False):
            return

        # Update trigger position (X and Y from mouse, keep original Z)
        trigger = self.triggers[self.selected_trigger_index]
        trigger['x'] = world_coords['x']
        trigger['y'] = world_coords['y']
        trigger['z'] = self.trigger_original_height

        # Update menu position
        screen_pos = self.coordinate_detector.world_to_screen_coordinates(
            trigger['x'], trigger['y'], trigger['z']
        )
        if screen_pos['success']:
            self.trigger_action_menu_position = (int(screen_pos['x']), int(screen_pos['y']))

    def start_trigger_scaling(self, mouse_pos):
        """Start scaling the selected trigger"""
        if self.selected_trigger_index is None:
            return

        self.scaling_trigger = True
        self.trigger_scale_start_pos = mouse_pos
        trigger = self.triggers[self.selected_trigger_index]
        self.trigger_scale_start_radius = trigger['radius']
        self._trigger_scale_start_snapshot = copy.deepcopy(trigger)
        print(f"Started scaling trigger {self.selected_trigger_index}")

    def stop_trigger_scaling(self):
        """Stop scaling the trigger"""
        if not self.scaling_trigger:
            return

        self.scaling_trigger = False
        if self.selected_trigger_index is not None and self.selected_trigger_index < len(self.triggers):
            trigger = self.triggers[self.selected_trigger_index]
            print(f"Stopped scaling trigger {self.selected_trigger_index}")
            start_snapshot = self._trigger_scale_start_snapshot
            self._trigger_scale_start_snapshot = None
            changed = True
            if start_snapshot:
                changed = abs(start_snapshot.get('radius', 0.0) - trigger.get('radius', 0.0)) > 1e-4
            if changed:
                command = SetGlobalTriggerCommand(
                    self,
                    start_snapshot,
                    trigger,
                    preserve_selection=True,
                    description="Scale trigger",
                )
                if getattr(self, "editor", None):
                    self.editor.execute_command(command)
                else:
                    command.execute()

    def update_trigger_scaling(self, mouse_pos):
        """Update trigger radius during scaling"""
        if not self.scaling_trigger or self.selected_trigger_index is None:
            return

        # Calculate vertical mouse movement
        delta_y = self.trigger_scale_start_pos[1] - mouse_pos[1]  # Up is positive

        # Scale radius based on vertical movement (1 pixel = 0.1 meter)
        new_radius = self.trigger_scale_start_radius + (delta_y * 0.1)

        # Clamp radius to reasonable values (minimum 2.5m, maximum 100m)
        new_radius = max(2.5, min(new_radius, 100.0))

        # Update trigger radius
        trigger = self.triggers[self.selected_trigger_index]
        trigger['radius'] = new_radius

    def delete_selected_trigger(self):
        """Delete the currently selected trigger"""
        if self.selected_trigger_index is None:
            print("No trigger selected for deletion")
            return

        deleted_trigger = copy.deepcopy(self.triggers[self.selected_trigger_index])
        command = SetGlobalTriggerCommand(
            self,
            deleted_trigger,
            None,
            preserve_selection=False,
            description="Delete trigger",
        )
        if getattr(self, "editor", None):
            self.editor.execute_command(command)
        else:
            command.execute()

        print(f"Deleted trigger at ({deleted_trigger['x']:.2f}, {deleted_trigger['y']:.2f}, {deleted_trigger['z']:.2f})")

    def render_trigger_placement_overlay(self, screen):
        """Delegate trigger placement overlay to helper."""
        TriggerOverlayRenderer.render_trigger_placement_overlay(self, screen)

    def render_triggers_overlay(self, screen):
        """Delegate trigger debug overlay to helper."""
        TriggerOverlayRenderer.render_triggers(self, screen)

    def render_trigger_action_menu(self, screen):
        """Render the action menu for selected trigger"""
        if self.editor and self.editor.scenario_running:
            return

        if self.selected_personal_trigger:
            return

        if self.trigger_menu_hidden_for_camera_pan:
            return

        if self.selected_trigger_index is None or not self.trigger_action_menu_position:
            return

        icon_order = ['delete', 'move', 'scale']
        tooltip_mgr = getattr(self.editor, 'tooltip_manager', None) if self.editor else None
        OverlayMenuRenderer.draw_menu(
            screen,
            self.trigger_action_menu_position,
            icon_order,
            (self.screen_width, self.screen_height),
            tooltip_manager=tooltip_mgr,
        )

    ############################################################
    # Personal Trigger Interaction (Vehicles, Pedestrians, Lights)
    ############################################################

    def _get_personal_trigger_payload(self, selection):
        """Return (center_dict, radius) for the provided personal trigger selection."""
        if not selection:
            return None, None
        kind = selection.get('kind')
        if kind == 'pedestrian':
            actor_id = selection.get('id')
            return (
                self.pedestrian_trigger_centers.get(actor_id),
                self.pedestrian_trigger_radii.get(actor_id),
            )
        if kind == 'vehicle':
            actor_id = selection.get('id')
            return (
                self.vehicle_trigger_centers.get(actor_id),
                self.vehicle_trigger_radii.get(actor_id),
            )
        if kind == 'traffic_light':
            group = selection.get('group')
            key = selection.get('key')
            center, radius, resolved_key = self._get_traffic_light_trigger_data(key=key, group=group)
            if resolved_key and (key != resolved_key):
                selection['key'] = resolved_key
            if not group and resolved_key:
                selection['group'] = self._find_traffic_light_group_by_key(resolved_key)
            return center, radius
        return None, None

    def _personal_trigger_hit_radius(self, trigger_radius: float) -> float:
        """Return the hover/click radius (screen space) for personal triggers."""
        base = max(14.0, min(64.0, float(trigger_radius) * 8.0))
        return base * 2.0

    def _is_personal_trigger_hovered(self, selection, mouse_pos) -> bool:
        """Determine whether the mouse cursor is hovering over a personal trigger marker."""
        if not selection or not mouse_pos:
            return False
        center, radius = self._get_personal_trigger_payload(selection)
        if not center or radius is None:
            return False
        screen_pos = self.coordinate_detector.world_to_screen_coordinates(
            center['x'], center['y'], center['z']
        )
        if not screen_pos.get('success'):
            return False
        hit_radius = self._personal_trigger_hit_radius(radius)
        distance = math.hypot(mouse_pos[0] - screen_pos['x'], mouse_pos[1] - screen_pos['y'])
        return distance <= hit_radius

    def _ensure_traffic_light_trigger_context(
        self,
        selection,
        *,
        auto_select: bool = True,
    ) -> Optional[TrafficLightGroupData]:
        """Resolve the traffic-light group for a trigger selection and ensure it is active."""
        if not selection or selection.get('kind') != 'traffic_light':
            return None

        group = selection.get('group')
        key = selection.get('key')
        if not group and key:
            group = self._find_traffic_light_group_by_key(key)
            if group:
                selection['group'] = group

        if not group:
            return None

        if auto_select:
            current_group = self.selected_traffic_light_group
            if current_group is not group:
                if not self.select_traffic_light_group(group):
                    return None
        return group

    def select_personal_trigger(self, selection):
        """Select a personal trigger and update its menu anchor."""
        if not selection:
            self.clear_personal_trigger_selection()
            return
        if selection.get('kind') == 'traffic_light':
            group = self._ensure_traffic_light_trigger_context(selection, auto_select=True)
            if not group:
                print("Select the traffic light group before editing its trigger.")
                return
            key = selection.get('key')
            if not key:
                key = self._traffic_light_trigger_key(group=group)
                if key:
                    selection['key'] = key
            self._last_visible_traffic_light_trigger_key = selection.get(
                'key', self._last_visible_traffic_light_trigger_key
            )
        self.selected_personal_trigger = selection
        self.personal_trigger_menu_position = None
        self.personal_trigger_menu_hidden_for_camera_pan = False
        # Hide other action menus to keep UI exclusive
        self.vehicle_menu_position = None
        self.trigger_action_menu_position = None
        self.traffic_light_menu_position = None
        self.selected_trigger_index = None
        self.update_personal_trigger_menu_position(force=True)

    def clear_personal_trigger_selection(self):
        """Clear any selected personal trigger."""
        self.selected_personal_trigger = None
        self.personal_trigger_menu_position = None
        self.personal_trigger_menu_hidden_for_camera_pan = False
        self._last_visible_traffic_light_trigger_key = None
        if self.moving_personal_trigger:
            self.stop_personal_trigger_movement()
        if self.scaling_pedestrian_trigger:
            self.stop_pedestrian_trigger_scaling()
        if self.scaling_vehicle_trigger:
            self.stop_vehicle_trigger_scaling()

    def update_personal_trigger_menu_position(self, force: bool = False) -> None:
        """Update floating menu anchor for the selected personal trigger."""
        selection = self.selected_personal_trigger
        if not selection:
            self.personal_trigger_menu_position = None
            return

        if not force:
            current_time = time.time()
            if self.camera_is_moving and (current_time - self.camera_movement_timer < self.menu_update_delay):
                return

        center, _ = self._get_personal_trigger_payload(selection)
        if not center:
            self.clear_personal_trigger_selection()
            return

        screen_pos = self.coordinate_detector.world_to_screen_coordinates(
            center['x'], center['y'], center['z']
        )
        if screen_pos['success']:
            self.personal_trigger_menu_position = (int(screen_pos['x']), int(screen_pos['y']))
            self.personal_trigger_menu_hidden_for_camera_pan = False
        else:
            self.personal_trigger_menu_position = None

    def handle_personal_trigger_click(self, screen_x: int, screen_y: int) -> bool:
        """Handle clicks on personal triggers and their menus."""
        if (self.selected_personal_trigger and self.personal_trigger_menu_position
                and not self.personal_trigger_menu_hidden_for_camera_pan):
            action = OverlayMenuRenderer.hit_test(
                self.personal_trigger_menu_position,
                ['delete', 'move', 'scale'],
                (self.screen_width, self.screen_height),
                (screen_x, screen_y),
            )
            if action:
                if action == 'delete':
                    self.delete_selected_personal_trigger()
                elif action == 'move':
                    self.start_personal_trigger_movement((screen_x, screen_y))
                elif action == 'scale':
                    self.start_selected_personal_trigger_scaling((screen_x, screen_y))
                return True

        hit_selection = self._hit_test_personal_trigger(screen_x, screen_y)
        if hit_selection:
            self.select_personal_trigger(hit_selection)
            return True
        return False

    def _hit_test_personal_trigger(self, screen_x: int, screen_y: int):
        """Return the selection descriptor for a personal trigger under the cursor."""
        candidates = []
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            actor_id = self.selected_vehicle.id
            if self.selected_vehicle_is_pedestrian and actor_id in self.pedestrian_trigger_radii:
                candidates.append({'kind': 'pedestrian', 'id': actor_id})
            elif (not self.selected_vehicle_is_pedestrian and not self.is_ego_vehicle(actor_id)
                    and actor_id in self.vehicle_trigger_radii):
                candidates.append({'kind': 'vehicle', 'id': actor_id})

        if self.traffic_lights_visible:
            allowed_groups = []
            if self.selected_traffic_light_group:
                allowed_groups.append(self.selected_traffic_light_group)
            scaling_group = getattr(self, "_traffic_light_scaling_group", None)
            if scaling_group and scaling_group not in allowed_groups:
                allowed_groups.append(scaling_group)

            for group in allowed_groups:
                center, radius, key = self._get_traffic_light_trigger_data(group=group)
                if center and radius is not None:
                    candidates.append({'kind': 'traffic_light', 'group': group, 'key': key})

        for selection in candidates:
            center, radius = self._get_personal_trigger_payload(selection)
            if not center or radius is None:
                continue
            screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                center['x'], center['y'], center['z']
            )
            if not screen_pos['success']:
                continue
            distance = math.sqrt(
                (screen_x - screen_pos['x']) ** 2 +
                (screen_y - screen_pos['y']) ** 2
            )
            hit_radius = self._personal_trigger_hit_radius(radius)
            if distance <= hit_radius:
                return selection
        return None

    def start_personal_trigger_movement(self, mouse_pos):
        """Begin drag-move for the currently selected personal trigger."""
        selection = self.selected_personal_trigger
        if not selection:
            return
        center, _ = self._get_personal_trigger_payload(selection)
        if not center:
            return

        self.moving_personal_trigger = True
        self._personal_trigger_move_target = dict(selection)
        self.personal_trigger_movement_start_pos = mouse_pos
        self.personal_trigger_original_height = center.get('z', 0.0)
        self._personal_trigger_move_start_center = dict(center)
        self._personal_trigger_move_cache = {}
        print("Started moving personal trigger")

    def update_personal_trigger_movement(self, mouse_pos):
        """Update personal trigger position while moving."""
        if not self.moving_personal_trigger or not self._personal_trigger_move_target:
            return

        selection = self._personal_trigger_move_target
        cache = self._personal_trigger_move_cache
        coords = self.coordinate_detector.screen_to_world_coordinates_no_raycast(
            mouse_pos[0],
            mouse_pos[1],
            self.screen_width,
            self.screen_height,
            self.personal_trigger_original_height,
            cache=cache,
        )
        if (not coords) or (not coords.get('success', False)):
            coords = self.coordinate_detector.screen_to_world_coordinates(
                mouse_pos[0],
                mouse_pos[1],
                self.screen_width,
                self.screen_height,
            )
        if not coords or not coords.get('success', False):
            return

        center = {
            'x': float(coords['x']),
            'y': float(coords['y']),
            'z': float(self.personal_trigger_original_height),
        }
        _, current_radius = self._get_personal_trigger_payload(selection)
        if selection.get('kind') == 'pedestrian':
            actor_id = selection.get('id')
            if actor_id in self.pedestrian_trigger_centers:
                self.pedestrian_trigger_centers[actor_id] = center
        elif selection.get('kind') == 'vehicle':
            actor_id = selection.get('id')
            if actor_id in self.vehicle_trigger_centers:
                self.vehicle_trigger_centers[actor_id] = center
        elif selection.get('kind') == 'traffic_light':
            group = selection.get('group')
            key = selection.get('key')
            resolved_key = self._set_traffic_light_trigger_data(
                center,
                current_radius if current_radius is not None else DEFAULT_PERSONAL_TRIGGER_RADIUS,
                key=key,
                group=group,
            )
            if resolved_key and resolved_key != key:
                selection['key'] = resolved_key
            if group:
                self._cache_traffic_light_sequence(group)
        self.update_personal_trigger_menu_position(force=True)

    def stop_personal_trigger_movement(self):
        """Finish personal trigger movement."""
        if not self.moving_personal_trigger:
            return

        selection = self._personal_trigger_move_target or self.selected_personal_trigger

        self.moving_personal_trigger = False
        self._personal_trigger_move_target = None
        self.personal_trigger_original_height = None
        self._personal_trigger_move_cache = None
        adjusted_height = None
        final_center = None
        radius_value = None

        if selection:
            center, radius = self._get_personal_trigger_payload(selection)
            radius_value = radius
            if center:
                location = carla.Location(
                    float(center.get('x', 0.0)),
                    float(center.get('y', 0.0)),
                    float(center.get('z', 0.0)),
                )
                ground_z = get_ground_height(
                    self.world,
                    location,
                    cached_map=self.cached_map,
                )
                adjusted_height = float(ground_z)
                updated_center = {
                    'x': float(center.get('x', 0.0)),
                    'y': float(center.get('y', 0.0)),
                    'z': adjusted_height,
                }
                final_center = dict(updated_center)
                kind = selection.get('kind')
                if kind == 'pedestrian':
                    actor_id = selection.get('id')
                    if actor_id in self.pedestrian_trigger_centers:
                        self.pedestrian_trigger_centers[actor_id] = updated_center
                elif kind == 'vehicle':
                    actor_id = selection.get('id')
                    if actor_id in self.vehicle_trigger_centers:
                        self.vehicle_trigger_centers[actor_id] = updated_center
                elif kind == 'traffic_light':
                    group = selection.get('group')
                    key = selection.get('key')
                    resolved_key = self._set_traffic_light_trigger_data(
                        updated_center,
                        radius if radius is not None else DEFAULT_PERSONAL_TRIGGER_RADIUS,
                        key=key,
                        group=group,
                    )
                    if resolved_key and resolved_key != key:
                        selection['key'] = resolved_key
                self.update_personal_trigger_menu_position(force=True)

        start_center = self._personal_trigger_move_start_center
        if (self.editor and selection and start_center and final_center):
            delta = (
                abs(start_center.get('x', 0.0) - final_center.get('x', 0.0)) +
                abs(start_center.get('y', 0.0) - final_center.get('y', 0.0)) +
                abs(start_center.get('z', 0.0) - final_center.get('z', 0.0))
            )
            if delta > 0.01:
                command = MovePersonalTriggerCommand(
                    self,
                    dict(selection),
                    dict(start_center),
                    dict(final_center),
                    radius_value,
                )
                self.editor.execute_command(command)
        self._personal_trigger_move_start_center = None

        if adjusted_height is not None:
            print(f"Stopped moving personal trigger, adjusted Z to {adjusted_height:.2f}")
        else:
            print("Stopped moving personal trigger")

    def start_selected_personal_trigger_scaling(self, mouse_pos):
        """Route scaling request for the selected personal trigger."""
        selection = self.selected_personal_trigger
        if not selection:
            return
        kind = selection.get('kind')
        if kind == 'pedestrian':
            actor_id = selection.get('id')
            if actor_id is not None:
                self.start_pedestrian_trigger_scaling(actor_id, mouse_pos)
        elif kind == 'vehicle':
            actor_id = selection.get('id')
            if actor_id is not None:
                self.start_vehicle_trigger_scaling(actor_id, mouse_pos)
        elif kind == 'traffic_light':
            group = self._ensure_traffic_light_trigger_context(selection, auto_select=True)
            if group:
                self.start_traffic_light_trigger_scaling(mouse_pos)

    def delete_selected_personal_trigger(self):
        """Delete the currently selected personal trigger."""
        selection = self.selected_personal_trigger
        if not selection:
            return
        kind = selection.get('kind')
        if kind == 'pedestrian':
            actor_id = selection.get('id')
            if actor_id is not None:
                self.delete_pedestrian_trigger(actor_id)
        elif kind == 'vehicle':
            actor_id = selection.get('id')
            if actor_id is not None:
                self.delete_vehicle_trigger(actor_id)
        elif kind == 'traffic_light':
            key = selection.get('key')
            group = self._ensure_traffic_light_trigger_context(selection, auto_select=True)
            if group:
                self.delete_traffic_light_trigger(group)
            elif key:
                print("Traffic light group missing; removing saved trigger data.")
                self._delete_traffic_light_trigger_data(key=key)
        self.clear_personal_trigger_selection()

    def render_personal_trigger_action_menu(self, screen):
        """Render contextual menu for selected personal trigger."""
        if (self.editor and self.editor.scenario_running) or not self.selected_personal_trigger:
            return
        if self.personal_trigger_menu_hidden_for_camera_pan:
            return
        if not self.personal_trigger_menu_position:
            return
        if (self.selected_personal_trigger.get('kind') == 'traffic_light'
                and not self.traffic_lights_visible):
            return

        tooltip_mgr = getattr(self.editor, 'tooltip_manager', None) if self.editor else None
        OverlayMenuRenderer.draw_menu(
            screen,
            self.personal_trigger_menu_position,
            ['delete', 'move', 'scale'],
            (self.screen_width, self.screen_height),
            tooltip_manager=tooltip_mgr,
        )

    def render_personal_trigger_links(self, screen):
        """Draw persistent link lines between actors/groups and their personal triggers."""
        if not screen:
            return

        link_entries: Dict[Tuple[str, object], Dict[str, object]] = {}

        def add_actor_link(kind: str, actor_id: Optional[int], actor_obj: Optional[carla.Actor]):
            if actor_id is None:
                return
            key = (kind, actor_id)
            if key in link_entries:
                return
            if kind == 'pedestrian':
                center = self.pedestrian_trigger_centers.get(actor_id)
            else:
                center = self.vehicle_trigger_centers.get(actor_id)
            if not center:
                return
            if not actor_obj or not actor_obj.is_alive:
                actor_obj = self.get_spawned_vehicle(actor_id)
            if not actor_obj or not actor_obj.is_alive:
                return
            link_entries[key] = {
                'anchor_type': 'actor',
                'actor': actor_obj,
                'center': center,
            }

        def add_group_link(group: Optional[TrafficLightGroupData], key: Optional[Tuple[str, Tuple]] = None):
            resolved_key = key or self._traffic_light_trigger_key(group=group)
            if not resolved_key:
                return
            center, _, final_key = self._get_traffic_light_trigger_data(key=resolved_key, group=group)
            if not center:
                return
            group_ref = group or self._find_traffic_light_group_by_key(final_key)
            if not group_ref:
                return
            entry_key = ('traffic_light', final_key)
            if entry_key in link_entries:
                return
            link_entries[entry_key] = {
                'anchor_type': 'traffic_light',
                'group': group_ref,
                'key': final_key,
                'center': center,
            }

        # Actor selections
        if self.selected_vehicle and self.selected_vehicle.is_alive:
            if self.selected_vehicle_is_pedestrian:
                actor_id = self.selected_vehicle.id
                if actor_id in self.pedestrian_trigger_centers:
                    add_actor_link('pedestrian', actor_id, self.selected_vehicle)
            else:
                actor_id = self.selected_vehicle.id
                if (not self.is_ego_vehicle(actor_id)
                        and actor_id in self.vehicle_trigger_centers):
                    add_actor_link('vehicle', actor_id, self.selected_vehicle)

        # Personal trigger selection
        selection = self.selected_personal_trigger
        if selection:
            kind = selection.get('kind')
            if kind in ('pedestrian', 'vehicle'):
                actor_id = selection.get('id')
                add_actor_link(kind, actor_id, self.get_spawned_vehicle(actor_id))
            elif kind == 'traffic_light':
                add_group_link(selection.get('group'), selection.get('key'))

        # Traffic light group selection
        if self.selected_traffic_light_group:
            add_group_link(self.selected_traffic_light_group)

        color = (0, 140, 255)
        for entry in link_entries.values():
            if self.actor_overlays_hidden_for_camera_pan and entry.get('anchor_type') == 'actor':
                continue
            center = entry.get('center')
            if not center:
                continue
            if (self.traffic_light_overlays_hidden_for_camera_pan
                    and entry.get('anchor_type') == 'traffic_light'):
                continue
            center_screen = self.coordinate_detector.world_to_screen_coordinates(
                center['x'], center['y'], center['z']
            )
            if not center_screen.get('success'):
                continue
            target_pos = (int(center_screen['x']), int(center_screen['y']))

            anchor_pos = None
            if entry.get('anchor_type') == 'actor':
                actor = entry.get('actor')
                if actor and actor.is_alive:
                    location = actor.get_location()
                    anchor_result = self.coordinate_detector.world_to_screen_coordinates(
                        location.x, location.y, location.z + 2.0
                    )
                    if anchor_result.get('success'):
                        anchor_pos = (int(anchor_result['x']), int(anchor_result['y']))
            elif entry.get('anchor_type') == 'traffic_light':
                group = entry.get('group')
                key = entry.get('key')
                if not group and key:
                    group = self._find_traffic_light_group_by_key(key)
                anchor = self._get_traffic_light_group_menu_anchor(group) if group else None
                if not anchor and group and group.center_location:
                    loc = group.center_location
                    anchor_result = self.coordinate_detector.world_to_screen_coordinates(
                        loc.x, loc.y, loc.z
                    )
                    if anchor_result.get('success'):
                        anchor = (anchor_result['x'], anchor_result['y'])
                if anchor:
                    anchor_pos = (int(anchor[0]), int(anchor[1]))

            if anchor_pos:
                pygame.draw.line(screen, color, anchor_pos, target_pos, 2)

    ############################################################
    # Scenario Persistence
    ############################################################

    def get_vehicle_waypoints(self, vehicle_id):
        """Return the waypoint list for a vehicle (empty list if not present)."""
        return self.waypoint_list.get(vehicle_id, [])

    def set_vehicle_waypoints(self, vehicle_id, waypoints):
        """Assign a waypoint list for a vehicle."""
        self.waypoint_list[vehicle_id] = waypoints

    def clear_vehicle_waypoints(self, vehicle_id):
        """Remove stored waypoints for a vehicle."""
        if vehicle_id in self.waypoint_list:
            del self.waypoint_list[vehicle_id]

    def get_vehicle_speed(self, vehicle_id, default=50):
        if self.is_ego_vehicle(vehicle_id) and default == 50:
            default = 40
        return self.vehicle_speeds.get(vehicle_id, default)

    def set_vehicle_speed(self, vehicle_id, value):
        self.vehicle_speeds[vehicle_id] = value

    def clear_vehicle_speed(self, vehicle_id):
        self.vehicle_speeds.pop(vehicle_id, None)

    def get_vehicle_destination_speed(self, vehicle_id):
        return self.vehicle_destination_speeds.get(vehicle_id)

    def set_vehicle_destination_speed(self, vehicle_id, value):
        if value is None:
            self.vehicle_destination_speeds.pop(vehicle_id, None)
        else:
            self.vehicle_destination_speeds[vehicle_id] = value

    def clear_vehicle_destination_speed(self, vehicle_id):
        self.vehicle_destination_speeds.pop(vehicle_id, None)

    def get_vehicle_max_lat_acc(self, vehicle_id, default=3.0):
        return self.vehicle_max_lat_acc.get(vehicle_id, default)

    def set_vehicle_max_lat_acc(self, vehicle_id, value):
        if value is None:
            self.vehicle_max_lat_acc.pop(vehicle_id, None)
        else:
            self.vehicle_max_lat_acc[vehicle_id] = value

    def clear_vehicle_max_lat_acc(self, vehicle_id):
        self.vehicle_max_lat_acc.pop(vehicle_id, None)

    def get_actor_idle_time(self, actor_id, default=0.0):
        return self.actor_idle_times.get(actor_id, default)

    def set_actor_idle_time(self, actor_id, value):
        self.actor_idle_times[actor_id] = value

    def clear_actor_idle_time(self, actor_id):
        self.actor_idle_times.pop(actor_id, None)

    def get_actor_turn_time(self, actor_id, default=0.0):
        return self.actor_turn_times.get(actor_id, default)

    def set_actor_turn_time(self, actor_id, value):
        self.actor_turn_times[actor_id] = value

    def clear_actor_turn_time(self, actor_id):
        self.actor_turn_times.pop(actor_id, None)

    def get_vehicle_color(self, vehicle_id):
        return self.vehicle_colors.get(vehicle_id)

    def set_vehicle_color(self, vehicle_id, color):
        if color is None:
            self.vehicle_colors.pop(vehicle_id, None)
        else:
            self.vehicle_colors[vehicle_id] = color

    def clear_vehicle_color(self, vehicle_id):
        self.vehicle_colors.pop(vehicle_id, None)

    def get_vehicle_ignore_flags(self, vehicle_id) -> VehicleIgnoreFlags:
        raw = {
            'traffic_lights': self.vehicle_ignore_traffic_lights.get(vehicle_id, False),
            'stop_signs': self.vehicle_ignore_stop_signs.get(vehicle_id, False),
            'vehicles': self.vehicle_ignore_vehicles.get(vehicle_id, False),
        }
        return ensure_ignore_flags(raw)

    def set_vehicle_ignore_flags(self, vehicle_id, flags):
        normalized = ensure_ignore_flags(flags)
        self.vehicle_ignore_traffic_lights[vehicle_id] = normalized['traffic_lights']
        self.vehicle_ignore_stop_signs[vehicle_id] = normalized['stop_signs']
        self.vehicle_ignore_vehicles[vehicle_id] = normalized['vehicles']

    def clear_vehicle_ignore_flags(self, vehicle_id):
        self.vehicle_ignore_traffic_lights.pop(vehicle_id, None)
        self.vehicle_ignore_stop_signs.pop(vehicle_id, None)
        self.vehicle_ignore_vehicles.pop(vehicle_id, None)

    def _ensure_waypoint_container(self, vehicle_id):
        waypoints = self.waypoint_list.get(vehicle_id)
        if waypoints is None:
            waypoints = []
            self.waypoint_list[vehicle_id] = waypoints
        return waypoints

    def append_waypoint_data(self, vehicle_id, waypoint):
        waypoints = self._ensure_waypoint_container(vehicle_id)
        waypoint_copy = clone_waypoint_data(waypoint)
        waypoints.append(waypoint_copy)
        return waypoint_copy

    def insert_waypoint_data(self, vehicle_id, index, waypoint):
        waypoints = self._ensure_waypoint_container(vehicle_id)
        if index < 0 or index > len(waypoints):
            return None
        waypoint_copy = clone_waypoint_data(waypoint)
        waypoints.insert(index, waypoint_copy)
        # If we inserted at the front for a pedestrian, reorient to the new first waypoint
        if index == 0 and self._is_pedestrian_actor(vehicle_id):
            self._adjust_pedestrian_spawn_orientation(vehicle_id)
        return waypoint_copy

    def remove_waypoint_data(self, vehicle_id, index):
        waypoints = self.waypoint_list.get(vehicle_id)
        if not waypoints or index < 0 or index >= len(waypoints):
            return None
        removed = clone_waypoint_data(waypoints.pop(index))
        if not waypoints:
            self.clear_vehicle_waypoints(vehicle_id)
        else:
            # If the first waypoint changed (e.g., deleted index 0), reorient pedestrians
            if index == 0 and self._is_pedestrian_actor(vehicle_id):
                self._adjust_pedestrian_spawn_orientation(vehicle_id)
        return removed

    def update_waypoint_fields(self, vehicle_id, index, updates: Dict[str, Union[float, bool, str, None]]):
        waypoints = self.waypoint_list.get(vehicle_id)
        if not waypoints or index < 0 or index >= len(waypoints):
            return None
        waypoint = waypoints[index]
        previous = clone_waypoint_data(waypoint)
        waypoint.update(updates)
        return previous

    def get_spawned_vehicle(self, vehicle_id: Optional[int]):
        """Return the live CARLA actor for a tracked vehicle id (None if missing or dead)."""
        if vehicle_id is None:
            return None
        for actor in self.spawned_vehicles:
            if actor and actor.is_alive and actor.id == vehicle_id:
                return actor
        return None

    def assert_spawned_vehicle(self, vehicle_id: Optional[int], context: str = "") -> bool:
        """Log a warning (and return False) when a command targets a missing actor."""
        vehicle = self.get_spawned_vehicle(vehicle_id)
        if vehicle:
            return True
        if context:
            print(f"[WARN] {context}: vehicle {vehicle_id} no longer available.")
        else:
            print(f"[WARN] Vehicle {vehicle_id} no longer available.")
        return False

    def initialize_vehicle_metadata(
        self,
        vehicle_id,
        *,
        speed,
        destination_speed=None,
        idle_time=0.0,
        turn_time=0.0,
        color=None,
        ignore_flags=None,
        max_lat_acc=3.0,
    ):
        self.set_vehicle_speed(vehicle_id, speed)
        self.set_vehicle_destination_speed(vehicle_id, destination_speed)
        self.set_actor_idle_time(vehicle_id, idle_time)
        self.set_actor_turn_time(vehicle_id, turn_time)
        self.set_vehicle_color(vehicle_id, color)
        self.set_vehicle_ignore_flags(vehicle_id, ignore_flags or {})
        if max_lat_acc is None:
            max_lat_acc = 3.0
        self.set_vehicle_max_lat_acc(vehicle_id, max_lat_acc)

    def clear_vehicle_metadata(self, vehicle_id, *, clear_waypoints=False):
        self.clear_vehicle_speed(vehicle_id)
        self.clear_vehicle_destination_speed(vehicle_id)
        self.clear_actor_idle_time(vehicle_id)
        self.clear_actor_turn_time(vehicle_id)
        self.clear_vehicle_color(vehicle_id)
        self.clear_vehicle_ignore_flags(vehicle_id)
        self.clear_vehicle_max_lat_acc(vehicle_id)
        # Clear pedestrian trigger data
        self.pedestrian_trigger_centers.pop(vehicle_id, None)
        self.pedestrian_trigger_radii.pop(vehicle_id, None)
        # Clear vehicle trigger data
        self.vehicle_trigger_centers.pop(vehicle_id, None)
        self.vehicle_trigger_radii.pop(vehicle_id, None)
        if clear_waypoints:
            self.clear_vehicle_waypoints(vehicle_id)

    def clear_all_vehicle_metadata(self):
        """Clear all stored vehicle metadata collections."""
        self.waypoint_list.clear()
        self.vehicle_speeds.clear()
        self.vehicle_destination_speeds.clear()
        self.actor_idle_times.clear()
        self.actor_turn_times.clear()
        self.vehicle_colors.clear()
        self.vehicle_ignore_traffic_lights.clear()
        self.vehicle_ignore_stop_signs.clear()
        self.vehicle_ignore_vehicles.clear()
        self.vehicle_max_lat_acc.clear()
        # Clear pedestrian trigger data
        self.pedestrian_trigger_centers.clear()
        self.pedestrian_trigger_radii.clear()
        # Clear vehicle trigger data
        self.vehicle_trigger_centers.clear()
        self.vehicle_trigger_radii.clear()

    def _cleanup_leftover_ego_actor(self):
        """Destroy any ego-designated actor the editor no longer tracks."""
        if not self.world:
            return
        try:
            actors = self.world.get_actors().filter('vehicle.*')
        except RuntimeError:
            return

        tracked_ids = {actor.id for actor in self.spawned_vehicles if actor and actor.is_alive}
        roles = {'hero', 'ego', 'ego_vehicle', 'player'}
        preserved_id = None
        editor = getattr(self, 'editor', None)
        if editor:
            preserved_id = getattr(editor, 'external_ego_actor_id', None)

        for actor in actors:
            if actor.id in tracked_ids:
                continue
            role_name = actor.attributes.get('role_name', '').lower()
            if role_name in roles:
                if preserved_id and actor.id == preserved_id:
                    print(f"Preserving external ego actor {actor.id} (role '{role_name}') during cleanup.")
                    continue
                try:
                    print(f"Destroying leftover ego actor {actor.id} before reload")
                    actor.destroy()
                except Exception as exc:
                    print(f"Failed to destroy leftover ego actor {actor.id}: {exc}")
                break

    def is_manual_control_actor(self, actor_id: Optional[int]) -> bool:
        return (
            actor_id is not None
            and self.manual_control_actor is not None
            and self.manual_control_actor.id == actor_id
        )

    def _serialize_waypoints_for_vehicle(self, vehicle_id, *, start_location: Optional[carla.Transform] = None):
        """Return serialized waypoint payload and destination speed for a vehicle.

        start_location is ignored for serialization; waypoint list begins with the first user-placed waypoint.
        """
        waypoints = self.get_vehicle_waypoints(vehicle_id)
        if not waypoints:
            return [], self.get_vehicle_destination_speed(vehicle_id)

        serialized = []
        destination_speed = self.get_vehicle_destination_speed(vehicle_id)
        is_ego = self.is_ego_vehicle(vehicle_id)
        default_speed = 40 if is_ego else 50
        total_waypoints = len(waypoints)

        for index, waypoint in enumerate(waypoints):
            is_last = index == total_waypoints - 1
            waypoint_data = {
                'index': "destination" if is_last else index + 1,
                'location': {
                    'x': waypoint['x'],
                    'y': waypoint['y'],
                    'z': waypoint['z'],
                },
                'yaw': waypoint.get('yaw', None),
                'speed_km_h': waypoint.get('speed_km_h', default_speed),
                'speed_deviation_km_h': waypoint.get('speed_deviation_km_h', 0),
                'idle_time_s': waypoint.get('idle_time_s', 0.0),
                'turn_time_s': waypoint.get('turn_time_s', 0.0),
                'auto_generated': waypoint.get('auto_generated', False),
                'is_destination': is_last,
            }
            try:
                waypoint_data['speed_km_h'] = float(waypoint_data['speed_km_h'])
            except Exception:
                waypoint_data['speed_km_h'] = default_speed
            if waypoint_data['speed_km_h'] <= 0.0:
                waypoint_data['speed_km_h'] = default_speed
            try:
                deviation_value = int(float(waypoint_data.get('speed_deviation_km_h', 0) or 0))
            except Exception:
                deviation_value = 0
            if deviation_value < 0:
                deviation_value = 0
            waypoint_data['speed_deviation_km_h'] = deviation_value
            serialized.append(waypoint_data)
            if is_last:
                destination_speed = waypoint_data['speed_km_h']

        if destination_speed is None:
            destination_speed = default_speed
        return serialized, destination_speed

    def _build_vehicle_snapshot(self, vehicle):
        """Serialize a single actor for scenario saving."""
        if not vehicle or not vehicle.is_alive:
            return None, None

        transform = vehicle.get_transform()

        if self.is_ego_vehicle(vehicle.id):
            payload = {
                'type': vehicle.type_id,
                'location': {
                    'x': transform.location.x,
                    'y': transform.location.y,
                    'z': transform.location.z,
                },
                'rotation': {
                    'pitch': transform.rotation.pitch,
                    'yaw': transform.rotation.yaw,
                    'roll': transform.rotation.roll,
                },
                'role': 'ego_vehicle',
            }
            color = self.get_vehicle_color(vehicle.id)
            if color is not None:
                payload['color'] = color
            ignore_flags = self.get_vehicle_ignore_flags(vehicle.id)
            payload['ignore_traffic_lights'] = ignore_flags['traffic_lights']
            payload['ignore_stop_signs'] = ignore_flags['stop_signs']
            payload['ignore_vehicles'] = ignore_flags['vehicles']
            payload['max_lat_acc'] = float(self.get_vehicle_max_lat_acc(vehicle.id, 3.0))
            serialized_waypoints, destination_speed = self._serialize_waypoints_for_vehicle(
                vehicle.id,
                start_location=transform,
            )
            if serialized_waypoints:
                payload['waypoints'] = serialized_waypoints
            if destination_speed is not None:
                payload['destination_speed_km_h'] = destination_speed
            return None, payload

        vehicle_data = {
            'id': vehicle.id,
            'type': vehicle.type_id,
            'location': {
                'x': transform.location.x,
                'y': transform.location.y,
                'z': transform.location.z,
            },
            'rotation': {
                'pitch': transform.rotation.pitch,
                'yaw': transform.rotation.yaw,
                'roll': transform.rotation.roll,
            },
            'speed_km_h': self.get_vehicle_speed(vehicle.id, 50),
            'idle_time_s': self.get_actor_idle_time(vehicle.id, 0.0),
            'waypoints': [],
        }
        if vehicle.type_id.startswith('walker.'):
            vehicle_data['turn_time_s'] = self.get_actor_turn_time(vehicle.id, 0.0)

        color = self.get_vehicle_color(vehicle.id)
        if color is not None:
            vehicle_data['color'] = color

        ignore_flags = self.get_vehicle_ignore_flags(vehicle.id)
        vehicle_data['ignore_traffic_lights'] = ignore_flags['traffic_lights']
        vehicle_data['ignore_stop_signs'] = ignore_flags['stop_signs']
        vehicle_data['ignore_vehicles'] = ignore_flags['vehicles']
        if not vehicle.type_id.startswith('walker.'):
            vehicle_data['max_lat_acc'] = float(self.get_vehicle_max_lat_acc(vehicle.id, 3.0))

        serialized_waypoints, destination_speed = self._serialize_waypoints_for_vehicle(
            vehicle.id,
            start_location=transform if self.is_ego_vehicle(vehicle.id) else None,
        )
        if serialized_waypoints:
            vehicle_data['waypoints'] = serialized_waypoints
        if destination_speed is not None:
            vehicle_data['destination_speed_km_h'] = destination_speed

        trigger_center = None
        trigger_radius = None
        if vehicle.type_id.startswith('walker.'):
            trigger_center = self.pedestrian_trigger_centers.get(vehicle.id)
            trigger_radius = self.pedestrian_trigger_radii.get(vehicle.id)
        else:
            trigger_center = self.vehicle_trigger_centers.get(vehicle.id)
            trigger_radius = self.vehicle_trigger_radii.get(vehicle.id)

        if trigger_center and trigger_radius is not None:
            vehicle_data['trigger'] = {
                'center': {
                    'x': float(trigger_center['x']),
                    'y': float(trigger_center['y']),
                    'z': float(trigger_center['z']),
                },
                'radius': float(trigger_radius),
            }

        return vehicle_data, None

    def _serialize_trigger(self):
        """Return serialized trigger payload if present."""
        if not self.triggers:
            return None
        trigger = self.triggers[0]
        return {
            'location': {
                'x': trigger['x'],
                'y': trigger['y'],
                'z': trigger['z'],
            },
            'radius': trigger['radius'],
        }

    def _serialize_traffic_light_triggers(self) -> Optional[List[Dict[str, object]]]:
        """Return serialized traffic light trigger payloads based on the stable trigger store."""
        entries: List[Dict[str, object]] = []
        for key, center in self.traffic_light_trigger_centers.items():
            radius = self.traffic_light_trigger_radii.get(key)
            if not center or radius is None:
                continue

            payload: Dict[str, object] = {
                'center': {
                    'x': float(center.get('x', 0.0)),
                    'y': float(center.get('y', 0.0)),
                    'z': float(center.get('z', 0.0)),
                },
                'radius': float(radius),
            }

            group = self._find_traffic_light_group_by_key(key)
            if group:
                payload['ids_live'] = sorted(group.ids)
                payload['ids_reference'] = sorted(group.reference_ids or set(group.ids))
                if group.location_fingerprint is None:
                    group.location_fingerprint = self._compute_traffic_light_fingerprint(group.lights)
                if group.location_fingerprint:
                    payload['fingerprint'] = [
                        [int(pt[0]), int(pt[1]), int(pt[2])] for pt in group.location_fingerprint
                    ]
                seq = group.sequence
                if not seq:
                    seq = self.traffic_light_sequences.get(frozenset(group.ids), [])
                if seq:
                    payload['sequence'] = self._normalize_traffic_light_sequence(seq)
            else:
                # Persist fallback identifiers when no live group is available
                if key[0] == 'fp':
                    payload['fingerprint'] = [
                        [int(pt[0]), int(pt[1]), int(pt[2])] for pt in key[1]
                    ]
                elif key[0] == 'ids':
                    payload['ids_reference'] = list(key[1])

            entries.append(payload)

        return entries or None

    def _weather_dict_from_params(self, weather: "carla.WeatherParameters") -> Dict[str, float]:
        """Convert WeatherParameters to a plain dict for saving."""
        payload: Dict[str, float] = {}
        for spec in WEATHER_PARAMETER_SPECS:
            try:
                payload[spec.name] = float(getattr(weather, spec.name))
            except Exception:
                payload[spec.name] = spec.min_value
        return payload

    def _weather_params_from_dict(self, values: Dict[str, float]) -> "carla.WeatherParameters":
        """Convert a payload dict back into WeatherParameters."""
        weather = carla.WeatherParameters()
        for spec in WEATHER_PARAMETER_SPECS:
            if spec.name in values:
                try:
                    setattr(weather, spec.name, float(values[spec.name]))
                except Exception:
                    pass
        return weather

    def _collect_scenario_snapshot(self, map_name):
        """Create the scenario data payload for saving."""
        save_data = {
            'vehicles': [],
            'timestamp': time.time(),
            'map_name': map_name,
        }
        ego_entry = None

        for vehicle in self.spawned_vehicles:
            vehicle_data, maybe_ego = self._build_vehicle_snapshot(vehicle)
            if maybe_ego is not None:
                ego_entry = maybe_ego
                continue
            if vehicle_data is not None:
                save_data['vehicles'].append(vehicle_data)

        if ego_entry is None:
            ego_entry = self.get_ego_vehicle_data()
        if ego_entry:
            save_data['ego_vehicle'] = ego_entry

        for group in self.traffic_light_groups:
            self._cache_traffic_light_sequence(group)
        trigger_payload = self._serialize_trigger()
        if trigger_payload:
            save_data['trigger'] = trigger_payload

        traffic_light_payloads = self._serialize_traffic_light_triggers()
        if traffic_light_payloads:
            save_data['traffic_light_triggers'] = traffic_light_payloads

        return save_data, ego_entry

    def _sanitize_weather_keyframes(self, keyframes: Iterable[Dict[str, float]]) -> List[Dict[str, float]]:
        """Normalize weather keyframes for saving."""
        cleaned: List[Dict[str, float]] = []

        def _append(payload: Dict[str, float]) -> None:
            try:
                pct = float(payload.get("route_percentage", payload.get("route_percent", payload.get("pct", 0.0))))
            except Exception:
                return
            normalized: Dict[str, float] = {"route_percentage": max(0.0, min(100.0, pct))}
            for spec in WEATHER_PARAMETER_SPECS:
                val = payload.get(spec.name)
                if val is None and spec.name.lower() in payload:
                    val = payload.get(spec.name.lower())
                if val is None:
                    continue
                try:
                    normalized[spec.name] = float(val)
                except Exception:
                    normalized[spec.name] = spec.min_value
            cleaned.append(normalized)

        for frame in keyframes or []:
            if isinstance(frame, dict):
                _append(frame)

        if not cleaned:
            base = dict(self._weather_state)
            if not base:
                try:
                    base = self._weather_dict_from_params(self.world.get_weather())
                except Exception:
                    base = {}
            default_frame = {"route_percentage": 0.0, **base}
            cleaned = [
                default_frame,
                {**default_frame, "route_percentage": 100.0},
            ]

        # Sort and deduplicate by route percentage (last wins)
        cleaned = sorted(cleaned, key=lambda kf: float(kf.get("route_percentage", 0.0)))
        deduped: List[Dict[str, float]] = []
        for frame in cleaned:
            pct = float(frame.get("route_percentage", 0.0))
            if deduped and abs(deduped[-1].get("route_percentage", 0.0) - pct) < 1e-3:
                deduped[-1].update({k: v for k, v in frame.items() if k != "route_percentage"})
            else:
                deduped.append(frame)

        if deduped[0].get("route_percentage", 0.0) > 0.0:
            deduped.insert(0, {"route_percentage": 0.0, **deduped[0]})
        if deduped[-1].get("route_percentage", 0.0) < 100.0:
            deduped.append({"route_percentage": 100.0, **deduped[-1]})

        # Ensure each frame has all parameters so playback can interpolate reliably.
        for frame in deduped:
            for spec in WEATHER_PARAMETER_SPECS:
                if spec.name not in frame:
                    frame[spec.name] = float(self._weather_state.get(spec.name, spec.min_value))
        return deduped

    def _weather_keyframes_for_save(self) -> List[Dict[str, float]]:
        """Build weather keyframes payload for scenario save."""
        source_keyframes = None
        if getattr(self, "editor", None) is not None:
            source_keyframes = getattr(self.editor, "_weather_keyframes", None)
        if not isinstance(source_keyframes, list):
            source_keyframes = self._weather_keyframes
        return self._sanitize_weather_keyframes(source_keyframes)

    def save_waypoint_data_to_file(self, filename):
        """Save all waypoint data to a JSON file"""
        try:
            # Check if filename is valid
            if not filename or not filename.strip():
                print("Error: Empty filename provided for save operation")
                print("Call stack:")
                traceback.print_stack()
                return False

            # Get map name (strip path, keep only the map name)
            map_obj = self._get_cached_map(refresh=False)
            if map_obj:
                full_map_name = map_obj.name
                map_name = full_map_name.split('/')[-1] if '/' in full_map_name else full_map_name
            else:
                full_map_name = "unknown"
                map_name = "unknown"

            weather_keyframes = self._weather_keyframes_for_save()
            save_data, ego_entry = self._collect_scenario_snapshot(map_name)
            save_data['weather_keyframes'] = weather_keyframes

            # Ensure directory exists (only if there's a directory path)
            dirname = os.path.dirname(filename)
            if dirname:
                os.makedirs(dirname, exist_ok=True)
            
            # Write JSON to file
            with open(filename, 'w') as f:
                json.dump(save_data, f, indent=2)

            print(f"Saved waypoint data for {len(save_data['vehicles'])} vehicles to {filename}")
            if ego_entry:
                print("Included ego vehicle in scenario data")
            if 'trigger' in save_data:
                print(f"Saved trigger to scenario")
            if save_data.get('traffic_light_triggers'):
                print(
                    f"Saved {len(save_data['traffic_light_triggers'])} "
                    f"traffic light trigger(s) to scenario"
                )

            return True
            
        except Exception as e:
            print(f"Error saving waypoint data: {e}")
            return False
    
    def _reset_scenario_state(self):
        """Clear currently loaded scenario actors, waypoints, and triggers."""
        editor = getattr(self, 'editor', None)
        if editor is not None:
            editor.scene_preview_destroyed = False
        if editor:
            try:
                editor._detect_external_ego_vehicle()
                editor._refresh_external_ego_actor_reference()
            except Exception as exc:
                print(f"[Scenario] Warning: failed to probe external ego vehicle before reset ({exc})")
        self.cleanup_all_vehicles()
        self._cleanup_leftover_ego_actor()
        self.waypoint_list.clear()
        self.triggers.clear()
        self.traffic_light_trigger_centers.clear()
        self.traffic_light_trigger_radii.clear()
        self.traffic_light_sequences.clear()
        self._traffic_light_group_snapshots.clear()
        self._scenario_active_traffic_light_trigger = None
        self._last_visible_traffic_light_trigger_key = None
        self.scaling_traffic_light_trigger = False
        self._traffic_light_scaling_group = None
        self.traffic_light_menu_position = None
        for group in self.traffic_light_groups:
            group.trigger_center = None
            group.trigger_radius = None
            group.sequence = []
        self.clear_traffic_light_selection()

    def _load_vehicle_entry(self, vehicle_data, blueprint_library, ego_data, context):
        """Spawn and configure a single vehicle entry from loaded scenario data."""
        try:
            if vehicle_data.get('role') == 'ego':
                return

            if ego_data and vehicle_data.get('role') is None and vehicle_data.get('type') == ego_data.get('type'):
                loc = vehicle_data.get('location', {})
                ego_loc = ego_data.get('location', {})
                if loc.get('x') == ego_loc.get('x') and loc.get('y') == ego_loc.get('y'):
                    return

            vehicle_bp = blueprint_library.find(vehicle_data['type'])
            if 'color' in vehicle_data and not vehicle_data['type'].startswith('walker.'):
                if vehicle_bp.has_attribute('color'):
                    vehicle_bp.set_attribute('color', vehicle_data['color'])

            location = carla.Location(
                vehicle_data['location']['x'],
                vehicle_data['location']['y'],
                vehicle_data['location']['z'],
            )
            rotation = carla.Rotation(
                vehicle_data['rotation']['pitch'],
                vehicle_data['rotation']['yaw'],
                vehicle_data['rotation']['roll'],
            )
            transform = carla.Transform(location, rotation)

            if vehicle_data['type'].startswith('walker.'):
                if context['first_ped_json_location'] is None:
                    context['first_ped_json_location'] = carla.Location(location.x, location.y, location.z)
            else:
                if context['first_vehicle_json_location'] is None:
                    context['first_vehicle_json_location'] = carla.Location(location.x, location.y, location.z)

            vehicle = self.world.try_spawn_actor(vehicle_bp, transform)
            if not vehicle:
                print(f"Failed to spawn vehicle {vehicle_data['type']}")
                return

            vehicle.set_simulate_physics(False)
            self.spawned_vehicles.append(vehicle)

            default_speed = 5 if vehicle_data.get('type', '').startswith('walker.') else 50
            speed_value = vehicle_data.get('speed_km_h', default_speed)
            idle_value = vehicle_data.get('idle_time_s', 0.0)
            turn_value = vehicle_data.get('turn_time_s', 0.0)
            color = vehicle_data.get('color')
            ignore_flags = {
                'traffic_lights': vehicle_data.get('ignore_traffic_lights', False),
                'stop_signs': vehicle_data.get('ignore_stop_signs', False),
                'vehicles': vehicle_data.get('ignore_vehicles', False),
            }
            max_lat_acc_value = float(vehicle_data.get('max_lat_acc', 3.0))
            if max_lat_acc_value <= 0.0:
                max_lat_acc_value = 3.0

            print(f"Vehicle loaded at JSON Z: {location.z:.2f}")

            actual_location = vehicle.get_location()
            if vehicle_data['type'].startswith('walker.'):
                if context['first_ped_spawn_location'] is None:
                    context['first_ped_spawn_location'] = carla.Location(
                        actual_location.x, actual_location.y, actual_location.z
                    )
            else:
                if context['first_vehicle_spawn_location'] is None:
                    context['first_vehicle_spawn_location'] = carla.Location(
                        actual_location.x, actual_location.y, actual_location.z
                    )

            waypoints = []
            for wp_data in vehicle_data.get('waypoints', []):
                snapped_state = wp_data['snapped'] if 'snapped' in wp_data else True
                deviation_val = wp_data.get('speed_deviation_km_h', 0)
                try:
                    deviation_val = int(float(deviation_val or 0))
                except Exception:
                    deviation_val = 0
                if deviation_val < 0:
                    deviation_val = 0
                waypoints.append({
                    'x': wp_data['location']['x'],
                    'y': wp_data['location']['y'],
                    'z': wp_data['location']['z'],
                    'index': wp_data.get('index'),
                    'snapped': snapped_state,
                    'yaw': wp_data.get('yaw', None),
                    'speed_km_h': wp_data.get('speed_km_h', 50),
                    'speed_deviation_km_h': deviation_val,
                    'idle_time_s': wp_data.get('idle_time_s', 0.0),
                    'turn_time_s': wp_data.get('turn_time_s', 0.0),
                    'is_destination': wp_data.get('is_destination', False),
                })

            destination_speed_value = vehicle_data.get('destination_speed_km_h')
            self.initialize_vehicle_metadata(
                vehicle.id,
                speed=speed_value,
                destination_speed=destination_speed_value,
                idle_time=idle_value,
                turn_time=turn_value,
                color=color,
                ignore_flags=ignore_flags,
                max_lat_acc=max_lat_acc_value,
            )

            if waypoints:
                for idx, waypoint in enumerate(waypoints):
                    is_last = idx == len(waypoints) - 1
                    waypoint['index'] = "destination" if is_last else idx + 1
                    waypoint['is_destination'] = is_last
                    if is_last and destination_speed_value is not None:
                        waypoint['speed_km_h'] = destination_speed_value

                self.set_vehicle_waypoints(vehicle.id, waypoints)
                self._cache_destination_speed(vehicle.id)
                print(f"Loaded vehicle {vehicle_data['type']} with {len(waypoints)} waypoints")
            else:
                self.clear_vehicle_waypoints(vehicle.id)
                self.set_vehicle_destination_speed(vehicle.id, destination_speed_value)
                print(f"Loaded vehicle {vehicle_data['type']} with no waypoints")

            if 'trigger' in vehicle_data:
                trigger_data = vehicle_data['trigger']
                if 'center' in trigger_data and 'radius' in trigger_data:
                    center = trigger_data['center']
                    radius = float(trigger_data['radius'])
                    if vehicle_data['type'].startswith('walker.'):
                        self.pedestrian_trigger_centers[vehicle.id] = {
                            'x': float(center['x']),
                            'y': float(center['y']),
                            'z': float(center['z']),
                        }
                        self.pedestrian_trigger_radii[vehicle.id] = max(MIN_PERSONAL_TRIGGER_RADIUS, radius)
                        print(f"Loaded pedestrian trigger: radius {radius:.2f}m")
                    else:
                        if not self.is_ego_vehicle(vehicle.id):
                            self.vehicle_trigger_centers[vehicle.id] = {
                                'x': float(center['x']),
                                'y': float(center['y']),
                                'z': float(center['z']),
                            }
                            self.vehicle_trigger_radii[vehicle.id] = max(MIN_PERSONAL_TRIGGER_RADIUS, radius)
                            print(f"Loaded vehicle trigger: radius {radius:.2f}m")

        except Exception as exc:
            print(f"Error loading vehicle {vehicle_data.get('type', 'unknown')}: {exc}")

    def _apply_ego_data_to_actor(self, ego_data: dict, actor: carla.Actor) -> None:
        """Apply ego metadata and waypoints to an existing actor."""
        if not ego_data or not actor or not actor.is_alive:
            return

        ego_default_speed = 40.0
        try:
            ego_default_speed = float(ego_data.get('speed_km_h', ego_default_speed) or ego_default_speed)
        except Exception:
            ego_default_speed = 40.0
        try:
            destination_speed_value = float(ego_data.get('destination_speed_km_h')) if ego_data.get('destination_speed_km_h') is not None else None
        except Exception:
            destination_speed_value = None
        ignore_flags = {
            'traffic_lights': bool(ego_data.get('ignore_traffic_lights', False)),
            'stop_signs': bool(ego_data.get('ignore_stop_signs', False)),
            'vehicles': bool(ego_data.get('ignore_vehicles', False)),
        }
        try:
            max_lat_acc_value = float(ego_data.get('max_lat_acc', 3.0) or 3.0)
        except Exception:
            max_lat_acc_value = 3.0
        if max_lat_acc_value <= 0.0:
            max_lat_acc_value = 3.0
        ego_color = ego_data.get('color')

        self.initialize_vehicle_metadata(
            actor.id,
            speed=ego_default_speed,
            destination_speed=destination_speed_value,
            idle_time=0.0,
            turn_time=0.0,
            color=ego_color,
            ignore_flags=ignore_flags,
            max_lat_acc=max_lat_acc_value,
        )

        raw_waypoints = ego_data.get('waypoints', [])
        waypoints: List[WaypointData] = []
        if isinstance(raw_waypoints, list):
            total = len(raw_waypoints)
            for idx, wp_data in enumerate(raw_waypoints):
                snapped_state = wp_data['snapped'] if 'snapped' in wp_data else True
                waypoint_entry = {
                    'x': wp_data.get('location', {}).get('x', 0.0),
                    'y': wp_data.get('location', {}).get('y', 0.0),
                    'z': wp_data.get('location', {}).get('z', 0.0),
                    'index': wp_data.get('index'),
                    'snapped': snapped_state,
                    'yaw': wp_data.get('yaw', None),
                    'speed_km_h': wp_data.get('speed_km_h', ego_default_speed),
                    'idle_time_s': wp_data.get('idle_time_s', 0.0),
                    'turn_time_s': wp_data.get('turn_time_s', 0.0),
                    'is_destination': wp_data.get('is_destination', idx == total - 1),
                }
                deviation_val = wp_data.get('speed_deviation_km_h', 0)
                try:
                    deviation_val = int(float(deviation_val or 0))
                except Exception:
                    deviation_val = 0
                if deviation_val < 0:
                    deviation_val = 0
                waypoint_entry['speed_deviation_km_h'] = deviation_val
                try:
                    speed_val = float(waypoint_entry['speed_km_h'])
                except Exception:
                    speed_val = ego_default_speed
                if speed_val <= 0.0:
                    speed_val = ego_default_speed
                waypoint_entry['speed_km_h'] = speed_val
                if waypoint_entry['is_destination'] and destination_speed_value is not None:
                    waypoint_entry['speed_km_h'] = destination_speed_value
                waypoints.append(waypoint_entry)

        if waypoints:
            self.set_vehicle_waypoints(actor.id, waypoints)
            self._cache_destination_speed(actor.id)
        else:
            self.clear_vehicle_waypoints(actor.id)
            self.set_vehicle_destination_speed(actor.id, destination_speed_value)

    def _spawn_ego_from_data(self, ego_data, blueprint_library):
        """Spawn ego vehicle from loaded scenario data."""
        ego_spawn_location = None
        if not ego_data:
            return None

        try:
            destination_speed_value = float(ego_data.get('destination_speed_km_h')) if ego_data.get('destination_speed_km_h') is not None else None
        except Exception:
            destination_speed_value = None
        ego_default_speed = 40.0
        try:
            ego_default_speed = float(ego_data.get('speed_km_h', ego_default_speed) or ego_default_speed)
        except Exception:
            ego_default_speed = 40.0
        ignore_flags = {
            'traffic_lights': bool(ego_data.get('ignore_traffic_lights', False)),
            'stop_signs': bool(ego_data.get('ignore_stop_signs', False)),
            'vehicles': bool(ego_data.get('ignore_vehicles', False)),
        }
        try:
            max_lat_acc_value = float(ego_data.get('max_lat_acc', 3.0) or 3.0)
        except Exception:
            max_lat_acc_value = 3.0
        if max_lat_acc_value <= 0.0:
            max_lat_acc_value = 3.0
        ego_color = ego_data.get('color')

        def _apply_loaded_ego_waypoints(target_vehicle_id: Optional[int]) -> None:
            if target_vehicle_id is None:
                return
            raw_waypoints = ego_data.get('waypoints', [])
            waypoints: List[WaypointData] = []
            if isinstance(raw_waypoints, list):
                total = len(raw_waypoints)
                for idx, wp_data in enumerate(raw_waypoints):
                    snapped_state = wp_data['snapped'] if 'snapped' in wp_data else True
                    waypoint_entry = {
                        'x': wp_data.get('location', {}).get('x', 0.0),
                        'y': wp_data.get('location', {}).get('y', 0.0),
                        'z': wp_data.get('location', {}).get('z', 0.0),
                        'index': wp_data.get('index'),
                        'snapped': snapped_state,
                        'yaw': wp_data.get('yaw', None),
                        'speed_km_h': wp_data.get('speed_km_h', ego_default_speed),
                        'idle_time_s': wp_data.get('idle_time_s', 0.0),
                        'turn_time_s': wp_data.get('turn_time_s', 0.0),
                        'is_destination': wp_data.get('is_destination', idx == total - 1),
                    }
                    deviation_val = wp_data.get('speed_deviation_km_h', 0)
                    try:
                        deviation_val = int(float(deviation_val or 0))
                    except Exception:
                        deviation_val = 0
                    if deviation_val < 0:
                        deviation_val = 0
                    waypoint_entry['speed_deviation_km_h'] = deviation_val
                    try:
                        speed_val = float(waypoint_entry['speed_km_h'])
                    except Exception:
                        speed_val = ego_default_speed
                    if speed_val <= 0.0:
                        speed_val = ego_default_speed
                    waypoint_entry['speed_km_h'] = speed_val
                    waypoints.append(waypoint_entry)

            if waypoints:
                for idx, waypoint in enumerate(waypoints):
                    is_last = idx == len(waypoints) - 1
                    waypoint['index'] = "destination" if is_last else idx + 1
                    waypoint['is_destination'] = is_last
                    if is_last and destination_speed_value is not None:
                        waypoint['speed_km_h'] = destination_speed_value
                self.set_vehicle_waypoints(target_vehicle_id, waypoints)
                self._cache_destination_speed(target_vehicle_id)
                print(f"Loaded ego vehicle with {len(waypoints)} waypoints")
            elif destination_speed_value is not None:
                self.set_vehicle_destination_speed(target_vehicle_id, destination_speed_value)

        try:
            editor = getattr(self, 'editor', None)
            if editor:
                try:
                    editor._detect_external_ego_vehicle()
                    editor._refresh_external_ego_actor_reference()
                except Exception as exc:
                    print(f"[Scenario] Warning: failed to refresh external ego before spawn ({exc})")
            self._cleanup_leftover_ego_actor()

            # If an external ego is present and alive, reuse it as the ego actor instead of spawning a new one.
            external_actor = None
            external_id = None
            if editor:
                try:
                    external_id = getattr(editor, "external_ego_actor_id", None) or getattr(
                        editor, "_external_swap_current_id", None
                    )
                except Exception:
                    external_id = None
            if external_id:
                try:
                    external_actor = self.world.get_actor(external_id)
                except Exception:
                    external_actor = None
                if external_actor and external_actor.is_alive:
                    transform = carla.Transform(
                        carla.Location(
                            ego_data.get('location', {}).get('x', 0.0),
                            ego_data.get('location', {}).get('y', 0.0),
                            ego_data.get('location', {}).get('z', 0.0) + 0.2,
                        ),
                        carla.Rotation(
                            ego_data.get('rotation', {}).get('pitch', 0.0),
                            ego_data.get('rotation', {}).get('yaw', 0.0),
                            ego_data.get('rotation', {}).get('roll', 0.0),
                        ),
                    )
                    try:
                        external_actor.set_transform(transform)
                        external_actor.set_target_velocity(carla.Vector3D())
                        external_actor.set_target_angular_velocity(carla.Vector3D())
                        external_actor.set_simulate_physics(True)
                    except Exception:
                        pass
                    self.spawned_vehicles.append(external_actor)
                    self.initialize_vehicle_metadata(
                        external_actor.id,
                        speed=ego_default_speed,
                        destination_speed=destination_speed_value,
                        idle_time=float(ego_data.get('idle_time_s', 0.0) or 0.0),
                        turn_time=0.0,
                        color=ego_color,
                        ignore_flags=ignore_flags,
                        max_lat_acc=max_lat_acc_value,
                    )
                    self.register_ego_vehicle(external_actor, transform)
                    _apply_loaded_ego_waypoints(external_actor.id)
                    ego_spawn_location = external_actor.get_location()
                    return ego_spawn_location

            vehicle_bp = blueprint_library.find(ego_data.get('type', 'vehicle.lexus.utlexus'))
            loc_data = ego_data.get('location', {})
            rot_data = ego_data.get('rotation', {})
            base_location = carla.Location(
                loc_data.get('x', 0.0),
                loc_data.get('y', 0.0),
                loc_data.get('z', 0.0),
            )
            rotation = carla.Rotation(
                rot_data.get('pitch', 0.0),
                rot_data.get('yaw', 0.0),
                rot_data.get('roll', 0.0),
            )
            spawn_location = carla.Location(base_location.x, base_location.y, base_location.z + 0.1)
            transform = carla.Transform(spawn_location, rotation)

            ego_actor = self.world.try_spawn_actor(vehicle_bp, transform)
            if ego_actor:
                ego_actor.set_simulate_physics(False)
                self.spawned_vehicles.append(ego_actor)
                self.initialize_vehicle_metadata(
                    ego_actor.id,
                    speed=ego_default_speed,
                    destination_speed=destination_speed_value,
                    idle_time=float(ego_data.get('idle_time_s', 0.0) or 0.0),
                    turn_time=0.0,
                    color=ego_color,
                    ignore_flags=ignore_flags,
                    max_lat_acc=max_lat_acc_value,
                )
                self.register_ego_vehicle(ego_actor, transform)
                _apply_loaded_ego_waypoints(ego_actor.id)
                ego_spawn_location = ego_actor.get_location()
                print(f"Loaded ego vehicle at ({spawn_location.x:.2f}, {spawn_location.y:.2f}, {spawn_location.z:.2f})")
            else:
                fallback_actor = self.get_ego_vehicle_actor()
                if fallback_actor and fallback_actor.is_alive:
                    print(f"Reusing existing ego actor {fallback_actor.id} for scenario spawn")
                    external_id = None
                    try:
                        editor = getattr(self, "editor", None)
                        if editor:
                            external_id = getattr(editor, "external_ego_actor_id", None) or getattr(
                                editor, "_external_swap_current_id", None
                            )
                    except Exception:
                        external_id = None
                    if external_id is not None and fallback_actor.id == external_id:
                        try:
                            fallback_actor.set_simulate_physics(True)
                        except Exception:
                            pass
                    else:
                        fallback_actor.set_simulate_physics(False)
                    fallback_actor.set_transform(transform)
                    self.spawned_vehicles.append(fallback_actor)
                    self.initialize_vehicle_metadata(
                        fallback_actor.id,
                        speed=ego_default_speed,
                        destination_speed=destination_speed_value,
                        idle_time=float(ego_data.get('idle_time_s', 0.0) or 0.0),
                        turn_time=0.0,
                        color=ego_color,
                        ignore_flags=ignore_flags,
                        max_lat_acc=max_lat_acc_value,
                    )
                    self.register_ego_vehicle(fallback_actor, transform)
                    _apply_loaded_ego_waypoints(fallback_actor.id)
                    ego_spawn_location = fallback_actor.get_location()
                else:
                    self.ego_vehicle_transform = transform
                    self.ego_vehicle_blueprint = ego_data.get('type', 'vehicle.lexus.utlexus')
                    self.ego_vehicle_id = None
                    ego_spawn_location = carla.Location(base_location.x, base_location.y, base_location.z)
                    print(f"Warning: Failed to spawn ego vehicle at ({base_location.x:.2f}, {base_location.y:.2f}, {base_location.z:.2f}). Location might be blocked.")
        except Exception as exc:
            self.ego_vehicle_transform = carla.Transform(spawn_location, rotation)
            self.ego_vehicle_blueprint = ego_data.get('type', 'vehicle.lexus.utlexus')
            self.ego_vehicle_id = None
            print(f"Error loading ego vehicle: {exc}")

        return ego_spawn_location

    def _apply_trigger_data(self, trigger_data):
        """Restore trigger from scenario data."""
        if not trigger_data:
            print("No trigger found in scenario")
            return
        try:
            loc = trigger_data.get('location', {})
            trigger = {
                'x': loc.get('x', 0.0),
                'y': loc.get('y', 0.0),
                'z': loc.get('z', 0.0),
                'radius': trigger_data.get('radius', 10.0),
            }
            self.triggers.append(trigger)
            print(f"Successfully loaded trigger at ({trigger['x']:.2f}, {trigger['y']:.2f}, {trigger['z']:.2f})")
        except Exception as trigger_exc:
            print(f"Error loading trigger: {trigger_exc}")

    def _apply_traffic_light_trigger_data(self, trigger_entries) -> None:
        """Restore traffic light group triggers from saved scenario data."""
        if not trigger_entries:
            print("No traffic light triggers in scenario")
            return

        if not isinstance(trigger_entries, list):
            print("Warning: Traffic light trigger payload is malformed; expected a list.")
            return

        try:
            self._refresh_traffic_lights()
        except Exception as exc:
            print(f"Warning: Unable to refresh traffic lights before applying triggers ({exc})")

        if not self.traffic_light_groups:
            print("Warning: No traffic light groups available to apply trigger data.")
            return

        live_lookup = {frozenset(group.ids): group for group in self.traffic_light_groups if group.ids}
        reference_lookup: Dict[frozenset, TrafficLightGroupData] = {}
        fingerprint_lookup: Dict[Tuple[Tuple[int, int, int], ...], TrafficLightGroupData] = {}
        for group in self.traffic_light_groups:
            if group.reference_ids:
                reference_lookup[frozenset(group.reference_ids)] = group
            if group.location_fingerprint:
                fingerprint_lookup[group.location_fingerprint] = group
        restored_count = 0

        for entry in trigger_entries:
            if not isinstance(entry, dict):
                continue
            ids_live = entry.get('ids_live')
            ids_reference = entry.get('ids_reference')
            fingerprint_payload = entry.get('fingerprint')

            group: Optional[TrafficLightGroupData] = None

            def _make_set(values: Optional[Iterable[int]]) -> Optional[frozenset]:
                if not values:
                    return None
                try:
                    converted = [int(v) for v in values]
                except Exception:
                    return None
                return frozenset(converted)

            # Prefer fingerprint matching to survive ID churn
            if group is None and fingerprint_payload:
                try:
                    fingerprint_tuple = tuple(
                        (int(pt[0]), int(pt[1]), int(pt[2])) for pt in fingerprint_payload
                    )
                except Exception:
                    fingerprint_tuple = None
                if fingerprint_tuple:
                    group = fingerprint_lookup.get(fingerprint_tuple)

            live_key = _make_set(ids_live)
            if group is None and live_key:
                group = live_lookup.get(live_key)

            if group is None:
                reference_key = _make_set(ids_reference or ids_live)
                if reference_key:
                    group = reference_lookup.get(reference_key) or live_lookup.get(reference_key)

            if not group:
                ids_for_warning = ids_live or ids_reference or fingerprint_payload
                print(
                    f"Warning: Traffic light trigger references IDs/fingerprint {ids_for_warning}, "
                    "but no matching group was found."
                )
                group = None

            normalized_fp = self._normalize_traffic_light_fingerprint(fingerprint_payload)
            center_payload = entry.get('center', {})
            radius_value = max(MIN_PERSONAL_TRIGGER_RADIUS, float(entry.get('radius', DEFAULT_PERSONAL_TRIGGER_RADIUS)))
            stored_center = {
                'x': float(center_payload.get('x', 0.0)),
                'y': float(center_payload.get('y', 0.0)),
                'z': float(center_payload.get('z', 0.0)),
            }
            key = self._traffic_light_trigger_key(
                group=group,
                fingerprint=normalized_fp,
                ids=ids_reference or ids_live,
            )
            self._set_traffic_light_trigger_data(
                stored_center,
                radius_value,
                key=key,
                group=group,
                mark_visible=False,
            )
            self._cache_traffic_light_trigger_payload(group)
            reference_key = _make_set(ids_reference or ids_live)
            if group:
                if reference_key:
                    group.reference_ids = set(reference_key)
                elif group.reference_ids is None:
                    group.reference_ids = set(group.ids)
                if fingerprint_payload and not group.location_fingerprint:
                    try:
                        group.location_fingerprint = tuple(
                            (int(pt[0]), int(pt[1]), int(pt[2])) for pt in fingerprint_payload
                        )
                    except Exception:
                        group.location_fingerprint = group.location_fingerprint
            sequence_payload = entry.get('sequence', [])
            if group:
                if isinstance(sequence_payload, list):
                    group.sequence = self._normalize_traffic_light_sequence(
                        sequence_payload,
                        coerce_color=True,
                    )
                else:
                    group.sequence = []
            restored_count += 1

            if (
                self.selected_traffic_light_group is not None
                and group.ids == self.selected_traffic_light_group.ids
            ):
                self._update_traffic_light_menu_anchor(group)

            self._cache_traffic_light_sequence(group)

        if restored_count:
            print(f"Restored {restored_count} traffic light trigger(s) from scenario data")
        else:
            print("No traffic light triggers restored (no matching traffic light groups found)")

    def _resolve_focus_location(self, context, ego_spawn_location):
        """Determine a good camera target after loading a scenario."""
        return (
            ego_spawn_location
            or context['first_vehicle_spawn_location']
            or context['first_vehicle_json_location']
            or context['first_ped_spawn_location']
            or context['first_ped_json_location']
        )

    def load_waypoint_data_from_file(
        self,
        filename,
        *,
        preserve_camera: bool = False,
        skip_ego_spawn: bool = False,
        apply_to_actor_only: bool = False,
        external_ego_actor: Optional[carla.Actor] = None,
        preserved_actor_id: Optional[int] = None,
    ):
        """Load waypoint data from a JSON file"""
        try:
            editor = getattr(self, "editor", None)
            if editor and hasattr(editor, "_debug_camera_pose"):
                try:
                    editor._debug_camera_pose(
                        f"load-waypoints-start preserve_camera={preserve_camera} skip_ego_spawn={skip_ego_spawn} apply_to_actor_only={apply_to_actor_only}"
                    )
                except Exception:
                    pass

            with open(filename, 'r') as f:
                load_data = json.load(f)

            # Store loaded data for later reference (needed for pedestrian restoration)
            self.loaded_scenario_data = load_data
            ego_data = load_data.get('ego_vehicle')

            print(f"Loading scenario from {filename}...")
            print(f"Map: {load_data.get('map_name', 'Unknown')}")

            # If we are skipping ego spawn because an external ego is active, reload others while preserving the external.
            if skip_ego_spawn and not apply_to_actor_only:
                editor_ref = getattr(self, "editor", None)
                external_actor = getattr(editor_ref, "external_ego_actor", None) if editor_ref else None
                if external_actor and external_actor.is_alive and ego_data:
                    try:
                        self._apply_ego_data_to_actor(ego_data, external_actor)
                        self.waypoint_display_vehicle_id = external_actor.id
                        self.selected_vehicle = external_actor
                        self.selected_vehicle_is_pedestrian = False
                        self.refresh_waypoints_carla_debug()
                    except Exception as exc:
                        print(f"Failed to apply ego data to external actor during skip_ego_spawn load: {exc}")
                    preserved_actor_id = external_actor.id
                elif preserved_actor_id is not None:
                    preserved_actor_id = preserved_actor_id
                else:
                    # Skip full reload/reset when skipping ego spawn but no external actor to target
                    return True

                preserved_waypoints = self.get_vehicle_waypoints(preserved_actor_id) if preserved_actor_id else []
                self.cleanup_all_vehicles(preserve_ids={preserved_actor_id} if preserved_actor_id else set())
                # Clear non-ego waypoint/metadata entries
                for vid in list(self.waypoint_list.keys()):
                    if vid != preserved_actor_id:
                        self.clear_vehicle_waypoints(vid)
                # Clear triggers/traffic-light state
                self.triggers.clear()
                self.traffic_light_trigger_centers.clear()
                self.traffic_light_trigger_radii.clear()
                self.traffic_light_sequences.clear()
                self._traffic_light_group_snapshots.clear()
                self._scenario_active_traffic_light_trigger = None
                self._last_visible_traffic_light_trigger_key = None
                self.scaling_traffic_light_trigger = False
                self._traffic_light_scaling_group = None
                self.traffic_light_menu_position = None
                for group in self.traffic_light_groups:
                    group.trigger_center = None
                    group.trigger_radius = None
                self.clear_traffic_light_selection()

                context = {
                    'first_vehicle_json_location': None,
                    'first_vehicle_spawn_location': None,
                    'first_ped_json_location': None,
                    'first_ped_spawn_location': None,
                }
                blueprint_library = self.world.get_blueprint_library()
                for vehicle_data in load_data.get('vehicles', []):
                    self._load_vehicle_entry(vehicle_data, blueprint_library, ego_data, context)

                self._apply_trigger_data(load_data.get('trigger'))

                triggers_payload = self._normalize_traffic_light_trigger_entries(
                    load_data.get('traffic_light_triggers')
                )
                self._apply_traffic_light_trigger_data(triggers_payload)

                if preserved_actor_id is not None:
                    if preserved_waypoints:
                        try:
                            self.set_vehicle_waypoints(preserved_actor_id, preserved_waypoints)
                        except Exception:
                            pass
                    self.waypoint_display_vehicle_id = preserved_actor_id
                    self.selected_vehicle = self.get_spawned_vehicle(preserved_actor_id) or external_actor
                    self.selected_vehicle_is_pedestrian = False
                    try:
                        self.refresh_waypoints_carla_debug()
                    except Exception:
                        pass
                return True

            # If we only need to apply ego data to an existing actor, do it and return
            if apply_to_actor_only:
                if ego_data and external_ego_actor:
                    try:
                        self._apply_ego_data_to_actor(ego_data, external_ego_actor)
                        self.waypoint_display_vehicle_id = external_ego_actor.id
                        self.selected_vehicle = external_ego_actor
                        self.selected_vehicle_is_pedestrian = False
                        self.refresh_waypoints_carla_debug()
                    except Exception as exc:
                        print(f"Failed to apply ego data to external actor: {exc}")
                return True

            context = {
                'first_vehicle_json_location': None,
                'first_vehicle_spawn_location': None,
                'first_ped_json_location': None,
                'first_ped_spawn_location': None,
            }
            self._reset_scenario_state()

            blueprint_library = self.world.get_blueprint_library()
            
            for vehicle_data in load_data.get('vehicles', []):
                self._load_vehicle_entry(vehicle_data, blueprint_library, ego_data, context)
            
            print(f"Successfully loaded {len(self.spawned_vehicles)} vehicles")

            ego_spawn_location = None
            if ego_data and not skip_ego_spawn:
                ego_spawn_location = self._spawn_ego_from_data(ego_data, blueprint_library)

            self._apply_trigger_data(load_data.get('trigger'))

            triggers_payload = self._normalize_traffic_light_trigger_entries(
                load_data.get('traffic_light_triggers')
            )
            self._apply_traffic_light_trigger_data(triggers_payload)

            target_location = self._resolve_focus_location(context, ego_spawn_location)
            has_actor_focus = bool(
                context['first_vehicle_spawn_location']
                or context['first_vehicle_json_location']
                or context['first_ped_spawn_location']
                or context['first_ped_json_location']
            )

            if target_location and (not preserve_camera or not has_actor_focus):
                auto_camera_ok = not (editor and getattr(editor, "camera_stream_enabled", True) is False)
                if auto_camera_ok:
                    self.focus_camera_on_location(target_location)
                    if editor and hasattr(editor, "_debug_camera_pose"):
                        try:
                            editor._debug_camera_pose("load-waypoints-focus")
                        except Exception:
                            pass

            return True

        except Exception as e:
            print(f"Error loading waypoint data: {e}")
            return False

    def get_actor_original_json_position(self, actor_id, actor_type):
        """Get the original position of an actor from the loaded JSON data"""
        if not hasattr(self, 'loaded_scenario_data') or not self.loaded_scenario_data:
            return None

        # Search for the actor in the loaded JSON data by type
        for vehicle_data in self.loaded_scenario_data.get('vehicles', []):
            if vehicle_data.get('type') == actor_type:
                location_data = vehicle_data.get('location', {})
                rotation_data = vehicle_data.get('rotation', {})

                # Create CARLA location and rotation objects
                location = carla.Location(
                    location_data.get('x', 0),
                    location_data.get('y', 0),
                    location_data.get('z', 0)
                )
                rotation = carla.Rotation(
                    rotation_data.get('pitch', 0),
                    rotation_data.get('yaw', 0),
                    rotation_data.get('roll', 0)
                )

                print(f"Found original JSON position for {actor_type}: ({location.x:.2f}, {location.y:.2f}, {location.z:.2f})")
                return carla.Transform(location, rotation)

        ego_data = self.loaded_scenario_data.get('ego_vehicle')
        if ego_data and ego_data.get('type') == actor_type:
            location = carla.Location(
                ego_data.get('location', {}).get('x', 0),
                ego_data.get('location', {}).get('y', 0),
                ego_data.get('location', {}).get('z', 0)
            )
            rotation = carla.Rotation(
                ego_data.get('rotation', {}).get('pitch', 0),
                ego_data.get('rotation', {}).get('yaw', 0),
                ego_data.get('rotation', {}).get('roll', 0)
            )
            print(f"Found original JSON position for ego {actor_type}: ({location.x:.2f}, {location.y:.2f}, {location.z:.2f})")
            return carla.Transform(location, rotation)

        print(f"No JSON position found for actor type: {actor_type}")
        return None

    def get_latest_image(self):
        """Get the latest camera image scaled to the current screen size if needed."""
        if not self.latest_image:
            return None

        target_size = (int(self.screen_width), int(self.screen_height))
        if target_size[0] <= 0 or target_size[1] <= 0:
            return self.latest_image

        if self.latest_image.get_size() == target_size:
            return self.latest_image

        if (
            self._scaled_image_cache is not None
            and self._scaled_image_size == target_size
            and self._scaled_image_frame == self.latest_frame_id
        ):
            return self._scaled_image_cache

        scaled = pygame.transform.smoothscale(self.latest_image, target_size)
        self._scaled_image_cache = scaled
        self._scaled_image_size = target_size
        self._scaled_image_frame = self.latest_frame_id
        return scaled
    
    def handle_mouse_click(self, screen_x, screen_y, move_camera=False):
        """Handle mouse clicks that should move the camera."""
        if move_camera:
            self.coordinate_detector.move_camera_to_screen_position(
                screen_x, screen_y, self.screen_width, self.screen_height
            )
    
    def _hit_test_displayed_waypoint(self, screen_x: int, screen_y: int):
        """Return hit waypoint metadata when clicking near a rendered marker."""
        vehicle_id = self.waypoint_display_vehicle_id
        if not vehicle_id:
            return None
        waypoints = self.get_vehicle_waypoints(vehicle_id)
        if not waypoints:
            return None

        for index, waypoint in enumerate(waypoints):
            screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                waypoint['x'], waypoint['y'], waypoint['z'] + 1.0
            )
            if not screen_pos.get('success'):
                continue
            marker_x = int(screen_pos['x'])
            marker_y = int(screen_pos['y'])
            distance = math.hypot(marker_x - screen_x, marker_y - screen_y)
            if distance <= self.waypoint_marker_radius + 5:
                return {
                    'vehicle_id': vehicle_id,
                    'index': index,
                    'waypoint': waypoint,
                }
        return None

    def handle_waypoint_click(self, screen_x, screen_y):
        """Handle click on waypoint markers for selection and movement"""
        hit = self._hit_test_displayed_waypoint(screen_x, screen_y)
        if not hit:
            self.waypoint_drag_armed = False
            if not self.moving_waypoint:
                self.selected_waypoint_vehicle_id = None
                self.selected_waypoint_index = None
                self.moving_waypoint = False
            return False

        vehicle_id = hit['vehicle_id']
        waypoint_index = hit['index']
        waypoints = self.get_vehicle_waypoints(vehicle_id)
        if not waypoints or waypoint_index >= len(waypoints):
            return False

        waypoint = waypoints[waypoint_index]
        # Reset pending click action; will re-arm if this click targets the last waypoint
        self.pending_waypoint_click_action = None
        # Arm dragging only because this click hit a waypoint
        self.waypoint_drag_armed = True
        # Waypoint was clicked - only select it, don't start moving yet
        self.selected_waypoint_vehicle_id = vehicle_id
        self.selected_waypoint_index = waypoint_index
        # Store the click position for potential drag detection
        self.waypoint_movement_start_pos = (screen_x, screen_y)
        # Store the complete waypoint state for undo operations
        self.waypoint_movement_start_coords = {
            'x': waypoint['x'],
            'y': waypoint['y'],
            'z': waypoint['z'],
            'snapped': waypoint.get('snapped', False),
            'yaw': waypoint.get('yaw', None),
            'speed_km_h': waypoint.get('speed_km_h', 50),
            'idle_time_s': waypoint.get('idle_time_s', 0.0),
            'turn_time_s': waypoint.get('turn_time_s', 0.0)
        }
        # Store original height for potential movement
        self.waypoint_original_height = waypoint['z']
        # Arm pending action so a simple click on the last waypoint can extend the path
        if self._is_last_waypoint(vehicle_id, waypoint_index):
            self.pending_waypoint_click_action = {
                'vehicle_id': vehicle_id,
                'index': waypoint_index
            }
        # Don't set moving_waypoint = True here - wait for mouse movement
        print(f"Selected waypoint {waypoint_index + 1}")

        # Show info panel for selected waypoint
        if self.editor and hasattr(self.editor, 'info_panel'):
            self.editor.info_panel.show(
                waypoint,
                'waypoint',
                self.editor.screen_width,
                self.editor.screen_height,
                vehicle_id,
                waypoint_index,
            )
        return True

    def split_waypoint_at_click(self, screen_x: int, screen_y: int) -> bool:
        """Split the waypoint hit by the cursor into two offset points."""
        hit = self._hit_test_displayed_waypoint(screen_x, screen_y)
        if not hit:
            return False
        vehicle_id = hit['vehicle_id']
        waypoint_index = hit['index']
        waypoints = self.get_vehicle_waypoints(vehicle_id)
        if not waypoints or waypoint_index >= len(waypoints):
            return False

        waypoint_data = waypoints[waypoint_index]
        offset = getattr(self, "waypoint_split_offset", 1.5)
        command = SplitWaypointCommand(
            self,
            vehicle_id,
            waypoint_index,
            waypoint_data,
            offset_distance=offset,
        )
        if self.editor:
            success = self.editor.execute_command(command)
        else:
            success = command.execute()
        if success is False:
            return False

        updated_waypoints = self.get_vehicle_waypoints(vehicle_id)
        target_index = min(waypoint_index, len(updated_waypoints) - 1) if updated_waypoints else waypoint_index
        self.selected_waypoint_vehicle_id = vehicle_id
        self.selected_waypoint_index = target_index
        self.waypoint_original_height = updated_waypoints[target_index].get('z', 0.0) if updated_waypoints else None
        self.moving_waypoint = False
        self.pending_waypoint_click_action = None

        if (self.editor and hasattr(self.editor, 'info_panel') and updated_waypoints
                and target_index < len(updated_waypoints)):
            self.editor.info_panel.show(
                updated_waypoints[target_index],
                'waypoint',
                self.editor.screen_width,
                self.editor.screen_height,
                vehicle_id,
                target_index,
            )

        self.refresh_waypoints_carla_debug()
        print(f"Split waypoint {waypoint_index + 1} for actor {vehicle_id}")
        return True
    
    def handle_waypoint_mouse_movement(self, screen_x, screen_y):
        """Handle mouse movement for waypoint dragging"""
        # Do not allow dragging while placing new waypoints
        if self.creating_waypoint:
            return

        # Only process drag logic when armed by a recent waypoint click
        if not self.waypoint_drag_armed and not self.moving_waypoint:
            return

        # Check if we have a selected waypoint (but not necessarily moving yet)
        if (self.selected_waypoint_vehicle_id is not None and 
            self.selected_waypoint_index is not None):
            
            # Check if the waypoint list and waypoint still exist
            waypoints = self.get_vehicle_waypoints(self.selected_waypoint_vehicle_id)
            if (not waypoints or
                self.selected_waypoint_index >= len(waypoints)):
                self.selected_waypoint_vehicle_id = None
                self.selected_waypoint_index = None
                self.moving_waypoint = False
                self.waypoint_drag_armed = False
                return
            
            # If we're not moving yet, check if we should start moving based on drag threshold
            if not self.moving_waypoint:
                # Calculate distance from initial click position
                dx = screen_x - self.waypoint_movement_start_pos[0]
                dy = screen_y - self.waypoint_movement_start_pos[1]
                drag_distance = (dx * dx + dy * dy) ** 0.5
                
                # Start moving only if we've exceeded the drag threshold
                if drag_distance > self.waypoint_drag_threshold:
                    self.moving_waypoint = True
                    # Cancel pending click action because we're dragging instead of tapping
                    self.pending_waypoint_click_action = None
                    print(f"Started dragging waypoint {self.selected_waypoint_index + 1}")
                else:
                    # Still within threshold, don't start moving
                    return
            
            # Now handle the actual movement (only if moving_waypoint is True)
            if self.moving_waypoint:
                # Check if we have a valid original height
                if self.waypoint_original_height is None:
                    # Fallback to current waypoint height if original height is missing
                    if (waypoints and
                        self.selected_waypoint_index < len(waypoints)):
                        waypoint = waypoints[self.selected_waypoint_index]
                        self.waypoint_original_height = waypoint.get('z', 0.0)
                    else:
                        self.waypoint_original_height = 0.0  # Safe fallback
                
                # Check if Shift is held for free movement during waypoint drag
                keys = pygame.key.get_pressed()
                snap_to_lane = not is_shift_pressed(keys)  # Snap by default, shift for free placement
                if self._is_pedestrian_actor(self.selected_waypoint_vehicle_id):
                    snap_to_lane = False

                # Always use fast coordinate conversion and keep original Z during movement
                world_coords = self.coordinate_detector.screen_to_world_coordinates_no_raycast(
                    screen_x, screen_y, self.screen_width, self.screen_height, self.waypoint_original_height
                )

                if world_coords and world_coords.get('success', False):
                    waypoint = waypoints[self.selected_waypoint_index]
                    if snap_to_lane:
                        # Snap to lane, but keep original Z (use fast method, no raycast)
                        lane_result = self.coordinate_detector.find_closest_lane_point_fast(
                            world_coords['x'], world_coords['y'], self.waypoint_original_height
                        )
                        if lane_result['success']:
                            waypoint['x'] = lane_result['x']
                            waypoint['y'] = lane_result['y']
                            waypoint['z'] = self.waypoint_original_height
                            waypoint['snapped'] = True
                            waypoint['yaw'] = lane_result.get('yaw', None)
                        else:
                            waypoint['x'] = world_coords['x']
                            waypoint['y'] = world_coords['y']
                            waypoint['z'] = self.waypoint_original_height
                            waypoint['snapped'] = False
                    else:
                        # Free placement, keep original Z
                        waypoint['x'] = world_coords['x']
                        waypoint['y'] = world_coords['y']
                        waypoint['z'] = self.waypoint_original_height
                        waypoint['snapped'] = False
                else:
                    print("Failed to convert screen coordinates to world coordinates")
    
    def handle_waypoint_mouse_release(self):
        """Handle mouse release to stop waypoint movement and apply final positioning with raycasting"""
        # If there was no drag, a simple tap on the final waypoint should extend the path
        if (not self.moving_waypoint and
            self.pending_waypoint_click_action and
            self.selected_waypoint_vehicle_id == self.pending_waypoint_click_action.get('vehicle_id') and
            self.selected_waypoint_index == self.pending_waypoint_click_action.get('index') and
            self._is_last_waypoint(self.selected_waypoint_vehicle_id, self.selected_waypoint_index)):

            self._start_waypoint_extension_mode(self.selected_waypoint_vehicle_id)

        if self.moving_waypoint and self.selected_waypoint_index is not None:
            # Store original position for undo command
            original_position = None
            if self.waypoint_movement_start_coords:
                # waypoint_movement_start_coords now contains the complete waypoint state
                original_position = copy.deepcopy(self.waypoint_movement_start_coords)
            
            # We were actually moving a waypoint, so do the expensive raycast for final positioning
            waypoints = self.get_vehicle_waypoints(self.selected_waypoint_vehicle_id)
            if not waypoints or self.selected_waypoint_index >= len(waypoints):
                self.moving_waypoint = False
                self.waypoint_original_height = None
                self.waypoint_movement_start_coords = None
                self.pending_waypoint_click_action = None
                return
            waypoint = waypoints[self.selected_waypoint_index]
            
            # Check if Shift is held for free movement on release
            keys = pygame.key.get_pressed()
            snap_to_lane = not is_shift_pressed(keys)  # Inverted: snap by default, shift for free movement
            if self._is_pedestrian_actor(self.selected_waypoint_vehicle_id):
                snap_to_lane = False

            # Get current mouse position for final raycast
            mouse_pos = pygame.mouse.get_pos()
            final_coords = self.coordinate_detector.screen_to_world_coordinates(
                mouse_pos[0], mouse_pos[1], self.screen_width, self.screen_height
            )
            
            if final_coords and final_coords.get('success', False):
                # Apply lane snapping if requested or if waypoint was originally snapped
                if snap_to_lane or waypoint.get('snapped', False):
                    lane_result = self.coordinate_detector.find_closest_lane_point(
                        final_coords['x'], final_coords['y'], final_coords['z']
                    )
                    if lane_result['success']:
                        waypoint['x'] = lane_result['x']
                        waypoint['y'] = lane_result['y']
                        waypoint['z'] = lane_result['z']  # Use proper raycasted height on release
                        waypoint['snapped'] = True
                        waypoint['yaw'] = lane_result.get('yaw', None)
                        if snap_to_lane:
                            print(f"Snapped waypoint to lane during movement")
                    else:
                        # If snapping failed, use regular coordinates with raycasted height
                        waypoint['x'] = final_coords['x']
                        waypoint['y'] = final_coords['y']
                        waypoint['z'] = final_coords['z']
                        waypoint['snapped'] = False
                else:
                    # Update with raycasted height (no lane snapping)
                    waypoint['x'] = final_coords['x']
                    waypoint['y'] = final_coords['y']
                    waypoint['z'] = final_coords['z']
                    waypoint['snapped'] = False
            
            # Create undo command if waypoint was actually moved
            if original_position:
                new_position = {
                    'x': waypoint['x'],
                    'y': waypoint['y'],
                    'z': waypoint['z'],
                    'snapped': waypoint.get('snapped', False),
                    'yaw': waypoint.get('yaw', None),
                    'speed_km_h': waypoint.get('speed_km_h', 50),
                    'idle_time_s': waypoint.get('idle_time_s', 0.0)
                }
                
                # Only create command if position actually changed
                if (abs(original_position['x'] - new_position['x']) > 0.01 or
                    abs(original_position['y'] - new_position['y']) > 0.01 or
                    abs(original_position['z'] - new_position['z']) > 0.01):
                    
                    command = MoveWaypointCommand(
                        self,
                        self.selected_waypoint_vehicle_id,
                        self.selected_waypoint_index,
                        original_position,
                        new_position
                    )
                    self.editor.execute_command(command)
            
            waypoint_num = self.selected_waypoint_index + 1
            print(f"Finished moving waypoint {waypoint_num}")
            # If the first waypoint moved for a pedestrian, reorient to it
            if self._is_pedestrian_actor(self.selected_waypoint_vehicle_id) and self.selected_waypoint_index == 0:
                self._adjust_pedestrian_spawn_orientation(self.selected_waypoint_vehicle_id)
            
        # Always reset movement state on mouse release
        self.moving_waypoint = False
        self.waypoint_original_height = None
        self.waypoint_movement_start_coords = None  # Clear original coordinates
        self.pending_waypoint_click_action = None
        self.waypoint_drag_armed = False
        # Keep the waypoint selected (don't clear selected_waypoint_vehicle_id and selected_waypoint_index)
        # This allows for quick re-selection and maintains selection for other operations like deletion

    def _cache_destination_speed(self, vehicle_id):
        """Update cached destination speed for a vehicle based on its waypoints."""
        if vehicle_id is None:
            return

        waypoints = self.get_vehicle_waypoints(vehicle_id)
        if not waypoints:
            self.clear_vehicle_destination_speed(vehicle_id)
            return

        for waypoint in reversed(waypoints):
            if waypoint.get('is_destination'):
                speed = waypoint.get(
                    'speed_km_h',
                    self.get_vehicle_speed(vehicle_id, 50)
                )
                self.set_vehicle_destination_speed(vehicle_id, speed)
                return

        # No destination waypoint flagged - fall back to last waypoint speed
        last_speed = waypoints[-1].get('speed_km_h', self.get_vehicle_speed(vehicle_id, 50))
        self.set_vehicle_destination_speed(vehicle_id, last_speed)

    def _start_waypoint_extension_mode(self, vehicle_id):
        """Enter waypoint creation mode starting from the current final waypoint."""
        if vehicle_id is None:
            return False

        # Already in creation mode for this vehicle – nothing to change
        if (self.creating_waypoint and self.waypoint_vehicle and self.waypoint_vehicle.is_alive and
                self.waypoint_vehicle.id == vehicle_id):
            return False

        # If we're creating waypoints for another vehicle, stop that session first
        if self.creating_waypoint:
            self.stop_waypoint_creation()

        vehicle = next((v for v in self.spawned_vehicles if v.id == vehicle_id and v.is_alive), None)
        if not vehicle:
            print("Cannot extend waypoints: vehicle is no longer available.")
            return False

        # Ensure the previous destination waypoint resumes normal behaviour before extending
        waypoints = self.get_vehicle_waypoints(vehicle_id)
        if waypoints:
            last_index = len(waypoints) - 1
            last_waypoint = waypoints[last_index]
            default_speed = self.get_vehicle_speed(vehicle_id, 50)

            # Prepare property adjustments if needed
            adjustments = []
            if last_waypoint.get('is_destination', False):
                adjustments.append(('is_destination', last_waypoint.get('is_destination'), False))
            if last_waypoint.get('speed_km_h', 50) <= 0:
                # Avoid zero target speed that would make the vehicle stop prematurely
                adjustments.append(('speed_km_h', last_waypoint.get('speed_km_h', 0), max(default_speed, 10)))

            for property_name, old_value, new_value in adjustments:
                if old_value == new_value:
                    continue

                if self.editor:
                    command = UpdateWaypointPropertyCommand(
                        self,
                        vehicle_id,
                        last_index,
                        property_name,
                        old_value,
                        new_value
                    )
                    self.editor.execute_command(command)
                else:
                    # fallback without command system (should not generally happen)
                    waypoints[last_index][property_name] = new_value

        # Reuse the existing creation workflow by selecting the vehicle and invoking start without clearing
        self.selected_vehicle = vehicle
        self.selected_vehicle_is_pedestrian = vehicle.type_id.startswith('walker.')
        self.start_waypoint_creation(reset_existing=False)
        # --- Keep info panel visible for last waypoint during extension mode ---
        if waypoints:
            last_index = len(waypoints) - 1
            last_waypoint = waypoints[last_index]
            if self.editor and hasattr(self.editor, 'info_panel'):
                self.editor.info_panel.show(last_waypoint, 'waypoint', self.editor.screen_width, self.editor.screen_height, vehicle_id, last_index)
        print("Additional waypoint mode activated. Click to add waypoints, press ESC or right-click to finish.")
        return True

    def _is_last_waypoint(self, vehicle_id, waypoint_index):
        """Check whether the given waypoint is currently the final waypoint for the vehicle."""
        if vehicle_id is None or waypoint_index is None:
            return False

        waypoints = self.get_vehicle_waypoints(vehicle_id)
        if not waypoints:
            return False

        if waypoint_index < 0 or waypoint_index >= len(waypoints):
            return False

        return waypoint_index == len(waypoints) - 1

    def update_waypoint_movement(self, mouse_pos):
        """Update waypoint position based on mouse movement (used by main event loop)"""
        self.handle_waypoint_mouse_movement(mouse_pos[0], mouse_pos[1])
    
    def stop_waypoint_movement(self):
        """Stop waypoint movement (used by main event loop)"""
        self.handle_waypoint_mouse_release()
    
    def delete_selected_waypoint(self):
        """Delete the currently selected waypoint and reconnect the path"""
        if (self.selected_waypoint_vehicle_id is None or 
            self.selected_waypoint_index is None or
            not self.get_vehicle_waypoints(self.selected_waypoint_vehicle_id)):
            print("No waypoint selected for deletion")
            return False
        
        waypoints = self.get_vehicle_waypoints(self.selected_waypoint_vehicle_id)
        
        if self.selected_waypoint_index >= len(waypoints):
            print("Invalid waypoint index")
            return False
        
        # Get waypoint info before deletion
        waypoint_num = self.selected_waypoint_index + 1
        waypoint_data = waypoints[self.selected_waypoint_index]
        
        # Create and execute delete waypoint command
        command = DeleteWaypointCommand(
            self,
            self.selected_waypoint_vehicle_id,
            self.selected_waypoint_index,
            waypoint_data
        )
        success = self.editor.execute_command(command)
        
        if success:
            print(f"Deleted waypoint {waypoint_num} (was at {waypoint_data['x']:.1f}, {waypoint_data['y']:.1f})")
            
            # Update selection after deletion
            waypoints = self.get_vehicle_waypoints(self.selected_waypoint_vehicle_id)
            
            # Handle the case where we deleted the last waypoint
            if self.selected_waypoint_index >= len(waypoints):
                if len(waypoints) > 0:
                    # Select the new last waypoint
                    self.selected_waypoint_index = len(waypoints) - 1
                    print(f"Selected previous waypoint (now waypoint {self.selected_waypoint_index + 1})")
                else:
                    # No waypoints left, clear selection
                    print("No waypoints remaining for this vehicle")
                    self.selected_waypoint_vehicle_id = None
                    self.selected_waypoint_index = None
            else:
                # We deleted a waypoint in the middle, keep current index
                print(f"Path automatically reconnected. Selected waypoint {self.selected_waypoint_index + 1}")
            
            # Clear movement state if we were moving the deleted waypoint
            if self.moving_waypoint:
                self.moving_waypoint = False
                self.waypoint_original_height = None
            
            print(f"Waypoints remaining: {len(waypoints)}")
        
        return success
    
    def select_vehicle_actor(
        self,
        actor: Optional[carla.Actor],
        *,
        focus_camera: bool = False,
        fallback_screen_pos: Optional[Tuple[int, int]] = None,
    ) -> bool:
        """Select a vehicle or pedestrian actor and optionally move the camera."""
        if not actor or not actor.is_alive:
            return False

        if self.selected_trigger_index is not None or self.trigger_action_menu_position:
            self.selected_trigger_index = None
            self.trigger_action_menu_position = None
        if self.selected_personal_trigger:
            self.clear_personal_trigger_selection()
        self.clear_traffic_light_selection()

        self.selected_vehicle = actor
        self.selected_vehicle_is_pedestrian = actor.type_id.startswith('walker.')
        self.waypoint_display_vehicle_id = actor.id

        actor_location: Optional[carla.Location] = None
        if self.large_map_active:
            cached = self._actor_location_cache.get(actor.id)
            if cached:
                actor_location = cached[0]
            if actor_location is None:
                if focus_camera:
                    self._pending_large_map_focus_actor_id = int(actor.id)
                    self._pending_large_map_focus_next_attempt = 0.0
                    self._pending_large_map_focus_failures = 0
                else:
                    actor_location = self._get_actor_location_fast(actor.id, max_age_s=0.25)
        else:
            cached = self._actor_location_cache.get(actor.id) if focus_camera else None
            if cached:
                actor_location = cached[0]
            if actor_location is None:
                try:
                    actor_location = actor.get_location()
                except Exception:
                    actor_location = None
        if actor_location is not None:
            self._cache_actor_location(actor.id, actor_location)

        screen_pos = None
        if actor_location:
            screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                actor_location.x, actor_location.y, actor_location.z + 2.0
            )

        if screen_pos and screen_pos.get('success'):
            self.vehicle_menu_position = (int(screen_pos['x']), int(screen_pos['y']))
        elif fallback_screen_pos:
            self.vehicle_menu_position = (int(fallback_screen_pos[0]), int(fallback_screen_pos[1]))
        else:
            self.vehicle_menu_position = None

        skip_expensive_ui = bool(focus_camera and self.large_map_active)

        if self.editor and hasattr(self.editor, 'info_panel') and not skip_expensive_ui:
            obj_type = 'pedestrian' if self.selected_vehicle_is_pedestrian else 'vehicle'
            self.editor.info_panel.show(actor, obj_type, self.editor.screen_width, self.editor.screen_height)

        if focus_camera and actor_location:
            self.focus_camera_on_location(actor_location)

        if not skip_expensive_ui:
            self.refresh_selected_vehicle_ui()

        if actor_location:
            print(f"Selected vehicle at ({actor_location.x:.2f}, {actor_location.y:.2f})")
        else:
            print("Selected vehicle.")
        return True

    def handle_vehicle_click(self, screen_x, screen_y):
        """Handle click on a vehicle to show action menu"""
        clicked_vehicle = self.coordinate_detector.check_vehicle_click(screen_x, screen_y)

        if clicked_vehicle:
            self.select_vehicle_actor(clicked_vehicle, fallback_screen_pos=(screen_x, screen_y))
            return True

        # No vehicle clicked, clear selection and hide waypoints
        self.clear_vehicle_selection()
        self.clear_traffic_light_selection()
        return False

    def handle_traffic_light_click(self, screen_x: int, screen_y: int) -> bool:
        """Check if a traffic light marker was clicked and select it."""
        if not self.traffic_light_groups:
            return False

        click_point = (screen_x, screen_y)

        for group in self.traffic_light_groups:
            if not group.lights:
                continue
            polygon_data = self._get_traffic_light_group_screen_polygon(group)
            if not polygon_data:
                continue

            screen_points, _ = polygon_data
            hit = False
            if len(screen_points) >= 3:
                hit = self._is_point_inside_polygon(click_point, screen_points)
            elif len(screen_points) == 2:
                hit = self._is_point_near_segment(click_point, screen_points[0], screen_points[1])
            elif len(screen_points) == 1:
                dx = screen_points[0][0] - screen_x
                dy = screen_points[0][1] - screen_y
                hit = (dx * dx + dy * dy) <= 36.0  # radius ~6px

            if hit:
                if self.selected_personal_trigger:
                    self.clear_personal_trigger_selection()
                self.select_traffic_light_group(group)
                return True

        return False

    def handle_traffic_light_action_click(self, screen_x: int, screen_y: int) -> bool:
        """Handle clicks on the traffic light action menu icons."""
        group = self.selected_traffic_light_group
        if not group:
            return False

        icons = self._get_traffic_light_menu_icons(group)
        if not icons:
            return False

        self._update_traffic_light_menu_anchor(group)
        if not self.traffic_light_menu_position:
            return False

        action = OverlayMenuRenderer.hit_test(
            self.traffic_light_menu_position,
            icons,
            (self.screen_width, self.screen_height),
            (screen_x, screen_y),
        )
        if not action:
            return False

        if action == 'add_trigger':
            self.start_personal_trigger_placement('traffic_light', group=group)
            return True
        if action == 'remove_trigger':
            self.delete_traffic_light_trigger(group)
            return True

        return False

    def _get_traffic_light_menu_icons(self, group: Optional[TrafficLightGroupData]) -> List[str]:
        """Return the ordered icon list for the selected traffic light group."""
        if not group:
            return []
        icons: List[str] = ['add_trigger']
        if group.has_trigger():
            icons.append('remove_trigger')
        return icons

    def _get_traffic_light_group_menu_anchor(
        self, group: Optional[TrafficLightGroupData]
    ) -> Optional[Tuple[float, float]]:
        """Compute the current menu anchor for a traffic light group in screen space."""
        if not group:
            return None

        polygon_data = self._get_traffic_light_group_screen_polygon(group)
        if polygon_data:
            _, screen_center = polygon_data
            if screen_center:
                return screen_center

        if group.screen_center:
            return group.screen_center
        return None

    def _update_traffic_light_menu_anchor(self, group: Optional[TrafficLightGroupData]) -> None:
        """Update cached menu anchor for the provided traffic light group."""
        anchor = self._get_traffic_light_group_menu_anchor(group)
        if anchor:
            self.traffic_light_menu_position = (int(anchor[0]), int(anchor[1]))
        else:
            self.traffic_light_menu_position = None

    def _compute_traffic_light_group_trigger_center(
        self, group: TrafficLightGroupData
    ) -> Optional[carla.Location]:
        """Return the world-space center of the traffic light trigger box overlay."""
        centers: List[carla.Location] = []
        fallback_points: List[carla.Location] = []

        for light in group.lights:
            rectangle_data = self._get_traffic_light_rectangle_points(light)
            if not rectangle_data:
                continue
            corners, center = rectangle_data
            if center is not None:
                centers.append(center)
            elif corners:
                fallback_points.extend(corners)

        if centers:
            avg_x = sum(loc.x for loc in centers) / len(centers)
            avg_y = sum(loc.y for loc in centers) / len(centers)
            avg_z = sum(loc.z for loc in centers) / len(centers)
            return carla.Location(avg_x, avg_y, avg_z)

        if fallback_points:
            avg_x = sum(loc.x for loc in fallback_points) / len(fallback_points)
            avg_y = sum(loc.y for loc in fallback_points) / len(fallback_points)
            avg_z = sum(loc.z for loc in fallback_points) / len(fallback_points)
            return carla.Location(avg_x, avg_y, avg_z)

        return None

    def _ensure_traffic_light_group_trigger(self, group: TrafficLightGroupData) -> bool:
        """Create a trigger entry for the provided traffic light group if missing."""
        if group.has_trigger():
            return True

        center_location = self._compute_traffic_light_group_trigger_center(group)
        if center_location is None:
            print("Warning: Unable to determine trigger center for selected traffic lights.")
            return False

        group.trigger_center = {
            'x': float(center_location.x),
            'y': float(center_location.y),
            'z': float(center_location.z),
        }
        group.trigger_radius = DEFAULT_PERSONAL_TRIGGER_RADIUS
        sorted_ids = sorted(group.ids)
        print(
            f"Created traffic light trigger for IDs {sorted_ids} at "
            f"({center_location.x:.2f}, {center_location.y:.2f}, {center_location.z:.2f}) "
            f"with radius {group.trigger_radius:.2f} m"
        )
        self._cache_traffic_light_sequence(group)
        self._cache_traffic_light_trigger_payload(group)

        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if panel and panel.object_type == 'traffic_light' and panel.visible:
            current = getattr(panel, 'selected_object', None)
            same_object = current is group
            same_ids = bool(current and getattr(current, 'ids', None) == group.ids)
            if same_ids and not same_object:
                panel.selected_object = group
            if same_object or same_ids:
                screen_width = getattr(self, "screen_width", 1280)
                screen_height = getattr(self, "screen_height", 720)
                panel.show(group, 'traffic_light', screen_width, screen_height)
        return True

    def start_traffic_light_trigger_scaling(self, mouse_pos: Tuple[int, int]) -> None:
        """Begin scaling operation for the selected traffic light group's trigger."""
        group = self.selected_traffic_light_group
        if not group or not group.has_trigger():
            return

        self.scaling_traffic_light_trigger = True
        self._traffic_light_scaling_group = group
        self.traffic_light_scale_start_pos = mouse_pos
        self.traffic_light_scale_start_radius = float(group.trigger_radius or DEFAULT_PERSONAL_TRIGGER_RADIUS)
        print(f"Started scaling traffic light trigger for IDs {sorted(group.ids)}")

    def update_traffic_light_trigger_scaling(self, mouse_pos: Tuple[int, int]) -> None:
        """Update trigger radius while scaling a traffic light group."""
        if not self.scaling_traffic_light_trigger or not self._traffic_light_scaling_group:
            return

        group = self._traffic_light_scaling_group
        if not group.has_trigger():
            self.stop_traffic_light_trigger_scaling()
            return

        delta_y = self.traffic_light_scale_start_pos[1] - mouse_pos[1]
        new_radius = self.traffic_light_scale_start_radius + (delta_y * 0.1)
        new_radius = max(MIN_PERSONAL_TRIGGER_RADIUS, min(new_radius, 100.0))
        group.trigger_radius = new_radius
        self._cache_traffic_light_trigger_payload(group)

    def stop_traffic_light_trigger_scaling(self) -> None:
        """End any active traffic light trigger scaling."""
        if not self.scaling_traffic_light_trigger:
            return

        if self._traffic_light_scaling_group and self._traffic_light_scaling_group.has_trigger():
            print(
                f"Stopped scaling traffic light trigger for IDs "
                f"{sorted(self._traffic_light_scaling_group.ids)} "
                f"(radius {self._traffic_light_scaling_group.trigger_radius:.2f} m)"
            )
            group = self._traffic_light_scaling_group
            start_radius = getattr(self, "traffic_light_scale_start_radius", None)
            center_snapshot = group.trigger_center or {}
            cached_center, _, resolved_key = self._get_traffic_light_trigger_data(group=group)
            if not center_snapshot and cached_center:
                center_snapshot = dict(cached_center)
            key = self._traffic_light_trigger_key(group=group) or resolved_key
            if center_snapshot and start_radius is not None and abs(group.trigger_radius - start_radius) > 1e-4:
                selection = {
                    'kind': 'traffic_light',
                    'group': group,
                    'key': key,
                }
                command = SetPersonalTriggerCommand(
                    self,
                    selection,
                    dict(center_snapshot),
                    group.trigger_radius,
                    old_center=copy.deepcopy(center_snapshot),
                    old_radius=start_radius,
                )
                editor = getattr(self, "editor", None)
                if editor:
                    editor.execute_command(command)
                else:
                    command.execute()
            self._cache_traffic_light_trigger_payload(group)
            self._mark_last_visible_traffic_light_trigger(group)
        self.scaling_traffic_light_trigger = False
        self._traffic_light_scaling_group = None

    def delete_traffic_light_trigger(
        self, group: Optional[TrafficLightGroupData] = None
    ) -> bool:
        """Remove the trigger associated with the given traffic light group."""
        target_group = group or self.selected_traffic_light_group
        if not target_group or not target_group.has_trigger():
            print("No traffic light trigger available to delete.")
            return False

        if self.scaling_traffic_light_trigger and self._traffic_light_scaling_group is target_group:
            self.stop_traffic_light_trigger_scaling()

        self._delete_traffic_light_trigger_data(group=target_group)
        self.traffic_light_sequences.pop(frozenset(target_group.ids), None)
        target_group.sequence = []

        # Update snapshot to prevent restoration of deleted trigger
        for snapshot in self._traffic_light_group_snapshots:
            # Check if this snapshot matches the target group
            ids_match = (snapshot.get("ids_live") == target_group.ids or
                         snapshot.get("reference_ids") == target_group.reference_ids)
            fp_match = (snapshot.get("fingerprint") == target_group.location_fingerprint
                        if target_group.location_fingerprint else False)

            if ids_match or fp_match:
                # Clear trigger and sequence from snapshot
                snapshot["trigger"] = None
                snapshot["sequence"] = None
                break

        print(f"Deleted traffic light trigger for IDs {sorted(target_group.ids)}")
        if (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'traffic_light'
                and self.selected_personal_trigger.get('group') is target_group):
            self.clear_personal_trigger_selection()
        return True

    def _ensure_pedestrian_trigger(self, pedestrian_id: int) -> bool:
        """Create a trigger entry for the provided pedestrian if missing."""
        if pedestrian_id in self.pedestrian_trigger_radii:
            return True

        # Get pedestrian actor
        pedestrian = None
        for actor in self.spawned_vehicles:
            if actor.id == pedestrian_id and actor.is_alive:
                pedestrian = actor
                break

        if not pedestrian:
            print("Warning: Unable to find pedestrian actor.")
            return False

        # Get pedestrian location as trigger center
        location = pedestrian.get_location()
        self.pedestrian_trigger_centers[pedestrian_id] = {
            'x': float(location.x),
            'y': float(location.y),
            'z': float(location.z),
        }
        self.pedestrian_trigger_radii[pedestrian_id] = DEFAULT_PERSONAL_TRIGGER_RADIUS  # Default radius

        print(
            f"Created pedestrian trigger for ID {pedestrian_id} at "
            f"({location.x:.2f}, {location.y:.2f}, {location.z:.2f}) "
            f"with radius {DEFAULT_PERSONAL_TRIGGER_RADIUS:.1f} m"
        )

        # Refresh info panel if showing this pedestrian
        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if panel and panel.object_type == 'pedestrian' and panel.visible:
            current = getattr(panel, 'selected_object', None)
            if current and getattr(current, 'id', None) == pedestrian_id:
                screen_width = getattr(self, "screen_width", 1280)
                screen_height = getattr(self, "screen_height", 720)
                panel.show(pedestrian, 'pedestrian', screen_width, screen_height)

        return True

    def start_pedestrian_trigger_scaling(self, pedestrian_id: int, mouse_pos: tuple) -> None:
        """Begin scaling operation for the selected pedestrian's trigger."""
        if pedestrian_id not in self.pedestrian_trigger_radii:
            return

        self.scaling_pedestrian_trigger = True
        self._pedestrian_scaling_id = pedestrian_id
        self.pedestrian_trigger_scale_start_pos = mouse_pos
        self.pedestrian_trigger_scale_start_radius = float(self.pedestrian_trigger_radii[pedestrian_id])
        print(f"Started scaling pedestrian trigger for ID {pedestrian_id}")

    def update_pedestrian_trigger_scaling(self, mouse_pos: tuple) -> None:
        """Update trigger radius while scaling a pedestrian trigger."""
        if not self.scaling_pedestrian_trigger or self._pedestrian_scaling_id is None:
            return

        pedestrian_id = self._pedestrian_scaling_id
        if pedestrian_id not in self.pedestrian_trigger_radii:
            self.stop_pedestrian_trigger_scaling()
            return

        delta_y = self.pedestrian_trigger_scale_start_pos[1] - mouse_pos[1]
        new_radius = self.pedestrian_trigger_scale_start_radius + (delta_y * 0.1)
        new_radius = max(MIN_PERSONAL_TRIGGER_RADIUS, new_radius)
        self.pedestrian_trigger_radii[pedestrian_id] = new_radius

    def stop_pedestrian_trigger_scaling(self) -> None:
        """End any active pedestrian trigger scaling."""
        if not self.scaling_pedestrian_trigger:
            return

        target_id = self._pedestrian_scaling_id
        radius = self.pedestrian_trigger_radii.get(target_id) if target_id is not None else None
        if target_id is not None and radius is not None:
            print(
                f"Stopped scaling pedestrian trigger for ID "
                f"{target_id} "
                f"(radius {radius:.2f} m)"
            )
            start_radius = getattr(self, "pedestrian_trigger_scale_start_radius", None)
            if start_radius is not None and abs(radius - start_radius) > 1e-4:
                center_snapshot = self.pedestrian_trigger_centers.get(target_id)
                if center_snapshot is None:
                    self._ensure_pedestrian_trigger(target_id)
                    center_snapshot = self.pedestrian_trigger_centers.get(target_id)
                selection = {'kind': 'pedestrian', 'id': target_id}
                command = SetPersonalTriggerCommand(
                    self,
                    selection,
                    dict(center_snapshot) if center_snapshot else None,
                    radius,
                    old_center=copy.deepcopy(center_snapshot) if center_snapshot else None,
                    old_radius=start_radius,
                )
                if getattr(self, "editor", None):
                    self.editor.execute_command(command)
                else:
                    command.execute()
        self.scaling_pedestrian_trigger = False
        self._pedestrian_scaling_id = None

    def delete_pedestrian_trigger(self, pedestrian_id: int) -> bool:
        """Remove the trigger associated with the given pedestrian."""
        if pedestrian_id not in self.pedestrian_trigger_radii:
            print("No pedestrian trigger available to delete.")
            return False

        if self.scaling_pedestrian_trigger and self._pedestrian_scaling_id == pedestrian_id:
            self.stop_pedestrian_trigger_scaling()

        self.pedestrian_trigger_centers.pop(pedestrian_id, None)
        self.pedestrian_trigger_radii.pop(pedestrian_id, None)
        print(f"Deleted pedestrian trigger for ID {pedestrian_id}")
        if (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'pedestrian'
                and self.selected_personal_trigger.get('id') == pedestrian_id):
            self.clear_personal_trigger_selection()
        return True

    def _ensure_vehicle_trigger(self, vehicle_id: int) -> bool:
        """Create a trigger entry for the provided NPC vehicle if missing."""
        if vehicle_id in self.vehicle_trigger_radii:
            return True

        vehicle_actor = self.get_spawned_vehicle(vehicle_id)
        if not vehicle_actor or not vehicle_actor.is_alive:
            print("Warning: Unable to find vehicle actor.")
            return False
        if vehicle_actor.type_id.startswith('walker.'):
            return False
        if self.is_ego_vehicle(vehicle_id):
            return False

        location = vehicle_actor.get_location()
        self.vehicle_trigger_centers[vehicle_id] = {
            'x': float(location.x),
            'y': float(location.y),
            'z': float(location.z),
        }
        self.vehicle_trigger_radii[vehicle_id] = DEFAULT_PERSONAL_TRIGGER_RADIUS  # Default radius

        print(
            f"Created vehicle trigger for ID {vehicle_id} at "
            f"({location.x:.2f}, {location.y:.2f}, {location.z:.2f}) "
            f"with radius {DEFAULT_PERSONAL_TRIGGER_RADIUS:.1f} m"
        )

        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if panel and panel.object_type == 'vehicle' and panel.visible:
            current = getattr(panel, 'selected_object', None)
            if current and getattr(current, 'id', None) == vehicle_id:
                screen_width = getattr(self, "screen_width", 1280)
                screen_height = getattr(self, "screen_height", 720)
                panel.show(vehicle_actor, 'vehicle', screen_width, screen_height)

        return True

    def start_vehicle_trigger_scaling(self, vehicle_id: int, mouse_pos: tuple) -> None:
        """Begin scaling operation for the selected vehicle's trigger."""
        if vehicle_id not in self.vehicle_trigger_radii:
            return

        self.scaling_vehicle_trigger = True
        self._vehicle_scaling_id = vehicle_id
        self.vehicle_trigger_scale_start_pos = mouse_pos
        self.vehicle_trigger_scale_start_radius = float(self.vehicle_trigger_radii[vehicle_id])
        print(f"Started scaling vehicle trigger for ID {vehicle_id}")

    def update_vehicle_trigger_scaling(self, mouse_pos: tuple) -> None:
        """Update trigger radius while scaling a vehicle trigger."""
        if not self.scaling_vehicle_trigger or self._vehicle_scaling_id is None:
            return

        vehicle_id = self._vehicle_scaling_id
        if vehicle_id not in self.vehicle_trigger_radii:
            self.stop_vehicle_trigger_scaling()
            return

        delta_y = self.vehicle_trigger_scale_start_pos[1] - mouse_pos[1]
        new_radius = self.vehicle_trigger_scale_start_radius + (delta_y * 0.1)
        new_radius = max(MIN_PERSONAL_TRIGGER_RADIUS, new_radius)
        self.vehicle_trigger_radii[vehicle_id] = new_radius

    def stop_vehicle_trigger_scaling(self) -> None:
        """End any active vehicle trigger scaling."""
        if not self.scaling_vehicle_trigger:
            return

        target_id = self._vehicle_scaling_id
        radius = self.vehicle_trigger_radii.get(target_id) if target_id is not None else None
        if target_id is not None and radius is not None:
            print(
                f"Stopped scaling vehicle trigger for ID "
                f"{target_id} "
                f"(radius {radius:.2f} m)"
            )
            start_radius = getattr(self, "vehicle_trigger_scale_start_radius", None)
            if start_radius is not None and abs(radius - start_radius) > 1e-4:
                center_snapshot = self.vehicle_trigger_centers.get(target_id)
                if center_snapshot is None:
                    self._ensure_vehicle_trigger(target_id)
                    center_snapshot = self.vehicle_trigger_centers.get(target_id)
                selection = {'kind': 'vehicle', 'id': target_id}
                command = SetPersonalTriggerCommand(
                    self,
                    selection,
                    dict(center_snapshot) if center_snapshot else None,
                    radius,
                    old_center=copy.deepcopy(center_snapshot) if center_snapshot else None,
                    old_radius=start_radius,
                )
                if getattr(self, "editor", None):
                    self.editor.execute_command(command)
                else:
                    command.execute()
        self.scaling_vehicle_trigger = False
        self._vehicle_scaling_id = None

    def delete_vehicle_trigger(self, vehicle_id: int) -> bool:
        """Remove the trigger associated with the given vehicle."""
        if vehicle_id not in self.vehicle_trigger_radii:
            print("No vehicle trigger available to delete.")
            return False

        if self.scaling_vehicle_trigger and self._vehicle_scaling_id == vehicle_id:
            self.stop_vehicle_trigger_scaling()

        self.vehicle_trigger_centers.pop(vehicle_id, None)
        self.vehicle_trigger_radii.pop(vehicle_id, None)
        print(f"Deleted vehicle trigger for ID {vehicle_id}")
        if (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'vehicle'
                and self.selected_personal_trigger.get('id') == vehicle_id):
            self.clear_personal_trigger_selection()
        return True

    def _cache_traffic_light_sequence(self, group: Optional[TrafficLightGroupData]) -> None:
        if not group or not group.ids:
            return
        key = frozenset(group.ids)
        if group.sequence:
            self.traffic_light_sequences[key] = copy.deepcopy(group.sequence)
        else:
            self.traffic_light_sequences.pop(key, None)

    def _normalize_traffic_light_sequence(
        self,
        sequence: Optional[Iterable[Dict[str, Union[str, float, int]]]],
        *,
        coerce_color: bool = False,
    ) -> List[Dict[str, Union[str, float, int]]]:
        """Normalize a traffic light sequence payload to the expected dict format."""
        if not sequence:
            return []
        return [
            {
                'color': str(entry.get('color', 'Red')) if coerce_color else entry.get('color', 'Red'),
                'duration_s': float(entry.get('duration_s', 0.0)),
                'duration_ticks': int(entry.get('duration_ticks', 0)),
            }
            for entry in sequence
        ]

    def _normalize_traffic_light_trigger_entries(self, trigger_entries):
        """Normalize legacy traffic light trigger payloads in-place."""
        if not isinstance(trigger_entries, list):
            return trigger_entries
        for entry in trigger_entries:
            if not isinstance(entry, dict):
                continue
            if 'ids_live' not in entry and 'ids' in entry:
                legacy_ids = entry.pop('ids')
                entry['ids_live'] = legacy_ids
                entry.setdefault('ids_reference', list(legacy_ids))
        return trigger_entries

    def _normalize_traffic_light_fingerprint(
        self,
        fingerprint: Optional[Iterable[Tuple[int, int, int]]],
    ) -> Optional[Tuple[Tuple[int, int, int], ...]]:
        if not fingerprint:
            return None
        try:
            return tuple((int(pt[0]), int(pt[1]), int(pt[2])) for pt in fingerprint)
        except Exception:
            return None

    def _traffic_light_trigger_key(
        self,
        group: Optional[TrafficLightGroupData] = None,
        *,
        fingerprint: Optional[Iterable[Tuple[int, int, int]]] = None,
        ids: Optional[Iterable[int]] = None,
    ) -> Optional[Tuple[str, Tuple]]:
        """Return a stable key for storing traffic light trigger data."""
        normalized_fp = self._normalize_traffic_light_fingerprint(fingerprint)
        if normalized_fp is None and group is not None:
            if group.location_fingerprint is None:
                group.location_fingerprint = self._compute_traffic_light_fingerprint(group.lights)
            normalized_fp = self._normalize_traffic_light_fingerprint(group.location_fingerprint)
        if normalized_fp:
            return ('fp', normalized_fp)

        ids_source: Optional[Iterable[int]] = ids
        if ids_source is None and group is not None:
            if group.reference_ids:
                ids_source = group.reference_ids
            else:
                ids_source = group.ids
        if ids_source:
            try:
                ids_tuple = tuple(sorted(int(value) for value in ids_source))
            except Exception:
                ids_tuple = None
            if ids_tuple:
                return ('ids', ids_tuple)
        return None

    def _get_traffic_light_trigger_data(
        self,
        *,
        key: Optional[Tuple[str, Tuple]] = None,
        group: Optional[TrafficLightGroupData] = None,
    ) -> Tuple[Optional[Dict[str, float]], Optional[float], Optional[Tuple[str, Tuple]]]:
        resolved_key = key or self._traffic_light_trigger_key(group=group)
        if not resolved_key:
            return None, None, None
        center = self.traffic_light_trigger_centers.get(resolved_key)
        radius = self.traffic_light_trigger_radii.get(resolved_key)
        if center and radius is not None and group:
            group.trigger_center = dict(center)
            group.trigger_radius = float(radius)
        return center, radius, resolved_key

    def _set_traffic_light_trigger_data(
        self,
        center: Dict[str, float],
        radius: float,
        *,
        key: Optional[Tuple[str, Tuple]] = None,
        group: Optional[TrafficLightGroupData] = None,
        mark_visible: bool = True,
    ) -> Optional[Tuple[str, Tuple]]:
        resolved_key = key or self._traffic_light_trigger_key(group=group)
        if not resolved_key:
            return None
        self.traffic_light_trigger_centers[resolved_key] = dict(center)
        self.traffic_light_trigger_radii[resolved_key] = float(radius)
        if group:
            group.trigger_center = dict(center)
            group.trigger_radius = float(radius)
        if mark_visible:
            self._last_visible_traffic_light_trigger_key = resolved_key
        return resolved_key

    def _delete_traffic_light_trigger_data(
        self,
        *,
        key: Optional[Tuple[str, Tuple]] = None,
        group: Optional[TrafficLightGroupData] = None,
    ) -> bool:
        resolved_key = key or self._traffic_light_trigger_key(group=group)
        if not resolved_key:
            return False
        removed = False
        if resolved_key in self.traffic_light_trigger_centers or resolved_key in self.traffic_light_trigger_radii:
            self.traffic_light_trigger_centers.pop(resolved_key, None)
            self.traffic_light_trigger_radii.pop(resolved_key, None)
            removed = True
        if self._last_visible_traffic_light_trigger_key == resolved_key:
            self._last_visible_traffic_light_trigger_key = None
        if group:
            group.trigger_center = None
            group.trigger_radius = None
        return removed

    def _find_traffic_light_group_by_key(
        self,
        key: Optional[Tuple[str, Tuple]],
    ) -> Optional[TrafficLightGroupData]:
        if not key:
            return None
        for group in self.traffic_light_groups:
            if self._traffic_light_trigger_key(group=group) == key:
                return group
        return None

    # Backwards-compatible wrappers (legacy calls still reference these)
    def _cache_traffic_light_trigger_payload(self, group: Optional[TrafficLightGroupData]) -> None:
        """Legacy helper retained for compatibility with existing call sites."""
        if not group or not group.has_trigger():
            return
        center = group.trigger_center or {}
        radius = group.trigger_radius
        if center and radius is not None:
            self._set_traffic_light_trigger_data(center, radius, group=group, mark_visible=False)

    def _evict_traffic_light_trigger_cache(self, group: Optional[TrafficLightGroupData], *, key=None) -> None:
        """Legacy helper retained for compatibility with existing call sites."""
        if key is None:
            key = self._traffic_light_trigger_key(group=group)
        if key:
            self._delete_traffic_light_trigger_data(key=key, group=None)

    def _mark_last_visible_traffic_light_trigger(self, group: Optional[TrafficLightGroupData], *, key=None) -> None:
        """Legacy helper retained for compatibility with existing call sites."""
        resolved_key = key or self._traffic_light_trigger_key(group=group)
        if resolved_key:
            self._last_visible_traffic_light_trigger_key = resolved_key

    def select_traffic_light_group(self, group: TrafficLightGroupData) -> bool:
        """Select a traffic light group and log its members."""
        if not group or not group.lights:
            return False

        alive_lights = []
        for light in group.lights:
            try:
                if light and light.is_alive:
                    alive_lights.append(light)
            except Exception:
                continue

        if not alive_lights:
            return False

        # Reuse existing group if it still matches after filtering dead lights
        if len(alive_lights) != len(group.lights):
            group.lights = alive_lights
            group.ids = {light.id for light in alive_lights}
            group.location_fingerprint = self._compute_traffic_light_fingerprint(group.lights)
            group.center_location = self._compute_traffic_light_group_centroid(group.lights)
            group.cached_size = len(group.lights)
            self._rebuild_traffic_light_group_lookup()

        if self.selected_traffic_light_group and group.ids == self.selected_traffic_light_group.ids:
            self._update_traffic_light_menu_anchor(group)
            return True

        self.clear_vehicle_selection(clear_traffic_light=False)
        if self.scaling_traffic_light_trigger and self._traffic_light_scaling_group is not group:
            self.stop_traffic_light_trigger_scaling()
        if (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'traffic_light'
                and self.selected_personal_trigger.get('group') is not group):
            self.clear_personal_trigger_selection()
        self.selected_traffic_light_group = group
        self._selected_traffic_light_group_ids = set(group.ids)
        if group.location_fingerprint is None:
            group.location_fingerprint = self._compute_traffic_light_fingerprint(group.lights)
        if group.center_location is None:
            group.center_location = self._compute_traffic_light_group_centroid(group.lights)
        group.cached_size = len(group.lights)
        self._selected_traffic_light_group_fingerprint = group.location_fingerprint
        self._update_traffic_light_menu_anchor(group)
        self.traffic_light_menu_hidden_for_camera_pan = False
        self.traffic_light_overlays_hidden_for_camera_pan = False

        center_snapshot, radius_snapshot, key = self._get_traffic_light_trigger_data(group=group)
        if center_snapshot and radius_snapshot is not None:
            group.trigger_center = dict(center_snapshot)
            group.trigger_radius = float(radius_snapshot)
            if key:
                self._last_visible_traffic_light_trigger_key = key
        else:
            # Selecting a group without a trigger should clear any previously visible trigger marker.
            group.trigger_center = None
            group.trigger_radius = None
            self._last_visible_traffic_light_trigger_key = None

        # Show info panel for traffic light
        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if panel:
            screen_width = getattr(self, "screen_width", 1280)
            screen_height = getattr(self, "screen_height", 720)
            panel.show(group, 'traffic_light', screen_width, screen_height)

        try:
            reference_light = group.reference_light
            if reference_light:
                location = reference_light.get_transform().location
                ids_str = ", ".join(str(light.id) for light in group.lights)
                print(f"Selected {len(group.lights)} traffic lights [{ids_str}] near ({location.x:.2f}, {location.y:.2f})")
                return True
        except Exception:
            pass

        ids_str = ", ".join(str(light.id) for light in group.lights)
        print(f"Selected {len(group.lights)} traffic lights [{ids_str}]")
        return True

    def clear_traffic_light_selection(self) -> None:
        """Clear any active traffic light selection without stopping active operations."""
        # NOTE: Don't stop scaling here - let it complete like ego vehicle triggers
        # The scaling operation will be stopped explicitly on mouse button release
        self.selected_traffic_light_group = None
        self._selected_traffic_light_group_ids.clear()
        self._selected_traffic_light_group_fingerprint = None
        self._traffic_light_connector_debug_signature = None
        self.traffic_light_menu_position = None
        self.traffic_light_menu_hidden_for_camera_pan = False
        self.traffic_light_overlays_hidden_for_camera_pan = False

        # Hide info panel if it's showing a traffic light
        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if panel and panel.visible and panel.object_type == 'traffic_light':
            panel.hide()
        if (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'traffic_light'):
            self.clear_personal_trigger_selection()
        self._last_visible_traffic_light_trigger_key = None
    
    def spawn_vehicle_at_marker(self, vehicle_type, coordinates, *, role="npc"):
        """Spawn a vehicle at the given coordinates"""
        try:
            if role == "ego" and self.is_ego_vehicle_active():
                print("An ego vehicle already exists. Delete the current ego vehicle before placing a new one.")
                return False

            blueprint_library = self.world.get_blueprint_library()
            vehicle_bp = blueprint_library.find(vehicle_type)

            # Raycast ground height and add small buffer so actors rest on uneven terrain
            base_location = carla.Location(
                coordinates['x'],
                coordinates['y'],
                coordinates.get('z', 0.0),
            )
            debug_mode = getattr(self, 'debug_raycast', False)
            cached_map = self._get_cached_map(refresh=False)
            ground_height = get_ground_height(
                self.world,
                base_location,
                debug=debug_mode,
                cached_map=cached_map,
            )
            spawn_height = ground_height + 0.2

            # Set up spawn transform using raycast height
            location = carla.Location(coordinates['x'], coordinates['y'], spawn_height)

            # Use lane direction if available (snapped to lane)
            if coordinates.get('snapped', False) and 'yaw' in coordinates:
                rotation = carla.Rotation(pitch=0.0, yaw=coordinates['yaw'], roll=0.0)
                spawn_type = "lane-aligned"
            else:
                rotation = carla.Rotation()
                spawn_type = "default orientation"

            transform = carla.Transform(location, rotation)

            # Create and execute spawn vehicle command
            command = SpawnVehicleCommand(self, vehicle_type, transform, role=role)
            success = self.editor.execute_command(command)

            if success:
                # Update the command with the spawned vehicle ID for future reference
                if command.spawned_vehicle:
                    command.original_vehicle_id = command.spawned_vehicle.id
                print(f"Spawned {vehicle_type} at ({coordinates['x']:.2f}, {coordinates['y']:.2f}, {spawn_height:.2f}) - {spawn_type} (physics disabled)")
                return True
            else:
                print(f"Failed to spawn {vehicle_type} - location might be blocked")
                return False

        except Exception as e:
            print(f"Error spawning vehicle: {e}")
            return False

    def render_selected_actor_highlight(self, screen):
        """Render a green highlight around the selected pedestrian."""
        if (not self.selected_vehicle or
                not self.selected_vehicle_is_pedestrian or
                not self.selected_vehicle.is_alive or
                (self.editor and self.editor.scenario_running) or
                self.actor_overlays_hidden_for_camera_pan):
            return

        try:
            location = self.selected_vehicle.get_location()
            screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                location.x,
                location.y,
                location.z + 1.0
            )

            if screen_pos.get('success'):
                center = (int(screen_pos['x']), int(screen_pos['y']))
                highlight_color = (100, 255, 100)
                radius = 25
                thickness = 3
                pygame.draw.circle(screen, highlight_color, center, radius, thickness)
        except Exception as e:
            print(f"Error rendering pedestrian highlight: {e}")

    def render_selected_traffic_light_connectors(self, screen):
        """Draw connectors from the selected stopline group to its traffic lights."""
        group = self.selected_traffic_light_group
        if not group:
            self._last_connector_debug_signature = None
            return

        if self.traffic_light_overlays_hidden_for_camera_pan:
            self._last_connector_debug_signature = None
            return

        connector_color = (60, 150, 255)
        lights_to_draw = group.lights
        drawn_lines: List[Tuple[int, Tuple[int, int], Tuple[int, int]]] = []
        failure_messages: List[str] = []

        for light in lights_to_draw:
            try:
                rectangle_data = self._get_traffic_light_rectangle_points(light)
            except Exception as exc:
                failure_messages.append(f"Light {light.id}: rectangle error {exc}")
                continue

            if not rectangle_data:
                failure_messages.append(f"Light {light.id}: no trigger rectangle data")
                continue

            corners, trigger_center = rectangle_data
            if trigger_center is not None:
                stop_pos = trigger_center
            elif corners:
                stop_pos = carla.Location(
                    sum(corner.x for corner in corners) / len(corners),
                    sum(corner.y for corner in corners) / len(corners),
                    sum(corner.z for corner in corners) / len(corners),
                )
            else:
                failure_messages.append(f"Light {light.id}: trigger rectangle empty")
                continue

            stop_screen = self.coordinate_detector.world_to_screen_coordinates(
                stop_pos.x, stop_pos.y, stop_pos.z
            )
            if not stop_screen.get("success"):
                failure_messages.append(f"Light {light.id}: stopline projection failed")
                continue

            try:
                light_location = light.get_transform().location
            except Exception as exc:
                failure_messages.append(f"Light {light.id}: transform error {exc}")
                continue

            light_screen = self.coordinate_detector.world_to_screen_coordinates(
                light_location.x, light_location.y, light_location.z
            )
            if not light_screen.get("success"):
                failure_messages.append(f"Light {light.id}: mesh projection failed")
                continue

            start = (int(stop_screen["x"]), int(stop_screen["y"]))
            end = (int(light_screen["x"]), int(light_screen["y"]))

            pygame.draw.line(screen, connector_color, start, end, 2)
            pygame.draw.circle(screen, connector_color, end, 4)
            drawn_lines.append((light.id, start, end))

        drawn_ids = tuple(sorted(light_id for light_id, _, _ in drawn_lines))
        failures_sorted = tuple(sorted(failure_messages))
        debug_signature = (drawn_ids, failures_sorted)

        if debug_signature != self._last_connector_debug_signature:
            if drawn_lines:
                print(
                    f"[TrafficLines] Drawing {len(drawn_lines)} connector(s) for group {sorted(group.ids)}"
                )
                for light_id, start, end in drawn_lines:
                    print(
                        f"  Light {light_id}: stopline screen {start} -> mesh screen {end}"
                    )
            else:
                print(
                    f"[TrafficLines] No connectors drawn for group {sorted(group.ids)}"
                )
            for message in failure_messages:
                print(f"  {message}")
            self._last_connector_debug_signature = debug_signature

    def _get_single_light_screen_polygon(
        self, light: carla.TrafficLight
    ) -> Optional[Tuple[List[Tuple[float, float]], Optional[Tuple[float, float]]]]:
        rectangle_data = self._get_traffic_light_rectangle_points(light)
        if not rectangle_data:
            return None

        corners, _ = rectangle_data
        if not corners:
            return None

        projected: List[Tuple[float, float]] = []
        for corner in corners:
            screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                corner.x,
                corner.y,
                corner.z,
            )
            if not screen_pos.get('success'):
                return None
            projected.append((screen_pos['x'], screen_pos['y']))

        if not projected:
            return None

        hull = self._compute_convex_hull(projected)
        if not hull:
            return None

        center = (
            sum(pt[0] for pt in hull) / len(hull),
            sum(pt[1] for pt in hull) / len(hull),
        )
        return hull, center

    def _get_traffic_light_rectangle_points(
        self, traffic_light: carla.TrafficLight
    ) -> Optional[Tuple[List[carla.Location], Optional[carla.Location]]]:
        """Return world-space corners and center for the traffic light trigger rectangle."""
        if not traffic_light:
            return None
        cached = self._traffic_light_rectangles.get(traffic_light.id)
        if cached:
            return cached

        trigger_volume = getattr(traffic_light, "trigger_volume", None)
        if trigger_volume is None:
            return None

        try:
            transform = traffic_light.get_transform()
        except Exception:
            return None

        extent = trigger_volume.extent
        if extent is None:
            return None

        trigger_transform = carla.Transform(trigger_volume.location, trigger_volume.rotation)

        local_corners = [
            carla.Location(+extent.x, +extent.y, 0.0),
            carla.Location(-extent.x, +extent.y, 0.0),
            carla.Location(-extent.x, -extent.y, 0.0),
            carla.Location(+extent.x, -extent.y, 0.0),
        ]

        world_corners: List[carla.Location] = []
        for corner in local_corners:
            try:
                trigger_point = trigger_transform.transform(corner)
                world_point = transform.transform(trigger_point)
                world_corners.append(world_point)
            except Exception:
                return None

        try:
            trigger_center = transform.transform(trigger_transform.transform(carla.Location()))
        except Exception:
            trigger_center = None

        result = (world_corners, trigger_center)
        self._traffic_light_rectangles[traffic_light.id] = result
        return result

    def _get_traffic_light_screen_polygon(
        self, traffic_light: carla.TrafficLight
    ) -> Optional[Tuple[List[Tuple[float, float]], Optional[Tuple[float, float]]]]:
        """Project the trigger rectangle to screen space, returning polygon points and center."""
        rectangle_data = self._get_traffic_light_rectangle_points(traffic_light)
        if not rectangle_data:
            return None

        world_corners, world_center = rectangle_data
        screen_points: List[Tuple[float, float]] = []

        for corner in world_corners:
            screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                corner.x, corner.y, corner.z
            )
            if not screen_pos.get('success'):
                return None
            screen_points.append((screen_pos['x'], screen_pos['y']))

        screen_center: Optional[Tuple[float, float]] = None
        if world_center is not None:
            center_screen = self.coordinate_detector.world_to_screen_coordinates(
                world_center.x, world_center.y, world_center.z
            )
            if center_screen.get('success'):
                screen_center = (center_screen['x'], center_screen['y'])

        return screen_points, screen_center

    @staticmethod
    def _is_point_inside_polygon(point: Tuple[float, float], polygon: List[Tuple[float, float]]) -> bool:
        """Return True if the 2D point lies inside the given polygon (ray casting)."""
        x, y = point
        inside = False
        n = len(polygon)
        if n < 3:
            return False

        px1, py1 = polygon[0]
        for i in range(1, n + 1):
            px2, py2 = polygon[i % n]
            denominator = (py2 - py1)
            if ((py1 > y) != (py2 > y)) and (
                x < (px2 - px1) * (y - py1) / (denominator if abs(denominator) > 1e-8 else (1e-8)) + px1
            ):
                inside = not inside
            px1, py1 = px2, py2
        return inside

    def _get_traffic_light_group_screen_polygon(
        self, group: TrafficLightGroupData
    ) -> Optional[Tuple[List[Tuple[float, float]], Optional[Tuple[float, float]]]]:
        """Return a convex hull polygon covering all lights in the group."""
        all_points: List[Tuple[float, float]] = []

        for light in group.lights:
            rectangle_data = self._get_traffic_light_rectangle_points(light)
            if not rectangle_data:
                continue
            corners, _ = rectangle_data
            for corner in corners:
                screen_pos = self.coordinate_detector.world_to_screen_coordinates(
                    corner.x, corner.y, corner.z
                )
                if screen_pos.get('success'):
                    all_points.append((screen_pos['x'], screen_pos['y']))

        if not all_points:
            return None

        hull = self._compute_convex_hull(all_points)
        if not hull:
            return None

        center = (
            sum(pt[0] for pt in hull) / len(hull),
            sum(pt[1] for pt in hull) / len(hull),
        )
        return hull, center

    @staticmethod
    def _compute_convex_hull(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]:
        """Compute convex hull (Monotonic chain) for the provided 2D points."""
        if not points:
            return []

        unique_points = sorted(set((float(x), float(y)) for x, y in points))
        if len(unique_points) <= 2:
            return unique_points

        def cross(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        lower: List[Tuple[float, float]] = []
        for p in unique_points:
            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
                lower.pop()
            lower.append(p)

        upper: List[Tuple[float, float]] = []
        for p in reversed(unique_points):
            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
                upper.pop()
            upper.append(p)

        hull = lower[:-1] + upper[:-1]
        return hull

    @staticmethod
    def _is_point_near_segment(
        point: Tuple[float, float],
        segment_start: Tuple[float, float],
        segment_end: Tuple[float, float],
        tolerance: float = 6.0,
    ) -> bool:
        """Return True if the point is within tolerance of the line segment."""
        px, py = point
        x1, y1 = segment_start
        x2, y2 = segment_end

        dx = x2 - x1
        dy = y2 - y1
        segment_length_sq = dx * dx + dy * dy
        if segment_length_sq == 0:
            distance_sq = (px - x1) ** 2 + (py - y1) ** 2
            return distance_sq <= tolerance * tolerance

        t = ((px - x1) * dx + (py - y1) * dy) / segment_length_sq
        t = max(0.0, min(1.0, t))
        closest_x = x1 + t * dx
        closest_y = y1 + t * dy
        distance_sq = (px - closest_x) ** 2 + (py - closest_y) ** 2
        return distance_sq <= tolerance * tolerance

    def render_selected_traffic_light_connectors(self, screen):
        """Draw connectors from the selected stopline group to its traffic lights."""
        group = self.selected_traffic_light_group
        if not group:
            self._traffic_light_connector_debug_signature = None
            return

        if self.traffic_light_overlays_hidden_for_camera_pan:
            self._traffic_light_connector_debug_signature = None
            return

        connector_color = (60, 150, 255)
        drawn_lines: List[Tuple[int, Tuple[int, int], Tuple[int, int]]] = []
        failure_messages: List[str] = []

        for light in group.lights:
            light_id = getattr(light, "id", None)
            try:
                rectangle_data = self._get_traffic_light_rectangle_points(light)
            except Exception as exc:
                failure_messages.append(f"Light {light_id}: rectangle error {exc}")
                continue

            if not rectangle_data:
                failure_messages.append(f"Light {light_id}: no trigger rectangle data")
                continue

            corners, trigger_center = rectangle_data
            if trigger_center is not None:
                stop_pos = trigger_center
            elif corners:
                stop_pos = carla.Location(
                    sum(corner.x for corner in corners) / len(corners),
                    sum(corner.y for corner in corners) / len(corners),
                    sum(corner.z for corner in corners) / len(corners),
                )
            else:
                failure_messages.append(f"Light {light_id}: trigger rectangle empty")
                continue

            stop_screen = self.coordinate_detector.world_to_screen_coordinates(
                stop_pos.x, stop_pos.y, stop_pos.z
            )
            if not stop_screen.get("success"):
                failure_messages.append(f"Light {light_id}: stopline projection failed")
                continue

            try:
                light_location = light.get_transform().location
            except Exception as exc:
                failure_messages.append(f"Light {light_id}: transform error {exc}")
                continue

            light_screen = self.coordinate_detector.world_to_screen_coordinates(
                light_location.x,
                light_location.y,
                light_location.z,
            )
            if not light_screen.get("success"):
                failure_messages.append(f"Light {light_id}: mesh projection failed")
                continue

            start = (int(stop_screen["x"]), int(stop_screen["y"]))
            end = (int(light_screen["x"]), int(light_screen["y"]))

            pygame.draw.line(screen, connector_color, start, end, 2)
            pygame.draw.circle(screen, connector_color, end, 4)
            drawn_lines.append((light_id, start, end))

        drawn_ids = tuple(sorted(light_id for light_id, _, _ in drawn_lines if light_id is not None))
        failures_sorted = tuple(sorted(failure_messages))
        debug_signature = (drawn_ids, failures_sorted)

        if debug_signature != self._traffic_light_connector_debug_signature:
            if drawn_lines:
                print(
                    f"[TrafficLines] Drawing {len(drawn_lines)} connector(s) for group {sorted(group.ids)}"
                )
                for light_id, start, end in drawn_lines:
                    print(
                        f"  Light {light_id}: stopline screen {start} -> mesh screen {end}"
                    )
            else:
                print(
                    f"[TrafficLines] No connectors drawn for group {sorted(group.ids)}"
                )
            for message in failure_messages:
                print(f"  {message}")
            self._traffic_light_connector_debug_signature = debug_signature


    def render_traffic_light_markers(self, screen):
        """Draw small markers above each traffic light to make them discoverable."""
        if self.traffic_light_overlays_hidden_for_camera_pan:
            return

        if not self.traffic_light_groups:
            if self._traffic_light_debug_render:
                signature = (0, self.traffic_lights_visible)
                if signature != self._traffic_light_render_debug_signature:
                    self._traffic_light_render_debug_signature = signature
                    self._traffic_light_debug("Render markers skipped: no traffic light groups cached.")
            return

        marker_fill = (220, 50, 50)  # Red color for stop lines
        marker_outline = (20, 20, 20)
        drawn_groups = 0
        visibility_state = self.traffic_lights_visible

        for group in self.traffic_light_groups:
            polygon_data = self._get_traffic_light_group_screen_polygon(group)
            if not polygon_data:
                group.screen_polygon = None
                group.screen_center = None
                continue

            screen_points, screen_center = polygon_data
            group.screen_polygon = screen_points
            group.screen_center = screen_center

            int_points = [(int(x), int(y)) for x, y in screen_points]

            try:
                if len(int_points) >= 3:
                    pygame.draw.polygon(screen, marker_fill, int_points)
                    pygame.draw.polygon(screen, marker_outline, int_points, 2)
                elif len(int_points) == 2:
                    pygame.draw.line(screen, marker_outline, int_points[0], int_points[1], 4)
                elif len(int_points) == 1:
                    pygame.draw.circle(screen, marker_fill, int_points[0], 6)
                    pygame.draw.circle(screen, marker_outline, int_points[0], 6, 2)
            except Exception:
                continue

            if screen_center:
                center_int = (int(screen_center[0]), int(screen_center[1]))
                pygame.draw.circle(screen, marker_outline, center_int, 3)

                if len(group.lights) > 1 and self._traffic_light_font:
                    label = str(len(group.lights))
                    try:
                        text_surface = self._traffic_light_font.render(label, True, (10, 10, 10))
                        text_rect = text_surface.get_rect(center=center_int)
                        screen.blit(text_surface, text_rect)
                    except Exception:
                        pass
            drawn_groups += 1

        if self._traffic_light_debug_render:
            signature = (drawn_groups, visibility_state)
            if signature != self._traffic_light_render_debug_signature:
                self._traffic_light_render_debug_signature = signature
                if visibility_state:
                    self._traffic_light_debug(
                        f"Render markers: drew {drawn_groups} group marker(s) with overlay visible."
                    )
                else:
                    self._traffic_light_debug(
                        f"Render markers suppressed: overlay hidden (groups available={drawn_groups})."
                    )

    def render_selected_traffic_light_highlight(self, screen):
        """Render a blue highlight around the currently selected traffic light marker."""
        if self.traffic_light_overlays_hidden_for_camera_pan:
            return

        group = self.selected_traffic_light_group
        if not group:
            return

        polygon_data = None
        if group.screen_polygon:
            polygon_data = (group.screen_polygon, group.screen_center)
        else:
            polygon_data = self._get_traffic_light_group_screen_polygon(group)
        if not polygon_data:
            return

        screen_points, screen_center = polygon_data
        if not group.screen_polygon:
            group.screen_polygon = screen_points
            group.screen_center = screen_center
        if not screen_points:
            return

        int_points = [(int(x), int(y)) for x, y in screen_points]
        highlight_color = (60, 150, 255)
        try:
            if len(int_points) >= 3:
                pygame.draw.polygon(screen, highlight_color, int_points, 3)
            elif len(int_points) == 2:
                pygame.draw.line(screen, highlight_color, int_points[0], int_points[1], 3)
            elif len(int_points) == 1:
                pygame.draw.circle(screen, highlight_color, int_points[0], 8, 3)
        except Exception:
            return

    def render_traffic_light_action_menu(self, screen):
        """Render the floating action menu for the selected traffic light group."""
        if (self.editor and self.editor.scenario_running) or not self.traffic_lights_visible:
            return

        if self.selected_personal_trigger:
            return

        if self.traffic_light_overlays_hidden_for_camera_pan:
            return

        if self.traffic_light_menu_hidden_for_camera_pan:
            return

        group = self.selected_traffic_light_group
        if not group:
            self.traffic_light_menu_position = None
            return

        icons = self._get_traffic_light_menu_icons(group)
        if not icons:
            self.traffic_light_menu_position = None
            return

        self._update_traffic_light_menu_anchor(group)
        if not self.traffic_light_menu_position:
            return

        tooltip_mgr = getattr(self.editor, 'tooltip_manager', None) if self.editor else None
        OverlayMenuRenderer.draw_menu(
            screen,
            self.traffic_light_menu_position,
            icons,
            (self.screen_width, self.screen_height),
            tooltip_manager=tooltip_mgr,
        )

    def render_traffic_light_triggers_overlay(self):
        """Draw world-space debug circles for the selected traffic light trigger."""
        if not self.world or not self.traffic_lights_visible:
            return

        group = self.selected_traffic_light_group
        selection_group: Optional[TrafficLightGroupData] = None
        center_payload: Optional[Dict[str, float]] = None
        radius_value: Optional[float] = None
        resolved_key: Optional[Tuple[str, Tuple]] = None

        editor_running = bool(self.editor and getattr(self.editor, 'scenario_running', False))

        if group:
            center_payload, radius_value, resolved_key = self._get_traffic_light_trigger_data(group=group)
            if center_payload:
                selection_group = group
        if (not center_payload and self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'traffic_light'):
            sel_group = self.selected_personal_trigger.get('group')
            sel_key = self.selected_personal_trigger.get('key')
            center_payload, radius_value, resolved_key = self._get_traffic_light_trigger_data(
                key=sel_key,
                group=sel_group,
            )
            if center_payload:
                selection_group = sel_group or self._find_traffic_light_group_by_key(resolved_key)
                if selection_group:
                    self.selected_personal_trigger['group'] = selection_group
                if resolved_key:
                    self.selected_personal_trigger['key'] = resolved_key
        if not center_payload and editor_running and self._scenario_active_traffic_light_trigger:
            snapshot = self._scenario_active_traffic_light_trigger
            center_payload = snapshot.get('center') if isinstance(snapshot, dict) else None
            radius_value = snapshot.get('radius') if isinstance(snapshot, dict) else None
        if (not center_payload and self._last_visible_traffic_light_trigger_key
                and not self.selected_personal_trigger):
            center_payload = self.traffic_light_trigger_centers.get(self._last_visible_traffic_light_trigger_key)
            radius_value = self.traffic_light_trigger_radii.get(self._last_visible_traffic_light_trigger_key)
            resolved_key = self._last_visible_traffic_light_trigger_key
            selection_group = self._find_traffic_light_group_by_key(resolved_key)
        if not center_payload:
            return

        if not center_payload or radius_value is None:
            return

        if self.traffic_light_overlays_hidden_for_camera_pan and not selection_group:
            return

        center_location = carla.Location(
            float(center_payload.get('x', 0.0)),
            float(center_payload.get('y', 0.0)),
            float(center_payload.get('z', 0.0)),
        )
        draw_height = center_location.z + 0.3
        marker_location = carla.Location(center_location.x, center_location.y, draw_height)

        lifetime = self.waypoint_debug_lifetime
        try:
            mouse_pos = pygame.mouse.get_pos()
        except pygame.error:
            mouse_pos = None
        hover_selection = {'kind': 'traffic_light', 'group': selection_group, 'key': resolved_key} if (selection_group or resolved_key) else None
        is_selected = bool(
            selection_group
            and self.selected_personal_trigger
            and self.selected_personal_trigger.get('kind') == 'traffic_light'
            and self.selected_personal_trigger.get('group') is selection_group
        )
        is_hovered = bool(selection_group and self._is_personal_trigger_hovered(hover_selection, mouse_pos))
        if is_selected:
            marker_color = carla.Color(180, 180, 0)
            circle_color = carla.Color(180, 140, 0)
        elif is_hovered:
            marker_color = carla.Color(240, 240, 240)
            circle_color = carla.Color(210, 210, 210)
        else:
            marker_color = carla.Color(0, 120, 220)
            circle_color = carla.Color(0, 100, 200)
        radius_float = float(radius_value)

        if resolved_key:
            self._last_visible_traffic_light_trigger_key = resolved_key

        try:
            self.world.debug.draw_point(
                marker_location,
                size=0.5,
                color=marker_color,
                life_time=lifetime,
            )
            self.world.debug.draw_string(
                carla.Location(center_location.x, center_location.y, draw_height + 1.2),
                f"TL R: {radius_float:.1f}m",
                draw_shadow=True,
                color=carla.Color(180, 180, 180),
                life_time=lifetime,
                persistent_lines=False,
            )

            num_points = 32
            for i in range(num_points):
                angle1 = 2.0 * math.pi * i / num_points
                angle2 = 2.0 * math.pi * (i + 1) / num_points
                point1 = carla.Location(
                    center_location.x + radius_float * math.cos(angle1),
                    center_location.y + radius_float * math.sin(angle1),
                    draw_height,
                )
                point2 = carla.Location(
                    center_location.x + radius_float * math.cos(angle2),
                    center_location.y + radius_float * math.sin(angle2),
                    draw_height,
                )
                self.world.debug.draw_line(
                    point1,
                    point2,
                    thickness=0.1,
                    color=circle_color,
                    life_time=lifetime,
                    persistent_lines=False,
                )
        except Exception as exc:
            print(f"[Traffic Light Trigger] Debug draw failed: {exc}")

    def render_pedestrian_triggers_overlay(self):
        """Draw world-space debug circles for pedestrian triggers."""
        if not self.world:
            return

        pedestrian_id = None
        if (self.selected_vehicle and self.selected_vehicle_is_pedestrian
                and self.selected_vehicle.is_alive
                and self.selected_vehicle.id in self.pedestrian_trigger_radii):
            pedestrian_id = self.selected_vehicle.id
        elif (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'pedestrian'):
            candidate_id = self.selected_personal_trigger.get('id')
            if candidate_id in self.pedestrian_trigger_radii:
                pedestrian_id = candidate_id

        if pedestrian_id is None:
            return

        center_payload = self.pedestrian_trigger_centers.get(pedestrian_id)
        radius_value = self.pedestrian_trigger_radii.get(pedestrian_id)

        if not center_payload or radius_value is None:
            return

        center_location = carla.Location(
            float(center_payload.get('x', 0.0)),
            float(center_payload.get('y', 0.0)),
            float(center_payload.get('z', 0.0)),
        )

        draw_height = center_location.z + 0.3
        marker_location = carla.Location(center_location.x, center_location.y, draw_height)

        lifetime = self.waypoint_debug_lifetime
        is_selected = (
            self.selected_personal_trigger
            and self.selected_personal_trigger.get('kind') == 'pedestrian'
            and self.selected_personal_trigger.get('id') == pedestrian_id
        )
        mouse_pos = None
        try:
            mouse_pos = pygame.mouse.get_pos()
        except pygame.error:
            mouse_pos = None
        hover_selection = {'kind': 'pedestrian', 'id': pedestrian_id}
        is_hovered = bool(self._is_personal_trigger_hovered(hover_selection, mouse_pos))
        if is_selected:
            marker_color = carla.Color(180, 180, 0)
            circle_color = carla.Color(180, 140, 0)
        elif is_hovered:
            marker_color = carla.Color(240, 240, 240)
            circle_color = carla.Color(210, 210, 210)
        else:
            marker_color = carla.Color(0, 120, 220)
            circle_color = carla.Color(0, 100, 200)
        radius_float = float(radius_value)

        try:
            # Draw center marker
            self.world.debug.draw_point(
                marker_location,
                size=0.5,
                color=marker_color,
                life_time=lifetime,
            )
            # Draw radius label
            self.world.debug.draw_string(
                carla.Location(center_location.x, center_location.y, draw_height + 1.2),
                f"Ped R: {radius_float:.1f}m",
                draw_shadow=True,
                color=carla.Color(180, 180, 180),
                life_time=lifetime,
                persistent_lines=False,
            )

            # Draw circle with 32 line segments
            num_points = 32
            for i in range(num_points):
                angle1 = 2.0 * math.pi * i / num_points
                angle2 = 2.0 * math.pi * (i + 1) / num_points
                point1 = carla.Location(
                    center_location.x + radius_float * math.cos(angle1),
                    center_location.y + radius_float * math.sin(angle1),
                    draw_height,
                )
                point2 = carla.Location(
                    center_location.x + radius_float * math.cos(angle2),
                    center_location.y + radius_float * math.sin(angle2),
                    draw_height,
                )
                self.world.debug.draw_line(
                    point1,
                    point2,
                    thickness=0.1,
                    color=circle_color,
                    life_time=lifetime,
                    persistent_lines=False,
                )
        except Exception as exc:
            print(f"[Pedestrian Trigger] Debug draw failed: {exc}")

    def render_vehicle_triggers_overlay(self):
        """Draw world-space debug circles for NPC vehicle triggers."""
        if not self.world:
            return

        vehicle_id = None
        if (self.selected_vehicle and not self.selected_vehicle_is_pedestrian
                and self.selected_vehicle.is_alive and not self.is_ego_vehicle(self.selected_vehicle.id)
                and self.selected_vehicle.id in self.vehicle_trigger_radii):
            vehicle_id = self.selected_vehicle.id
        elif (self.selected_personal_trigger
                and self.selected_personal_trigger.get('kind') == 'vehicle'):
            candidate_id = self.selected_personal_trigger.get('id')
            if (candidate_id is not None and not self.is_ego_vehicle(candidate_id)
                    and candidate_id in self.vehicle_trigger_radii):
                vehicle_id = candidate_id

        if vehicle_id is None:
            return

        center_payload = self.vehicle_trigger_centers.get(vehicle_id)
        radius_value = self.vehicle_trigger_radii.get(vehicle_id)
        if not center_payload or radius_value is None:
            return

        center_location = carla.Location(
            float(center_payload.get('x', 0.0)),
            float(center_payload.get('y', 0.0)),
            float(center_payload.get('z', 0.0)),
        )

        draw_height = center_location.z + 0.3
        marker_location = carla.Location(center_location.x, center_location.y, draw_height)

        lifetime = self.waypoint_debug_lifetime
        is_selected = (
            self.selected_personal_trigger
            and self.selected_personal_trigger.get('kind') == 'vehicle'
            and self.selected_personal_trigger.get('id') == vehicle_id
        )
        mouse_pos = None
        try:
            mouse_pos = pygame.mouse.get_pos()
        except pygame.error:
            mouse_pos = None
        hover_selection = {'kind': 'vehicle', 'id': vehicle_id}
        is_hovered = bool(self._is_personal_trigger_hovered(hover_selection, mouse_pos))
        if is_selected:
            marker_color = carla.Color(180, 180, 0)
            circle_color = carla.Color(180, 140, 0)
        elif is_hovered:
            marker_color = carla.Color(240, 240, 240)
            circle_color = carla.Color(210, 210, 210)
        else:
            marker_color = carla.Color(0, 120, 220)
            circle_color = carla.Color(0, 100, 200)
        radius_float = float(radius_value)

        try:
            self.world.debug.draw_point(
                marker_location,
                size=0.5,
                color=marker_color,
                life_time=lifetime,
            )
            self.world.debug.draw_string(
                carla.Location(center_location.x, center_location.y, draw_height + 1.2),
                f"Veh R: {radius_float:.1f}m",
                draw_shadow=True,
                color=carla.Color(180, 180, 180),
                life_time=lifetime,
                persistent_lines=False,
            )

            num_points = 32
            for i in range(num_points):
                angle1 = 2.0 * math.pi * i / num_points
                angle2 = 2.0 * math.pi * (i + 1) / num_points
                point1 = carla.Location(
                    center_location.x + radius_float * math.cos(angle1),
                    center_location.y + radius_float * math.sin(angle1),
                    draw_height,
                )
                point2 = carla.Location(
                    center_location.x + radius_float * math.cos(angle2),
                    center_location.y + radius_float * math.sin(angle2),
                    draw_height,
                )
                self.world.debug.draw_line(
                    point1,
                    point2,
                    thickness=0.1,
                    color=circle_color,
                    life_time=lifetime,
                    persistent_lines=False,
                )
        except Exception as exc:
            print(f"[Vehicle Trigger] Debug draw failed: {exc}")

    def render_vehicle_action_menu(self, screen):
        """Render the action menu for selected vehicle"""
        # Don't render menu if we're in waypoint creation/destination mode or scenario playback
        if (self.creating_waypoint or self.creating_destination or
                (self.editor and self.editor.scenario_running)):
            return

        if self.selected_personal_trigger:
            return

        if self.vehicle_menu_hidden_for_camera_pan:
            return

        if not self.selected_vehicle or not self.vehicle_menu_position:
            return
        
        # Check if vehicle is still alive
        if not self.selected_vehicle.is_alive:
            self.clear_vehicle_selection()
            return
        
        # Build icon order based on current selection
        is_ego = self.is_ego_vehicle(self.selected_vehicle.id)
        icon_order = ['delete', 'move']
        if not self.selected_vehicle_is_pedestrian:
            icon_order.append('rotate')
        if not is_ego:
            icon_order.append('waypoint')
        if not self.selected_vehicle_is_pedestrian and not is_ego:
            icon_order.append('autoroute')
        if is_ego and not self.selected_vehicle_is_pedestrian:
            icon_order.append('ego_destination')
        trigger_supported = False
        if self.selected_vehicle_is_pedestrian:
            trigger_supported = True
        elif not is_ego:
            trigger_supported = True
        has_personal_trigger = False
        actor_id = self.selected_vehicle.id
        if self.selected_vehicle_is_pedestrian:
            has_personal_trigger = actor_id in self.pedestrian_trigger_radii
        elif not is_ego:
            has_personal_trigger = actor_id in self.vehicle_trigger_radii
        if trigger_supported:
            icon_order.append('add_trigger')
            if has_personal_trigger:
                icon_order.append('remove_trigger')

        tooltip_mgr = getattr(self.editor, 'tooltip_manager', None) if self.editor else None
        OverlayMenuRenderer.draw_menu(
            screen,
            self.vehicle_menu_position,
            icon_order,
            (self.screen_width, self.screen_height),
            tooltip_manager=tooltip_mgr,
        )
    
    def render_waypoint_creation_overlay(self, screen):
        """Delegate waypoint creation overlay rendering to helper."""
        WaypointOverlayRenderer.render_creation_overlay(self, screen)

    def render_destination_creation_overlay(self, screen):
        """Delegate destination overlay rendering to helper."""
        WaypointOverlayRenderer.render_destination_overlay(self, screen)

    def draw_dashed_line(self, surface, color, start_pos, end_pos, width=1, dash_length=5):
        """Backward-compatible wrapper around the overlay helper."""
        WaypointOverlayRenderer._draw_dashed_line(surface, color, start_pos, end_pos, width, dash_length)

    def render_action_menus(self, screen):
        """Render action menus and selection indicators (vehicle, pedestrian, traffic light, triggers).
        Called early in render loop to appear behind UI panels."""
        # Traffic light markers and selection indicators
        if self.traffic_lights_visible:
            self.render_traffic_light_markers(screen)
            self.render_selected_traffic_light_connectors(screen)
            self.render_selected_traffic_light_highlight(screen)
        # Actor selection highlight
        self.render_selected_actor_highlight(screen)
        # Action menus
        self.render_traffic_light_action_menu(screen)
        self.render_vehicle_action_menu(screen)
        self.render_trigger_action_menu(screen)
        self.render_personal_trigger_action_menu(screen)

    def render_all_overlays(self, screen):
        """Render world-space overlays (waypoints, lanes, triggers, etc).
        Does NOT include action menus or selection indicators - those are rendered earlier via render_action_menus()."""
        self.render_waypoint_creation_overlay(screen)
        self.render_destination_creation_overlay(screen)
        self.render_opendrive_lanes_overlay(screen)
        self.render_waypoints_overlay(screen)
        self.render_trigger_placement_overlay(screen)
        self.render_triggers_overlay(screen)
        self.render_personal_trigger_links(screen)
        self.render_traffic_light_triggers_overlay()
        self.render_pedestrian_triggers_overlay()
        self.render_vehicle_triggers_overlay()


    def render_waypoints_overlay(self, screen):
        """Delegate waypoint hover overlay rendering to helper."""
        WaypointOverlayRenderer.render_waypoints_overlay(self, screen)

    
    def draw_finish_line(self, screen, marker_x, marker_y, waypoints, waypoint_index, is_selected, is_hovered):
        """Backward-compatible wrapper around the overlay helper."""
        WaypointOverlayRenderer.draw_finish_line(
            self,
            screen,
            marker_x,
            marker_y,
            waypoints,
            waypoint_index,
            is_selected,
            is_hovered,
        )
    
    def render_opendrive_lanes_overlay(self, screen):
        """Delegate OpenDRIVE overlay rendering to helper."""
        if self.opendrive_overlay_hidden_for_camera_pan:
            return
        OpenDriveOverlayRenderer.render(self, screen)
    
    def _render_lanes_to_surface(self, surface):
        """Backward-compatible wrapper around the overlay helper."""
        OpenDriveOverlayRenderer._render_lanes_to_surface(self, surface)
    
    def precompute_opendrive_lane_data(self):
        """Delegate lane data precomputation to helper."""
        OpenDriveOverlayRenderer.precompute_lane_data(self)
    
    def trace_detailed_lane_segment_for_overlay(self, start_wp, end_wp):
        """Backward-compatible wrapper around the overlay helper."""
        return OpenDriveOverlayRenderer.trace_lane_segment(self, start_wp, end_wp)
    
    def toggle_opendrive_overlay(self):
        """Toggle OpenDRIVE overlay via helper."""
        OpenDriveOverlayRenderer.toggle_overlay(self)
    
    def _compute_world_viewport_bounds(self):
        """Backward-compatible wrapper for helper viewport bounds."""
        return OpenDriveOverlayRenderer._compute_viewport_bounds(self)
    
    def _build_opendrive_segment_grid(self):
        """Backward-compatible wrapper for helper grid builder."""
        OpenDriveOverlayRenderer._build_segment_grid(self)
    
    def _bbox_intersects(self, bbox1, bbox2):
        """Backward-compatible wrapper around helper bbox check."""
        return OpenDriveOverlayRenderer._bbox_intersects(bbox1, bbox2)
    
    def _has_camera_moved_significantly(self):
        """Backward-compatible wrapper to helper camera movement check."""
        return OpenDriveOverlayRenderer._has_camera_moved_significantly(self)
    
    def _update_camera_state(self):
        """Backward-compatible wrapper to helper state update."""
        OpenDriveOverlayRenderer._update_camera_state(self)
    
    def update_vehicle_id_references(self, old_id, new_id):
        """Update vehicle ID references in commands after vehicle respawn"""
        waypoints = self.get_vehicle_waypoints(old_id)
        if waypoints:
            self.clear_vehicle_waypoints(old_id)
            self.set_vehicle_waypoints(new_id, waypoints)

        if old_id in self.vehicle_speeds:
            speed = self.vehicle_speeds[old_id]
            self.clear_vehicle_speed(old_id)
            self.set_vehicle_speed(new_id, speed)

        if old_id in self.vehicle_destination_speeds:
            dest_speed = self.vehicle_destination_speeds[old_id]
            self.clear_vehicle_destination_speed(old_id)
            self.set_vehicle_destination_speed(new_id, dest_speed)

        if old_id in self.vehicle_max_lat_acc:
            lat_acc = self.vehicle_max_lat_acc.pop(old_id)
            self.vehicle_max_lat_acc[new_id] = lat_acc

        if old_id in self.vehicle_colors:
            color = self.vehicle_colors[old_id]
            self.clear_vehicle_color(old_id)
            self.set_vehicle_color(new_id, color)

        if old_id in self.actor_idle_times:
            idle = self.actor_idle_times[old_id]
            self.clear_actor_idle_time(old_id)
            self.set_actor_idle_time(new_id, idle)

        if old_id in self.actor_turn_times:
            turn = self.actor_turn_times[old_id]
            self.clear_actor_turn_time(old_id)
            self.set_actor_turn_time(new_id, turn)

        if old_id in self.vehicle_trigger_centers:
            center = self.vehicle_trigger_centers.pop(old_id)
            self.vehicle_trigger_centers[new_id] = center
        if old_id in self.vehicle_trigger_radii:
            radius = self.vehicle_trigger_radii.pop(old_id)
            self.vehicle_trigger_radii[new_id] = radius

        flags = self.get_vehicle_ignore_flags(old_id)
        self.clear_vehicle_ignore_flags(old_id)
        if any(flags.values()):
            self.set_vehicle_ignore_flags(new_id, flags)

        if self.ego_vehicle_id == old_id:
            self.ego_vehicle_id = new_id
            if self.manual_control_actor and self.manual_control_actor.id == old_id:
                self.disable_manual_control()

        # Update selection and UI references
        if self.selected_vehicle and self.selected_vehicle.id == old_id:
            new_actor = next((actor for actor in self.spawned_vehicles if actor.id == new_id and actor.is_alive), None)
            self.selected_vehicle = new_actor
            self.selected_vehicle_is_pedestrian = bool(new_actor and new_actor.type_id.startswith('walker.'))
            if new_actor:
                self.refresh_selected_vehicle_ui()
            else:
                self.vehicle_menu_position = None

        if self.waypoint_display_vehicle_id == old_id:
            self.waypoint_display_vehicle_id = new_id

        if self.selected_waypoint_vehicle_id == old_id:
            self.selected_waypoint_vehicle_id = new_id

        panel = getattr(getattr(self, "editor", None), "info_panel", None)
        if panel and panel.visible and panel.selected_object and panel.selected_object.id == old_id:
            new_actor = next((actor for actor in self.spawned_vehicles if actor.id == new_id and actor.is_alive), None)
            if new_actor:
                panel.show(new_actor,
                           'pedestrian' if new_actor.type_id.startswith('walker.') else 'vehicle',
                           self.editor.screen_width,
                           self.editor.screen_height)
            else:
                panel.hide()
    
        # Update commands in both stacks from the editor
        if self.editor:
            for command in self.editor.undo_stack + self.editor.redo_stack:
                if hasattr(command, 'vehicle_id') and command.vehicle_id == old_id:
                    command.vehicle_id = new_id
    
    def cleanup(self):
        """Cleanup camera sensor and visualization"""
        self._unregister_pedestrian_highlight_tick()
        if self.camera_sensor:
            self.camera_sensor.destroy()
            self.camera_sensor = None

        # Clear coordinate detector's cached world map to avoid stale references
        if hasattr(self, 'coordinate_detector') and self.coordinate_detector:
            self.coordinate_detector.world_map = None

        # Clear traffic light references
        if self.traffic_lights:
            self.traffic_lights.clear()
        if self.traffic_light_groups:
            self.traffic_light_groups.clear()
        self._traffic_light_group_lookup.clear()
        self._traffic_light_rectangles.clear()
        self.clear_traffic_light_selection()

        # Clean up all spawned vehicles
        self.cleanup_all_vehicles()
    
    def cleanup_all_vehicles(self, preserve_ids=None, preserve_ego=False):
        """Remove all editor-spawned vehicles, optionally preserving specific actor ids."""
        preserve_ids = set(preserve_ids or [])
        editor = getattr(self, "editor", None)
        if editor:
            external_id = getattr(editor, "external_ego_actor_id", None)
            swap_id = getattr(editor, "_external_swap_current_id", None)
            if swap_id:
                external_id = swap_id
            if external_id is not None:
                preserve_ids.add(external_id)
        preserved_actors = []
        vehicles_destroyed = 0

        if self.spawned_vehicles:
            print(f"Cleaning up {len(self.spawned_vehicles)} spawned vehicles...")

            # Work on a copy so we can mutate the original list in place.
            current_spawned = list(self.spawned_vehicles)
            preserved_actors = []
            destroy_pairs = []
            destroy_fallback = []

            for vehicle in current_spawned:
                actor_id = None
                try:
                    actor_id = vehicle.id if vehicle else None
                except Exception:
                    actor_id = None

                keep_actor = actor_id is not None and actor_id in preserve_ids

                if keep_actor:
                    preserved_actors.append(vehicle)
                    continue

                if actor_id is not None:
                    try:
                        self.clear_vehicle_metadata(int(actor_id), clear_waypoints=True)
                    except Exception:
                        pass

                if vehicle and getattr(vehicle, "is_alive", False):
                    if actor_id is not None:
                        try:
                            destroy_pairs.append((int(actor_id), vehicle))
                        except Exception:
                            destroy_fallback.append(vehicle)
                    else:
                        destroy_fallback.append(vehicle)

            if destroy_pairs:
                client = None
                if editor is not None:
                    client = getattr(editor, "client", None)
                if client is not None and hasattr(client, "apply_batch_sync"):
                    try:
                        batch = [carla.command.DestroyActor(actor_id) for actor_id, _actor in destroy_pairs]
                        responses = client.apply_batch_sync(batch, False)
                        if responses:
                            for response in responses:
                                try:
                                    if not getattr(response, "error", None):
                                        vehicles_destroyed += 1
                                except Exception:
                                    vehicles_destroyed += 1
                        else:
                            vehicles_destroyed += len(destroy_pairs)
                    except Exception as exc:
                        print(f"Error destroying vehicles via batch: {exc}")
                        destroy_fallback.extend([actor for _actor_id, actor in destroy_pairs])
                else:
                    destroy_fallback.extend([actor for _actor_id, actor in destroy_pairs])

            for actor in destroy_fallback:
                try:
                    if actor and getattr(actor, "is_alive", False):
                        actor.destroy()
                        vehicles_destroyed += 1
                except Exception as exc:
                    print(f"Error destroying vehicle: {exc}")
            # Keep the same list object that other systems (like the coordinate detector)
            # hold on to, so in-place operations remain visible everywhere.
            self.spawned_vehicles.clear()
            self.spawned_vehicles.extend(preserved_actors)

            if vehicles_destroyed > 0:
                print(f"Successfully destroyed {vehicles_destroyed} vehicles")
            else:
                if preserved_actors:
                    print("No vehicles destroyed; preserving requested actors.")
                else:
                    print("No vehicles to clean up")
        else:
            print("No vehicles to clean up")

        # Reset selection state if preserved actors do not include the selected vehicle
        if (
            self.selected_vehicle
            and self.selected_vehicle.id not in preserve_ids
        ):
            self.clear_vehicle_selection()
        elif not self.selected_vehicle:
            self.clear_vehicle_selection()

        if (
            self.waypoint_display_vehicle_id is not None
            and self.waypoint_display_vehicle_id not in preserve_ids
        ):
            self.waypoint_display_vehicle_id = None

        if not preserve_ids:
            self.clear_all_vehicle_metadata()

        if (
            self.ego_vehicle_id
            and (self.ego_vehicle_id not in preserve_ids or not preserve_ego)
        ):
            self.clear_ego_vehicle()

        self.disable_manual_control()
        self.pedestrian_colors.clear()

        # Ensure the coordinate detector always references the live list object.
        if hasattr(self, "coordinate_detector") and self.coordinate_detector:
            self.coordinate_detector.spawned_vehicles = self.spawned_vehicles

############################################################
# UI Classes (Selection Menus, Info Panel)
############################################################
class PlacementMode(Enum):
    VEHICLE = "vehicle"
    PEDESTRIAN = "pedestrian"
    EGO = "ego"
    TRIGGER = "trigger"


class ActorSelectionMenu:
    """Generic dropdown menu for selecting CARLA actor blueprints."""

    def __init__(self, *, title, blueprint_filter, fallback_id, fallback_name, display_transform=None):
        self.title = title
        self.blueprint_filter = blueprint_filter
        self.fallback_id = fallback_id
        self.fallback_name = fallback_name
        self.display_transform = display_transform or (lambda actor_id: actor_id)

        self.menu_width = 300
        self.menu_height = 200  # Height when dropdown is closed
        self.base_x = 10
        self.base_y = 120
        self.dropdown_open = False
        self.on_dropdown_open: Optional[Callable[["ActorSelectionMenu"], None]] = None
        self.selected_index = 0
        self.available_ids = []
        self.display_names = []
        self.font = pygame.font.Font(None, 20)
        self.small_font = pygame.font.Font(None, 16)

        # Scrolling support
        self.scroll_offset = 0
        self.max_visible_items = 10
        self.item_height = 25

        # UI colors
        self.bg_color = (40, 40, 40, 200)
        self.dropdown_color = (60, 60, 60)
        self.hover_color = (80, 80, 80)
        self.text_color = (255, 255, 255)
        self.border_color = (100, 100, 100)

    def initialize(self, world):
        """Populate menu options from CARLA blueprints."""
        try:
            blueprint_library = world.get_blueprint_library()
            blueprints = blueprint_library.filter(self.blueprint_filter)

            actor_entries = []
            for bp in blueprints:
                actor_id = bp.id
                display_name = self.display_transform(actor_id)
                actor_entries.append((actor_id, display_name))

            if not actor_entries:
                raise ValueError("No blueprints found")

            actor_entries.sort(key=lambda entry: entry[1].lower())

            self.available_ids = [entry[0] for entry in actor_entries]
            self.display_names = [entry[1] for entry in actor_entries]
            self.selected_index = min(self.selected_index, len(self.available_ids) - 1)
            self.scroll_offset = 0

            print(f"Found {len(self.available_ids)} {self.title.lower()} types")

        except Exception as e:
            print(f"Error initializing {self.title.lower()} menu: {e}")
            self.available_ids = [self.fallback_id]
            self.display_names = [self.fallback_name]
            self.selected_index = 0
            self.scroll_offset = 0

    def set_vertical_offset(self, top_offset):
        """Update the vertical offset for rendering and hit detection."""
        self.base_y = top_offset

    def handle_click(self, mouse_pos):
        """Handle mouse clicks on the menu."""
        menu_x = self.base_x
        menu_y = self.base_y
        dropdown_y = menu_y + 60
        dropdown_height = 30

        # Click on dropdown header toggles the list
        if (menu_x <= mouse_pos[0] <= menu_x + self.menu_width - 20 and
            dropdown_y <= mouse_pos[1] <= dropdown_y + dropdown_height):
            new_state = not self.dropdown_open
            if new_state and callable(self.on_dropdown_open):
                try:
                    self.on_dropdown_open(self)
                except Exception as exc:
                    print(f"[UI] Failed to close other menus: {exc}")
            self.dropdown_open = new_state
            return True

        # Handle item selection
        if self.dropdown_open:
            visible_items = min(self.max_visible_items, len(self.display_names) - self.scroll_offset)
            for i in range(visible_items):
                actual_index = i + self.scroll_offset
                item_y = dropdown_y + dropdown_height + (i * self.item_height)
                if (menu_x <= mouse_pos[0] <= menu_x + self.menu_width - 20 and
                    item_y <= mouse_pos[1] <= item_y + self.item_height):
                    self.selected_index = actual_index
                    self.dropdown_open = False
                    return True

        # Click outside closes dropdown
        if self.dropdown_open:
            if not (menu_x <= mouse_pos[0] <= menu_x + self.menu_width):
                self.dropdown_open = False
                return True

        return False

    def handle_scroll(self, mouse_pos, scroll_direction):
        """Handle mouse wheel scrolling in dropdown."""
        menu_x = self.base_x
        menu_y = self.base_y

        base_height = 120
        dropdown_list_height = self.max_visible_items * self.item_height if self.dropdown_open else 0
        total_menu_height = base_height + dropdown_list_height + 30

        if (menu_x <= mouse_pos[0] <= menu_x + self.menu_width and
            menu_y <= mouse_pos[1] <= menu_y + total_menu_height):

            if self.dropdown_open and dropdown_list_height > 0:
                dropdown_y = menu_y + 60
                dropdown_height = 30

                if (menu_x <= mouse_pos[0] <= menu_x + self.menu_width - 20 and
                    dropdown_y + dropdown_height <= mouse_pos[1] <= dropdown_y + dropdown_height + dropdown_list_height):

                    reversed_scroll = -scroll_direction

                    max_offset = max(0, len(self.display_names) - self.max_visible_items)
                    new_offset = max(0, min(
                        max_offset,
                        self.scroll_offset + reversed_scroll
                    ))

                    if new_offset != self.scroll_offset:
                        self.scroll_offset = new_offset

            return True

        return False

    def get_extra_height(self) -> int:
        """Return additional vertical space needed for subclass-specific UI."""
        return 0

    def render_extra_content(self, screen, menu_x: int, extra_top: int) -> None:
        """Render subclass-specific UI below the dropdown."""
        return

    def _get_spawn_tip_lines(self) -> List[str]:
        """Return context-specific tip lines to render above the dropdown."""
        return []

    def get_selected_actor(self):
        """Return the selected actor blueprint id."""
        if 0 <= self.selected_index < len(self.available_ids):
            return self.available_ids[self.selected_index]
        return None

    def render(self, screen):
        """Render the selection menu."""
        menu_x = self.base_x
        menu_y = self.base_y

        base_height = 120
        dropdown_list_height = 0
        dropdown_padding = 30 if self.dropdown_open else 0

        if self.dropdown_open:
            visible_items = min(self.max_visible_items, len(self.display_names) - self.scroll_offset)
            dropdown_list_height = visible_items * self.item_height

        content_offset = base_height + dropdown_list_height + dropdown_padding
        extra_height = self.get_extra_height()
        total_menu_height = content_offset + extra_height

        menu_surface = pygame.Surface((self.menu_width, total_menu_height), pygame.SRCALPHA)
        menu_surface.fill(self.bg_color)
        screen.blit(menu_surface, (menu_x, menu_y))

        pygame.draw.rect(screen, self.border_color,
                         (menu_x, menu_y, self.menu_width, total_menu_height), 2)

        title_text = self.font.render(self.title, True, self.text_color)
        screen.blit(title_text, (menu_x + 10, menu_y + 10))

        dropdown_y = menu_y + 60
        dropdown_height = 30

        tip_lines = self._get_spawn_tip_lines()
        if tip_lines:
            line_height = self.small_font.get_linesize()
            tip_top = dropdown_y - (line_height * len(tip_lines)) - 4
            for idx, tip in enumerate(tip_lines):
                tip_surface = self.small_font.render(tip, True, (200, 200, 200))
                screen.blit(tip_surface, (menu_x + 10, tip_top + idx * line_height))

        dropdown_rect = pygame.Rect(menu_x + 10, dropdown_y, self.menu_width - 40, dropdown_height)
        pygame.draw.rect(screen, self.dropdown_color, dropdown_rect)
        pygame.draw.rect(screen, self.border_color, dropdown_rect, 1)

        if self.selected_index < len(self.display_names):
            selected_text = self.display_names[self.selected_index]
            if len(selected_text) > 25:
                selected_text = selected_text[:22] + "..."

            text_surface = self.small_font.render(selected_text, True, self.text_color)
            screen.blit(text_surface, (menu_x + 15, dropdown_y + 8))

        arrow_x = menu_x + self.menu_width - 30
        arrow_y = dropdown_y + 15
        if self.dropdown_open:
            pygame.draw.polygon(screen, self.text_color, [
                (arrow_x, arrow_y + 5),
                (arrow_x + 10, arrow_y - 5),
                (arrow_x + 20, arrow_y + 5)
            ])
        else:
            pygame.draw.polygon(screen, self.text_color, [
                (arrow_x, arrow_y - 5),
                (arrow_x + 10, arrow_y + 5),
                (arrow_x + 20, arrow_y - 5)
            ])

        if self.dropdown_open:
            visible_items = min(self.max_visible_items, len(self.display_names) - self.scroll_offset)

            list_rect = pygame.Rect(menu_x + 10, dropdown_y + dropdown_height,
                                    self.menu_width - 40, dropdown_list_height)
            pygame.draw.rect(screen, self.dropdown_color, list_rect)
            pygame.draw.rect(screen, self.border_color, list_rect, 1)

            mouse_pos = pygame.mouse.get_pos()
            for i in range(visible_items):
                actual_index = i + self.scroll_offset
                item_y = dropdown_y + dropdown_height + (i * self.item_height)
                item_rect = pygame.Rect(menu_x + 10, item_y, self.menu_width - 40, self.item_height)

                if item_rect.collidepoint(mouse_pos):
                    pygame.draw.rect(screen, self.hover_color, item_rect)

                if actual_index < len(self.display_names):
                    item_text = self.display_names[actual_index]
                    if len(item_text) > 25:
                        item_text = item_text[:22] + "..."

                    text_surface = self.small_font.render(item_text, True, self.text_color)
                    screen.blit(text_surface, (menu_x + 15, item_y + 5))

            if self.scroll_offset > 0:
                pygame.draw.polygon(screen, (150, 150, 150), [
                    (menu_x + self.menu_width - 15, dropdown_y + dropdown_height + 5),
                    (menu_x + self.menu_width - 10, dropdown_y + dropdown_height),
                    (menu_x + self.menu_width - 5, dropdown_y + dropdown_height + 5)
                ])

            if self.scroll_offset + self.max_visible_items < len(self.display_names):
                bottom_y = dropdown_y + dropdown_height + dropdown_list_height
                pygame.draw.polygon(screen, (150, 150, 150), [
                    (menu_x + self.menu_width - 15, bottom_y - 5),
                    (menu_x + self.menu_width - 10, bottom_y),
                    (menu_x + self.menu_width - 5, bottom_y - 5)
                ])

        if extra_height > 0:
            extra_origin = menu_y + content_offset
            self.render_extra_content(screen, menu_x, extra_origin)

    def cleanup(self):
        """Cleanup placeholder for future resources."""
        pass


class VehicleSelectionMenu(ActorSelectionMenu):
    """Vehicle-specific selection menu wrapper."""

    _EGO_MODEL_ID = "vehicle.lexus.utlexus"
    _SPAWNED_HEADER_MARGIN = 18
    _SPAWNED_HEADER_HEIGHT = 24
    _SPAWNED_BOTTOM_PADDING = 30

    def __init__(self):
        super().__init__(
            title="NPC Vehicles",
            blueprint_filter="vehicle.*",
            fallback_id="vehicle.tesla.model3",
            fallback_name="Tesla Model 3",
            display_transform=self._format_vehicle_name
        )
        self._camera_processor_ref: Optional["weakref.ReferenceType[CameraImageProcessor]"] = None
        self.spawned_scroll_offset = 0
        self._spawned_layout: Optional[Dict[str, object]] = None
        self._spawned_item_hitboxes: List[Tuple[int, pygame.Rect]] = []
        self._spawned_section_rect: Optional[pygame.Rect] = None
        self._last_spawned_click_id: Optional[int] = None
        self._last_spawned_click_time = 0
        self._double_click_ms = 350
        self._placeholder_text = "No vehicles added yet"

    @staticmethod
    def _format_vehicle_name(actor_id):
        return actor_id.replace('vehicle.', '').replace('_', ' ').title()

    def set_camera_processor(self, camera_processor: Optional["CameraImageProcessor"]) -> None:
        self._camera_processor_ref = weakref.ref(camera_processor) if camera_processor else None
        self._spawned_layout = None
        self._spawned_item_hitboxes = []
        self._spawned_section_rect = None

    def _get_camera_processor(self) -> Optional["CameraImageProcessor"]:
        if not self._camera_processor_ref:
            return None
        return self._camera_processor_ref()

    def initialize_vehicles(self, world):
        self.initialize(world)

        # Remove ego blueprint from NPC list if present
        if self._EGO_MODEL_ID in self.available_ids:
            idx = self.available_ids.index(self._EGO_MODEL_ID)
            del self.available_ids[idx]
            del self.display_names[idx]
        if self.available_ids:
            self.selected_index = min(self.selected_index, len(self.available_ids) - 1)
        else:
            self.available_ids = [self.fallback_id]
            self.display_names = [self.fallback_name]
            self.selected_index = 0
        self.scroll_offset = 0

    def get_selected_vehicle(self):
        return self.get_selected_actor()

    def _build_spawned_entries(self) -> List[Dict[str, Union[int, str]]]:
        processor = self._get_camera_processor()
        entries: List[Dict[str, Union[int, str]]] = []
        if not processor:
            return entries

        external_ego_id = getattr(processor, "external_ego_actor_id", None)

        for actor in getattr(processor, "spawned_vehicles", []):
            if not actor or not actor.is_alive:
                continue
            if actor.type_id.startswith('walker.'):
                continue
            if actor.type_id == self._EGO_MODEL_ID:
                continue
            if processor.is_ego_vehicle(actor.id):
                continue
            if external_ego_id and actor.id == external_ego_id:
                continue
            entries.append({
                'id': actor.id,
                'name': self._format_vehicle_name(actor.type_id),
            })
        entries.sort(key=lambda item: str(item['name']).lower())
        return entries

    def _get_selected_vehicle_id(self) -> Optional[int]:
        processor = self._get_camera_processor()
        if not processor or not processor.selected_vehicle or processor.selected_vehicle_is_pedestrian:
            return None
        return processor.selected_vehicle.id

    def _get_spawn_tip_lines(self) -> List[str]:
        return [
            "Tip: Ctrl+Left click to spawn snapped to lane",
            "Tip: Ctrl+Shift+Left click for free placement",
        ]

    def _ensure_spawned_layout(self, *, force: bool = False) -> Dict[str, object]:
        if self._spawned_layout is not None and not force:
            return self._spawned_layout

        entries = self._build_spawned_entries()
        max_scroll = max(0, len(entries) - self.max_visible_items)
        if self.spawned_scroll_offset > max_scroll:
            self.spawned_scroll_offset = max_scroll

        visible_entries = entries[self.spawned_scroll_offset:self.spawned_scroll_offset + self.max_visible_items]
        list_rows = max(len(visible_entries), 1)
        list_height = list_rows * self.item_height

        dropdown_list_height = 0
        dropdown_padding = 30 if self.dropdown_open else 0
        if self.dropdown_open:
            visible_dropdown = min(self.max_visible_items, len(self.display_names) - self.scroll_offset)
            dropdown_list_height = visible_dropdown * self.item_height

        extra_top = self.base_y + 120 + dropdown_list_height + dropdown_padding
        tip_height = self.small_font.get_height() + 2
        header_block_height = self._SPAWNED_HEADER_HEIGHT + tip_height
        section_height = (
            self._SPAWNED_HEADER_MARGIN +
            header_block_height +
            list_height +
            self._SPAWNED_BOTTOM_PADDING
        )
        section_rect = pygame.Rect(self.base_x, extra_top, self.menu_width, section_height)
        header_y = section_rect.y + self._SPAWNED_HEADER_MARGIN
        list_top = header_y + header_block_height + 6
        list_rect = pygame.Rect(self.base_x + 10, list_top, self.menu_width - 40, list_height)

        visible_rows: List[Tuple[Dict[str, Union[int, str]], pygame.Rect]] = []
        row_y = list_rect.y
        for entry in visible_entries:
            row_rect = pygame.Rect(list_rect.x, row_y, list_rect.width, self.item_height)
            visible_rows.append((entry, row_rect))
            row_y += self.item_height

        self._spawned_item_hitboxes = [(entry['id'], rect) for entry, rect in visible_rows]
        self._spawned_section_rect = section_rect
        layout: Dict[str, object] = {
            'entries': entries,
            'visible_rows': visible_rows,
            'section_rect': section_rect,
            'list_rect': list_rect,
            'header_y': header_y,
            'tip_y': header_y + self._SPAWNED_HEADER_HEIGHT,
            'total_height': section_height,
            'count': len(entries),
            'selected_vehicle_id': self._get_selected_vehicle_id(),
        }
        self._spawned_layout = layout
        return layout

    def get_extra_height(self) -> int:
        layout = self._ensure_spawned_layout(force=True)
        return int(layout.get('total_height', 0))

    def render_extra_content(self, screen, menu_x: int, extra_top: int) -> None:
        layout = self._ensure_spawned_layout()
        section_rect = layout.get('section_rect')
        list_rect = layout.get('list_rect')
        header_y = layout.get('header_y', extra_top)
        if not isinstance(section_rect, pygame.Rect) or not isinstance(list_rect, pygame.Rect):
            return

        header_text = f"Placed Vehicles ({layout.get('count', 0)})"
        header_surface = self.small_font.render(header_text, True, self.text_color)
        screen.blit(header_surface, (menu_x + 10, header_y))

        tip_y = layout.get('tip_y', header_y + self._SPAWNED_HEADER_HEIGHT)
        tip_surface = self.small_font.render("Tip: double-click to focus camera", True, (200, 200, 200))
        screen.blit(tip_surface, (menu_x + 10, tip_y))

        pygame.draw.rect(screen, self.dropdown_color, list_rect)
        pygame.draw.rect(screen, self.border_color, list_rect, 1)

        visible_rows = layout.get('visible_rows') or []
        mouse_pos = pygame.mouse.get_pos()
        selected_vehicle_id = layout.get('selected_vehicle_id')

        if visible_rows:
            for entry, row_rect in visible_rows:
                entry_id = entry['id']
                if selected_vehicle_id == entry_id:
                    pygame.draw.rect(screen, (90, 110, 150), row_rect)
                elif row_rect.collidepoint(mouse_pos):
                    pygame.draw.rect(screen, self.hover_color, row_rect)

                name = str(entry['name'])
                if len(name) > 25:
                    name = name[:22] + "..."
                text_surface = self.small_font.render(name, True, self.text_color)
                screen.blit(text_surface, (row_rect.x + 5, row_rect.y + 5))
        else:
            placeholder_surface = self.small_font.render(self._placeholder_text, True, (180, 180, 180))
            text_rect = placeholder_surface.get_rect(center=list_rect.center)
            screen.blit(placeholder_surface, text_rect)

        total_entries = layout.get('count', 0)
        visible_count = len(visible_rows)
        if self.spawned_scroll_offset > 0:
            pygame.draw.polygon(screen, (150, 150, 150), [
                (list_rect.right - 10, list_rect.top + 6),
                (list_rect.right - 4, list_rect.top + 12),
                (list_rect.right - 16, list_rect.top + 12),
            ])
        if isinstance(total_entries, int) and total_entries > visible_count + self.spawned_scroll_offset:
            pygame.draw.polygon(screen, (150, 150, 150), [
                (list_rect.right - 10, list_rect.bottom - 6),
                (list_rect.right - 4, list_rect.bottom - 12),
                (list_rect.right - 16, list_rect.bottom - 12),
            ])

    def _process_spawned_entry_click(self, vehicle_id: int) -> bool:
        current_time = pygame.time.get_ticks()
        double_clicked = (
            self._last_spawned_click_id == vehicle_id and
            (current_time - self._last_spawned_click_time) <= self._double_click_ms
        )
        self._last_spawned_click_id = vehicle_id
        self._last_spawned_click_time = current_time

        actor = self._get_actor_by_id(vehicle_id)
        if not actor:
            print("Vehicle is no longer available.")
            self._spawned_layout = None
            return True

        processor = self._get_camera_processor()
        if processor:
            processor.select_vehicle_actor(actor, focus_camera=double_clicked)
        return True

    def _get_actor_by_id(self, vehicle_id: int):
        processor = self._get_camera_processor()
        if not processor:
            return None
        for actor in getattr(processor, "spawned_vehicles", []):
            if actor and actor.id == vehicle_id and actor.is_alive:
                return actor
        return None

    def _handle_spawned_section_click(self, mouse_pos) -> bool:
        layout = self._ensure_spawned_layout()
        section_rect = layout.get('section_rect')
        if not isinstance(section_rect, pygame.Rect) or not section_rect.collidepoint(mouse_pos):
            return False

        if not self._spawned_item_hitboxes:
            return True

        for vehicle_id, item_rect in self._spawned_item_hitboxes:
            if item_rect.collidepoint(mouse_pos):
                return self._process_spawned_entry_click(vehicle_id)
        return True

    def handle_click(self, mouse_pos):
        if self._handle_spawned_section_click(mouse_pos):
            return True
        return super().handle_click(mouse_pos)

    def handle_scroll(self, mouse_pos, scroll_direction):
        layout = self._ensure_spawned_layout()
        list_rect = layout.get('list_rect')
        section_rect = layout.get('section_rect')

        if ((isinstance(list_rect, pygame.Rect) and list_rect.collidepoint(mouse_pos)) or
                (isinstance(section_rect, pygame.Rect) and section_rect.collidepoint(mouse_pos))):
            entries = layout.get('entries', [])
            if isinstance(entries, list) and entries:
                reversed_scroll = -scroll_direction
                max_scroll = max(0, len(entries) - self.max_visible_items)
                new_offset = max(0, min(max_scroll, self.spawned_scroll_offset + reversed_scroll))
                if new_offset != self.spawned_scroll_offset:
                    self.spawned_scroll_offset = new_offset
                    self._spawned_layout = None
                    self._ensure_spawned_layout(force=True)
            return True

        return super().handle_scroll(mouse_pos, scroll_direction)


class EgoVehicleSelectionMenu(ActorSelectionMenu):
    """Selection menu for ego vehicle placement (single blueprint)."""

    _MODEL_ID = "vehicle.lexus.utlexus"
    _EGO_HEADER_MARGIN = 18
    _EGO_HEADER_HEIGHT = 24
    _EGO_ROW_HEIGHT = 28
    _EGO_BOTTOM_PADDING = 30

    def __init__(self):
        super().__init__(
            title="Ego Vehicle",
            blueprint_filter=self._MODEL_ID,
            fallback_id=self._MODEL_ID,
            fallback_name="Lexus Ego Vehicle",
            display_transform=self._format_vehicle_name
        )
        self._camera_processor_ref: Optional["weakref.ReferenceType[CameraImageProcessor]"] = None
        self._double_click_ms = 350
        self._last_row_click_time = 0
        self._ego_tip_height = self.small_font.get_linesize()
        self._ego_section_height = (
            self._EGO_HEADER_MARGIN +
            self._EGO_HEADER_HEIGHT +
            self._ego_tip_height +
            self._EGO_ROW_HEIGHT +
            self._EGO_BOTTOM_PADDING
        )

    def _get_spawn_tip_lines(self) -> List[str]:
        return [
            "Tip: Ctrl+Left click to spawn snapped to lane",
            "Tip: Ctrl+Shift+Left click for free placement",
        ]

    @staticmethod
    def _format_vehicle_name(actor_id):
        return actor_id.replace('vehicle.', '').replace('_', ' ').title()

    def set_camera_processor(self, camera_processor: Optional["CameraImageProcessor"]) -> None:
        self._camera_processor_ref = weakref.ref(camera_processor) if camera_processor else None

    def _get_camera_processor(self) -> Optional["CameraImageProcessor"]:
        if not self._camera_processor_ref:
            return None
        return self._camera_processor_ref()

    def initialize_ego_vehicle(self, world):
        try:
            blueprint_library = world.get_blueprint_library()
            blueprint_library.find(self._MODEL_ID)  # Ensure blueprint exists
            self.available_ids = [self._MODEL_ID]
            self.display_names = [self._format_vehicle_name(self._MODEL_ID)]
            self.selected_index = 0
            self.scroll_offset = 0
        except Exception as exc:
            print(f"Error initializing ego vehicle menu: {exc}")
            self.available_ids = [self.fallback_id]
            self.display_names = [self.fallback_name]
            self.selected_index = 0
            self.scroll_offset = 0

    def get_selected_ego_vehicle(self):
        return self.get_selected_actor()

    def _get_ego_actor(self):
        processor = self._get_camera_processor()
        if not processor:
            return None
        actor = processor.get_editor_ego_actor()
        if actor:
            return actor
        actor = processor.get_ego_vehicle_actor()
        if actor:
            return actor
        ego_id = processor.ego_vehicle_id
        if ego_id:
            for candidate in getattr(processor, "spawned_vehicles", []):
                if candidate and candidate.id == ego_id and candidate.is_alive:
                    return candidate
        return None

    def _compute_ego_layout(self) -> Dict[str, object]:
        base_height = 120
        dropdown_list_height = 0
        dropdown_padding = 30 if self.dropdown_open else 0
        if self.dropdown_open:
            visible_items = min(self.max_visible_items, len(self.display_names) - self.scroll_offset)
            dropdown_list_height = visible_items * self.item_height
        extra_top = self.base_y + base_height + dropdown_list_height + dropdown_padding
        section_rect = pygame.Rect(self.base_x, extra_top, self.menu_width, self._ego_section_height)
        header_y = section_rect.y + self._EGO_HEADER_MARGIN
        row_top = header_y + self._EGO_HEADER_HEIGHT + self._ego_tip_height + 6
        row_rect = pygame.Rect(self.base_x + 10, row_top, self.menu_width - 40, self._EGO_ROW_HEIGHT)
        return {
            'section_rect': section_rect,
            'header_y': header_y,
            'tip_y': header_y + self._EGO_HEADER_HEIGHT,
            'row_rect': row_rect,
        }

    def get_extra_height(self) -> int:
        return self._ego_section_height

    def render_extra_content(self, screen, menu_x: int, extra_top: int) -> None:
        layout = self._compute_ego_layout()
        section_rect = layout['section_rect']
        header_y = layout['header_y']
        tip_y = layout['tip_y']
        row_rect = layout['row_rect']

        processor = self._get_camera_processor()
        actor = self._get_ego_actor()
        header_surface = self.small_font.render("Ego Vehicle Instance", True, self.text_color)
        screen.blit(header_surface, (menu_x + 10, header_y))

        tip_surface = self.small_font.render("Tip: double-click to focus camera", True, (200, 200, 200))
        screen.blit(tip_surface, (menu_x + 10, tip_y))

        pygame.draw.rect(screen, self.dropdown_color, row_rect)
        pygame.draw.rect(screen, self.border_color, row_rect, 1)

        mouse_pos = pygame.mouse.get_pos()
        is_selected = False
        if processor and processor.selected_vehicle and not processor.selected_vehicle_is_pedestrian:
            is_selected = processor.is_ego_vehicle(processor.selected_vehicle.id)

        if actor:
            if is_selected:
                pygame.draw.rect(screen, (90, 110, 150), row_rect)
            elif row_rect.collidepoint(mouse_pos):
                pygame.draw.rect(screen, self.hover_color, row_rect)
            name = self._format_vehicle_name(actor.type_id)
            label = f"{name} (ID {actor.id})"
        else:
            label = "No ego vehicle spawned"
            if row_rect.collidepoint(mouse_pos):
                pygame.draw.rect(screen, self.hover_color, row_rect)

        text_surface = self.small_font.render(label, True, self.text_color)
        screen.blit(text_surface, (row_rect.x + 5, row_rect.y + 5))

    def _handle_ego_row_click(self, mouse_pos) -> bool:
        layout = self._compute_ego_layout()
        row_rect = layout['row_rect']
        if not row_rect.collidepoint(mouse_pos):
            return False

        actor = self._get_ego_actor()
        if not actor:
            return True

        current_time = pygame.time.get_ticks()
        double_clicked = (current_time - self._last_row_click_time) <= self._double_click_ms
        self._last_row_click_time = current_time

        processor = self._get_camera_processor()
        if processor:
            processor.select_vehicle_actor(actor, focus_camera=double_clicked)
        return True

    def handle_click(self, mouse_pos):
        if self._handle_ego_row_click(mouse_pos):
            return True
        return super().handle_click(mouse_pos)


class PedestrianSelectionMenu(ActorSelectionMenu):
    """Pedestrian-specific selection menu wrapper."""

    _SPAWNED_HEADER_MARGIN = 18
    _SPAWNED_HEADER_HEIGHT = 24
    _SPAWNED_BOTTOM_PADDING = 30

    def __init__(self):
        super().__init__(
            title="Pedestrian",
            blueprint_filter="walker.pedestrian.*",
            fallback_id="walker.pedestrian.0001",
            fallback_name="Pedestrian 0001",
            display_transform=self._format_pedestrian_name
        )
        self._camera_processor_ref: Optional["weakref.ReferenceType[CameraImageProcessor]"] = None
        self.spawned_scroll_offset = 0
        self._spawned_layout: Optional[Dict[str, object]] = None
        self._spawned_item_hitboxes: List[Tuple[int, pygame.Rect]] = []
        self._spawned_section_rect: Optional[pygame.Rect] = None
        self._last_spawned_click_id: Optional[int] = None
        self._last_spawned_click_time = 0
        self._double_click_ms = 350
        self._placeholder_text = "No pedestrians added yet"

    @staticmethod
    def _format_pedestrian_name(actor_id):
        return actor_id.replace('walker.pedestrian.', 'Pedestrian ').replace('_', ' ').title()

    def set_camera_processor(self, camera_processor: Optional["CameraImageProcessor"]) -> None:
        self._camera_processor_ref = weakref.ref(camera_processor) if camera_processor else None
        self._spawned_layout = None
        self._spawned_item_hitboxes = []
        self._spawned_section_rect = None

    def _get_camera_processor(self) -> Optional["CameraImageProcessor"]:
        if not self._camera_processor_ref:
            return None
        return self._camera_processor_ref()

    def initialize_pedestrians(self, world):
        self.initialize(world)

    def get_selected_pedestrian(self):
        return self.get_selected_actor()

    def _build_spawned_entries(self) -> List[Dict[str, Union[int, str]]]:
        processor = self._get_camera_processor()
        entries: List[Dict[str, Union[int, str]]] = []
        if not processor:
            return entries

        for actor in getattr(processor, "spawned_vehicles", []):
            if not actor or not actor.is_alive:
                continue
            if not actor.type_id.startswith('walker.'):
                continue
            entries.append({
                'id': actor.id,
                'name': self._format_pedestrian_name(actor.type_id),
            })
        entries.sort(key=lambda item: str(item['name']).lower())
        return entries

    def _get_selected_actor_id(self) -> Optional[int]:
        processor = self._get_camera_processor()
        if not processor or not processor.selected_vehicle or not processor.selected_vehicle_is_pedestrian:
            return None
        return processor.selected_vehicle.id

    def _get_spawn_tip_lines(self) -> List[str]:
        return [
            "Tip: Ctrl+Left click to spawn at mouse position",
        ]

    def _ensure_spawned_layout(self, *, force: bool = False) -> Dict[str, object]:
        if self._spawned_layout is not None and not force:
            return self._spawned_layout

        entries = self._build_spawned_entries()
        max_scroll = max(0, len(entries) - self.max_visible_items)
        if self.spawned_scroll_offset > max_scroll:
            self.spawned_scroll_offset = max_scroll

        visible_entries = entries[self.spawned_scroll_offset:self.spawned_scroll_offset + self.max_visible_items]
        list_rows = max(len(visible_entries), 1)
        list_height = list_rows * self.item_height

        dropdown_list_height = 0
        dropdown_padding = 30 if self.dropdown_open else 0
        if self.dropdown_open:
            visible_dropdown = min(self.max_visible_items, len(self.display_names) - self.scroll_offset)
            dropdown_list_height = visible_dropdown * self.item_height

        extra_top = self.base_y + 120 + dropdown_list_height + dropdown_padding
        tip_height = self.small_font.get_height() + 2
        header_block_height = self._SPAWNED_HEADER_HEIGHT + tip_height
        section_height = (
            self._SPAWNED_HEADER_MARGIN +
            header_block_height +
            list_height +
            self._SPAWNED_BOTTOM_PADDING
        )
        section_rect = pygame.Rect(self.base_x, extra_top, self.menu_width, section_height)
        header_y = section_rect.y + self._SPAWNED_HEADER_MARGIN
        list_top = header_y + header_block_height + 6
        list_rect = pygame.Rect(self.base_x + 10, list_top, self.menu_width - 40, list_height)

        visible_rows: List[Tuple[Dict[str, Union[int, str]], pygame.Rect]] = []
        row_y = list_rect.y
        for entry in visible_entries:
            row_rect = pygame.Rect(list_rect.x, row_y, list_rect.width, self.item_height)
            visible_rows.append((entry, row_rect))
            row_y += self.item_height

        self._spawned_item_hitboxes = [(entry['id'], rect) for entry, rect in visible_rows]
        self._spawned_section_rect = section_rect
        layout: Dict[str, object] = {
            'entries': entries,
            'visible_rows': visible_rows,
            'section_rect': section_rect,
            'list_rect': list_rect,
            'header_y': header_y,
            'tip_y': header_y + self._SPAWNED_HEADER_HEIGHT,
            'total_height': section_height,
            'count': len(entries),
            'selected_actor_id': self._get_selected_actor_id(),
        }
        self._spawned_layout = layout
        return layout

    def get_extra_height(self) -> int:
        layout = self._ensure_spawned_layout(force=True)
        return int(layout.get('total_height', 0))

    def render_extra_content(self, screen, menu_x: int, extra_top: int) -> None:
        layout = self._ensure_spawned_layout()
        section_rect = layout.get('section_rect')
        list_rect = layout.get('list_rect')
        header_y = layout.get('header_y', extra_top)
        if not isinstance(section_rect, pygame.Rect) or not isinstance(list_rect, pygame.Rect):
            return

        header_text = f"Placed Pedestrians ({layout.get('count', 0)})"
        header_surface = self.small_font.render(header_text, True, self.text_color)
        screen.blit(header_surface, (menu_x + 10, header_y))

        tip_y = layout.get('tip_y', header_y + self._SPAWNED_HEADER_HEIGHT)
        tip_surface = self.small_font.render("Tip: double-click to focus camera", True, (200, 200, 200))
        screen.blit(tip_surface, (menu_x + 10, tip_y))

        pygame.draw.rect(screen, self.dropdown_color, list_rect)
        pygame.draw.rect(screen, self.border_color, list_rect, 1)

        visible_rows = layout.get('visible_rows') or []
        mouse_pos = pygame.mouse.get_pos()
        selected_actor_id = layout.get('selected_actor_id')

        if visible_rows:
            for entry, row_rect in visible_rows:
                entry_id = entry['id']
                if selected_actor_id == entry_id:
                    pygame.draw.rect(screen, (90, 110, 150), row_rect)
                elif row_rect.collidepoint(mouse_pos):
                    pygame.draw.rect(screen, self.hover_color, row_rect)

                name = str(entry['name'])
                if len(name) > 25:
                    name = name[:22] + "..."
                text_surface = self.small_font.render(name, True, self.text_color)
                screen.blit(text_surface, (row_rect.x + 5, row_rect.y + 5))
        else:
            placeholder_surface = self.small_font.render(self._placeholder_text, True, (180, 180, 180))
            text_rect = placeholder_surface.get_rect(center=list_rect.center)
            screen.blit(placeholder_surface, text_rect)

        total_entries = layout.get('count', 0)
        visible_count = len(visible_rows)
        if self.spawned_scroll_offset > 0:
            pygame.draw.polygon(screen, (150, 150, 150), [
                (list_rect.right - 10, list_rect.top + 6),
                (list_rect.right - 4, list_rect.top + 12),
                (list_rect.right - 16, list_rect.top + 12),
            ])
        if isinstance(total_entries, int) and total_entries > visible_count + self.spawned_scroll_offset:
            pygame.draw.polygon(screen, (150, 150, 150), [
                (list_rect.right - 10, list_rect.bottom - 6),
                (list_rect.right - 4, list_rect.bottom - 12),
                (list_rect.right - 16, list_rect.bottom - 12),
            ])

    def _process_spawned_entry_click(self, actor_id: int) -> bool:
        current_time = pygame.time.get_ticks()
        double_clicked = (
            self._last_spawned_click_id == actor_id and
            (current_time - self._last_spawned_click_time) <= self._double_click_ms
        )
        self._last_spawned_click_id = actor_id
        self._last_spawned_click_time = current_time

        actor = self._get_actor_by_id(actor_id)
        if not actor:
            print("Pedestrian is no longer available.")
            self._spawned_layout = None
            return True

        processor = self._get_camera_processor()
        if processor:
            processor.select_vehicle_actor(actor, focus_camera=double_clicked)
        return True

    def _get_actor_by_id(self, actor_id: int):
        processor = self._get_camera_processor()
        if not processor:
            return None
        for actor in getattr(processor, "spawned_vehicles", []):
            if actor and actor.id == actor_id and actor.is_alive and actor.type_id.startswith('walker.'):
                return actor
        return None

    def _handle_spawned_section_click(self, mouse_pos) -> bool:
        layout = self._ensure_spawned_layout()
        section_rect = layout.get('section_rect')
        if not isinstance(section_rect, pygame.Rect) or not section_rect.collidepoint(mouse_pos):
            return False

        if not self._spawned_item_hitboxes:
            return True

        for actor_id, item_rect in self._spawned_item_hitboxes:
            if item_rect.collidepoint(mouse_pos):
                return self._process_spawned_entry_click(actor_id)
        return True

    def handle_click(self, mouse_pos):
        if self._handle_spawned_section_click(mouse_pos):
            return True
        return super().handle_click(mouse_pos)

    def handle_scroll(self, mouse_pos, scroll_direction):
        layout = self._ensure_spawned_layout()
        list_rect = layout.get('list_rect')
        section_rect = layout.get('section_rect')

        if ((isinstance(list_rect, pygame.Rect) and list_rect.collidepoint(mouse_pos)) or
                (isinstance(section_rect, pygame.Rect) and section_rect.collidepoint(mouse_pos))):
            entries = layout.get('entries', [])
            if isinstance(entries, list) and entries:
                reversed_scroll = -scroll_direction
                max_scroll = max(0, len(entries) - self.max_visible_items)
                new_offset = max(0, min(max_scroll, self.spawned_scroll_offset + reversed_scroll))
                if new_offset != self.spawned_scroll_offset:
                    self.spawned_scroll_offset = new_offset
                    self._spawned_layout = None
                    self._ensure_spawned_layout(force=True)
            return True

        return super().handle_scroll(mouse_pos, scroll_direction)


class TrafficLightGroupSelectionMenu:
    """Selection list for traffic light groups (stop lines) that have triggers."""

    _SECTION_MARGIN = 18
    _SECTION_HEADER_HEIGHT = 24
    _SECTION_BOTTOM_PADDING = 30

    def __init__(self):
        self.title = "Triggers"
        self.menu_width = 300
        self.base_x = 10
        self.base_y = 120

        self.font = pygame.font.Font(None, 20)
        self.small_font = pygame.font.Font(None, 16)

        self.bg_color = (40, 40, 40, 200)
        self.dropdown_color = (60, 60, 60)
        self.hover_color = (80, 80, 80)
        self.text_color = (255, 255, 255)
        self.border_color = (100, 100, 100)

        self.scroll_offset = 0
        self.max_visible_items = 10
        self.item_height = 25

        self._camera_processor_ref: Optional["weakref.ReferenceType[CameraImageProcessor]"] = None
        self._layout: Optional[Dict[str, object]] = None
        self._item_hitboxes: List[Tuple[Tuple[str, Tuple], pygame.Rect]] = []
        self._section_rect: Optional[pygame.Rect] = None

        self._last_click_key: Optional[Tuple[str, Tuple]] = None
        self._last_click_time_ms = 0
        self._double_click_ms = 350

        self._empty_title = "No Traffic Light Group triggers yet"
        self._empty_tip = "Tip: Select a stop line, then click Add Trigger"

    def set_vertical_offset(self, top_offset: int) -> None:
        self.base_y = int(top_offset)

    def set_camera_processor(self, camera_processor: Optional["CameraImageProcessor"]) -> None:
        self._camera_processor_ref = weakref.ref(camera_processor) if camera_processor else None
        self._layout = None
        self._item_hitboxes = []
        self._section_rect = None

    def _get_camera_processor(self) -> Optional["CameraImageProcessor"]:
        if not self._camera_processor_ref:
            return None
        return self._camera_processor_ref()

    def _stop_line_center_xy(
        self,
        processor: "CameraImageProcessor",
        group: TrafficLightGroupData,
    ) -> Optional[Tuple[float, float]]:
        try:
            center_location = processor._compute_traffic_light_group_trigger_center(group)
        except Exception:
            center_location = None
        if center_location is not None:
            try:
                return float(center_location.x), float(center_location.y)
            except Exception:
                return None

        center = getattr(group, "center_location", None)
        if center:
            try:
                return float(center[0]), float(center[1])
            except Exception:
                return None

        reference = getattr(group, "reference_light", None)
        if reference:
            try:
                location = reference.get_transform().location
                return float(location.x), float(location.y)
            except Exception:
                return None
        return None

    def _build_stop_line_number_map(
        self,
        processor: "CameraImageProcessor",
        groups: List[TrafficLightGroupData],
    ) -> Dict[Tuple[str, Tuple], int]:
        records: List[Tuple[Tuple[float, float], Tuple[str, Tuple]]] = []
        for group in groups:
            key = processor._traffic_light_trigger_key(group=group)
            if not key:
                continue
            center_xy = self._stop_line_center_xy(processor, group)
            if center_xy is None:
                sort_xy = (float("inf"), float("inf"))
            else:
                x, y = center_xy
                sort_xy = (round(y, 2), round(x, 2))
            records.append((sort_xy, key))

        records.sort(key=lambda item: (item[0][0], item[0][1], item[1][0], item[1][1]))
        return {key: idx + 1 for idx, (_center, key) in enumerate(records)}

    def _build_entries(self) -> List[Dict[str, object]]:
        processor = self._get_camera_processor()
        if not processor:
            return []

        groups = list(getattr(processor, "traffic_light_groups", []) or [])
        stop_line_number_map = self._build_stop_line_number_map(processor, groups)

        entries: List[Dict[str, object]] = []
        for group in groups:
            center_payload, radius_value, resolved_key = processor._get_traffic_light_trigger_data(group=group)
            if not center_payload or radius_value is None:
                continue
            if not resolved_key:
                resolved_key = processor._traffic_light_trigger_key(group=group)
            if not resolved_key:
                continue

            stop_line_number = stop_line_number_map.get(resolved_key)
            if stop_line_number is None:
                stop_line_number = 0

            light_count = getattr(group, "cached_size", 0) or len(getattr(group, "lights", []) or [])

            entries.append(
                {
                    "key": resolved_key,
                    "group": group,
                    "stop_line_number": int(stop_line_number),
                    "light_count": int(light_count),
                }
            )

        entries.sort(key=lambda entry: int(entry.get("stop_line_number", 0) or 0))
        return entries

    def _get_selected_key(self) -> Optional[Tuple[str, Tuple]]:
        processor = self._get_camera_processor()
        if not processor:
            return None
        group = getattr(processor, "selected_traffic_light_group", None)
        if not group:
            return None
        return processor._traffic_light_trigger_key(group=group)

    def _ensure_layout(self, *, force: bool = False) -> Dict[str, object]:
        if self._layout is not None and not force:
            return self._layout

        entries = self._build_entries()
        max_scroll = max(0, len(entries) - self.max_visible_items)
        if self.scroll_offset > max_scroll:
            self.scroll_offset = max_scroll

        visible_entries = entries[self.scroll_offset:self.scroll_offset + self.max_visible_items]
        list_rows = max(len(visible_entries), 1)
        list_height = list_rows * self.item_height

        title_height = self.font.get_height() + 12
        tip_height = self.small_font.get_height()
        header_block_height = self._SECTION_HEADER_HEIGHT + tip_height
        section_height = (
            title_height +
            self._SECTION_MARGIN +
            header_block_height +
            6 +
            list_height +
            self._SECTION_BOTTOM_PADDING
        )

        section_rect = pygame.Rect(self.base_x, self.base_y, self.menu_width, section_height)
        header_y = section_rect.y + title_height + self._SECTION_MARGIN
        tip_y = header_y + self._SECTION_HEADER_HEIGHT
        list_top = tip_y + tip_height + 6
        list_rect = pygame.Rect(self.base_x + 10, list_top, self.menu_width - 40, list_height)

        visible_rows: List[Tuple[Dict[str, object], pygame.Rect]] = []
        row_y = list_rect.y
        for entry in visible_entries:
            row_rect = pygame.Rect(list_rect.x, row_y, list_rect.width, self.item_height)
            visible_rows.append((entry, row_rect))
            row_y += self.item_height

        self._item_hitboxes = [
            (cast(Tuple[str, Tuple], entry.get("key")), rect)
            for entry, rect in visible_rows
            if entry.get("key") is not None
        ]
        self._section_rect = section_rect
        layout = {
            "entries": entries,
            "visible_rows": visible_rows,
            "section_rect": section_rect,
            "list_rect": list_rect,
            "header_y": header_y,
            "tip_y": tip_y,
            "count": len(entries),
            "selected_key": self._get_selected_key(),
        }
        self._layout = layout
        return layout

    def _resolve_group(self, key: Tuple[str, Tuple]) -> Optional[TrafficLightGroupData]:
        processor = self._get_camera_processor()
        if not processor:
            return None
        group = processor._find_traffic_light_group_by_key(key)
        if group:
            return group

        layout = self._ensure_layout()
        for entry in layout.get("entries", []) or []:
            if entry.get("key") == key:
                return entry.get("group")
        return None

    def _focus_camera_on_group(self, group: TrafficLightGroupData) -> None:
        processor = self._get_camera_processor()
        if not processor:
            return

        focus_location = None
        try:
            focus_location = processor._compute_traffic_light_group_trigger_center(group)
        except Exception:
            focus_location = None

        if focus_location is None:
            center_payload, _radius_value, _key = processor._get_traffic_light_trigger_data(group=group)
            if center_payload:
                try:
                    focus_location = carla.Location(
                        float(center_payload.get("x", 0.0)),
                        float(center_payload.get("y", 0.0)),
                        float(center_payload.get("z", 0.0)),
                    )
                except Exception:
                    focus_location = None

        if focus_location is None:
            reference = getattr(group, "reference_light", None)
            if reference:
                try:
                    focus_location = reference.get_transform().location
                except Exception:
                    focus_location = None

        if focus_location is not None:
            processor.focus_camera_on_location(focus_location)

    def _process_entry_click(self, key: Tuple[str, Tuple]) -> bool:
        processor = self._get_camera_processor()
        if not processor:
            return True

        current_time = pygame.time.get_ticks()
        double_clicked = (
            self._last_click_key == key and
            (current_time - self._last_click_time_ms) <= self._double_click_ms
        )
        self._last_click_key = key
        self._last_click_time_ms = current_time

        group = self._resolve_group(key)
        if not group:
            print("Traffic light group is no longer available.")
            self._layout = None
            return True

        if getattr(processor, "placing_trigger", False):
            processor.stop_trigger_placement()

        processor.traffic_lights_visible = True
        if processor.select_traffic_light_group(group) and double_clicked:
            self._focus_camera_on_group(group)
        return True

    def handle_click(self, mouse_pos: Tuple[int, int]) -> bool:
        layout = self._ensure_layout(force=True)
        section_rect = layout.get("section_rect")
        if not isinstance(section_rect, pygame.Rect) or not section_rect.collidepoint(mouse_pos):
            return False

        processor = self._get_camera_processor()
        if processor and getattr(processor, "placing_trigger", False):
            processor.stop_trigger_placement()

        if not self._item_hitboxes:
            return True

        for key, row_rect in self._item_hitboxes:
            if row_rect.collidepoint(mouse_pos):
                return self._process_entry_click(key)
        return True

    def handle_scroll(self, mouse_pos: Tuple[int, int], scroll_direction: int) -> bool:
        layout = self._ensure_layout(force=True)
        list_rect = layout.get("list_rect")
        section_rect = layout.get("section_rect")

        if ((isinstance(list_rect, pygame.Rect) and list_rect.collidepoint(mouse_pos)) or
                (isinstance(section_rect, pygame.Rect) and section_rect.collidepoint(mouse_pos))):
            entries = layout.get("entries") or []
            if isinstance(entries, list) and entries:
                reversed_scroll = -scroll_direction
                max_scroll = max(0, len(entries) - self.max_visible_items)
                new_offset = max(0, min(max_scroll, self.scroll_offset + reversed_scroll))
                if new_offset != self.scroll_offset:
                    self.scroll_offset = new_offset
                    self._layout = None
                    self._ensure_layout(force=True)
            return True
        return False

    def render(self, screen) -> None:
        layout = self._ensure_layout(force=True)
        section_rect = layout.get("section_rect")
        list_rect = layout.get("list_rect")
        header_y = layout.get("header_y", self.base_y + self._SECTION_MARGIN)
        tip_y = layout.get("tip_y", header_y + self._SECTION_HEADER_HEIGHT)
        if not isinstance(section_rect, pygame.Rect) or not isinstance(list_rect, pygame.Rect):
            return

        section_surface = pygame.Surface(section_rect.size, pygame.SRCALPHA)
        section_surface.fill(self.bg_color)
        screen.blit(section_surface, section_rect.topleft)
        pygame.draw.rect(screen, self.border_color, section_rect, 2)

        title_surface = self.font.render(self.title, True, self.text_color)
        screen.blit(title_surface, (section_rect.x + 10, section_rect.y + 10))

        header_text = f"Traffic Light Groups ({layout.get('count', 0)})"
        header_surface = self.small_font.render(header_text, True, self.text_color)
        screen.blit(header_surface, (section_rect.x + 10, header_y))

        tip_surface = self.small_font.render("Tip: double-click to focus camera", True, (200, 200, 200))
        screen.blit(tip_surface, (section_rect.x + 10, tip_y))

        pygame.draw.rect(screen, self.dropdown_color, list_rect)
        pygame.draw.rect(screen, self.border_color, list_rect, 1)

        visible_rows = layout.get("visible_rows") or []
        mouse_pos = pygame.mouse.get_pos()
        selected_key = layout.get("selected_key")

        if visible_rows:
            for entry, row_rect in visible_rows:
                key = entry.get("key")
                if key == selected_key:
                    pygame.draw.rect(screen, (90, 110, 150), row_rect)
                elif row_rect.collidepoint(mouse_pos):
                    pygame.draw.rect(screen, self.hover_color, row_rect)

                stop_line_number = entry.get("stop_line_number", 0)
                light_count = entry.get("light_count", 0)
                label = f"Stop Line {stop_line_number} ({light_count} lights)"
                text_surface = self.small_font.render(label, True, self.text_color)
                screen.blit(text_surface, (row_rect.x + 5, row_rect.y + 5))
        else:
            empty_surface = self.small_font.render(self._empty_title, True, (180, 180, 180))
            tip_surface = self.small_font.render(self._empty_tip, True, (160, 160, 160))
            center_x = list_rect.centerx
            center_y = list_rect.centery
            empty_rect = empty_surface.get_rect(center=(center_x, center_y - 8))
            tip_rect = tip_surface.get_rect(center=(center_x, center_y + 10))
            screen.blit(empty_surface, empty_rect)
            screen.blit(tip_surface, tip_rect)

        total_entries = int(layout.get("count", 0) or 0)
        visible_count = len(visible_rows)
        if self.scroll_offset > 0:
            pygame.draw.polygon(screen, (150, 150, 150), [
                (list_rect.right - 10, list_rect.top + 6),
                (list_rect.right - 4, list_rect.top + 12),
                (list_rect.right - 16, list_rect.top + 12),
            ])
        if total_entries > visible_count + self.scroll_offset:
            pygame.draw.polygon(screen, (150, 150, 150), [
                (list_rect.right - 10, list_rect.bottom - 6),
                (list_rect.right - 4, list_rect.bottom - 12),
                (list_rect.right - 16, list_rect.bottom - 12),
            ])



class MapSelectionMenu:
    """Dropdown menu for selecting and loading CARLA maps."""

    def __init__(self, world_handler):
        self.world_handler = world_handler
        self.title = "Open Map"
        self.entries = []
        self.selected_index = 0

        self.menu_width = 250
        self.item_height = 35
        self.max_visible_items = 15
        self.dropdown_open = True

        self.scroll_offset = 0

        self.font = pygame.font.Font(None, 20)
        self.small_font = pygame.font.Font(None, 16)
        self.bg_color = (40, 40, 40, 200)
        self.dropdown_color = (60, 60, 60)
        self.hover_color = (80, 80, 80)
        self.text_color = (255, 255, 255)
        self.border_color = (100, 100, 100)

    def initialize(self):
        """Fetch available maps from the currently connected server."""
        self.entries = []
        self.selected_index = 0
        self.scroll_offset = 0

        profile = getattr(self.world_handler, "connection_profile", None)
        client = getattr(self.world_handler, "client", None)

        target_host = '127.0.0.1'
        target_port = 2000
        entry_type = 'local_map'
        if profile is not None:
            target_host = profile.host
            target_port = profile.port
            if profile.is_remote:
                entry_type = 'remote_map'

        try:
            map_client = client or carla.Client(target_host, target_port)
            map_client.set_timeout(10.0)
            all_maps = map_client.get_available_maps()

            map_entries = []
            name_counts = {}
            for map_path in all_maps:
                map_name = map_path.split('/')[-1]
                base = map_name.split('_Tile_')[0] if '_Tile_' in map_name else map_name
                name_counts[base] = name_counts.get(base, 0) + 1

            for map_path in all_maps:
                map_name = map_path.split('/')[-1]
                base = map_name.split('_Tile_')[0] if '_Tile_' in map_name else map_name
                if '_Tile_' in map_name:
                    continue

                if name_counts[base] > 1:
                    parts = map_path.split('/')
                    if len(parts) >= 3:
                        parent = '/'.join(parts[-3:-1])
                        display = f"{base} ({parent})"
                    else:
                        display = f"{base} ({map_path})"
                else:
                    display = base

                map_entries.append((map_path, display))

            map_entries.sort(key=lambda entry: entry[1].lower())

            for map_path, display_name in map_entries:
                self.entries.append({
                    'type': entry_type,
                    'value': map_path,
                    'display': display_name
                })

            context = 'remote' if entry_type == 'remote_map' else 'local'
            print(f"Found {len(self.entries)} available maps ({context})")
        except Exception as exc:
            print(f"Error fetching available maps: {exc}")

    def set_vertical_offset(self, top_offset):
        self.base_y = top_offset

    def handle_click(self, mouse_pos):
        if not self.entries:
            return False

        button_rect = self.world_handler.open_map_button_rect
        if not button_rect:
            return False

        menu_x = button_rect.right + 5
        menu_y = button_rect.top
        visible_items = min(self.max_visible_items, len(self.entries) - self.scroll_offset)

        for i in range(visible_items):
            actual_index = i + self.scroll_offset
            item_y = menu_y + (i * self.item_height)

            if (menu_x <= mouse_pos[0] <= menu_x + self.menu_width and
                    item_y <= mouse_pos[1] <= item_y + self.item_height):
                entry = self.entries[actual_index]
                entry_type = entry.get('type')
                map_name = entry.get('value')

                self.world_handler.map_menu_visible = False

                if entry_type == 'remote_map':
                    self.world_handler.request_remote_map_change(map_name)
                else:
                    if map_name:
                        print(f"Loading map: {entry.get('display', map_name)}")
                        self.world_handler.load_map(map_name)
                return True

        menu_height = visible_items * self.item_height
        if not (menu_x <= mouse_pos[0] <= menu_x + self.menu_width and
                menu_y <= mouse_pos[1] <= menu_y + menu_height):
            return False

        return False

    def handle_scroll(self, mouse_pos, direction):
        if not self.entries:
            return False

        button_rect = self.world_handler.open_map_button_rect
        if not button_rect:
            return False

        menu_x = button_rect.right + 5
        menu_y = button_rect.top
        visible_items = min(self.max_visible_items, len(self.entries))
        menu_height = visible_items * self.item_height

        if (menu_x <= mouse_pos[0] <= menu_x + self.menu_width and
                menu_y <= mouse_pos[1] <= menu_y + menu_height):
            max_scroll = max(0, len(self.entries) - self.max_visible_items)
            self.scroll_offset = max(0, min(max_scroll, self.scroll_offset - direction))
            return True

        return False

    def render(self, screen, mouse_pos):
        if not self.entries:
            return

        button_rect = self.world_handler.open_map_button_rect
        if not button_rect:
            return

        menu_x = button_rect.right + 5
        menu_y = button_rect.top
        visible_items = min(self.max_visible_items, len(self.entries) - self.scroll_offset)
        menu_height = visible_items * self.item_height

        menu_surface = pygame.Surface((self.menu_width, menu_height), pygame.SRCALPHA)
        menu_surface.fill(self.bg_color)
        screen.blit(menu_surface, (menu_x, menu_y))

        menu_rect = pygame.Rect(menu_x, menu_y, self.menu_width, menu_height)
        pygame.draw.rect(screen, self.border_color, menu_rect, 2)

        current_map = self.world_handler._get_map_display_name()

        for i in range(visible_items):
            actual_index = i + self.scroll_offset
            entry = self.entries[actual_index]
            item_y = menu_y + (i * self.item_height)
            item_rect = pygame.Rect(menu_x, item_y, self.menu_width, self.item_height)

            is_hovered = item_rect.collidepoint(mouse_pos)
            if is_hovered:
                hover_surface = pygame.Surface((self.menu_width, self.item_height), pygame.SRCALPHA)
                hover_surface.fill(self.hover_color)
                screen.blit(hover_surface, (menu_x, item_y))

            if i > 0:
                pygame.draw.line(screen, self.border_color,
                                 (menu_x, item_y),
                                 (menu_x + self.menu_width, item_y), 1)

            item_text = entry.get('display', 'Unknown')
            entry_type = entry.get('type')
            entry_value = entry.get('value', '') or ''
            entry_short = entry_value.split('/')[-1] if entry_value else ''
            is_current = entry_short == current_map

            if entry_type == 'remote_map':
                base_color = (220, 200, 130) if is_current else (200, 200, 255)
            else:
                base_color = (255, 255, 120) if is_current else self.text_color

            text_color = (255, 255, 100) if is_hovered else base_color
            item_surface = self.font.render(item_text, True, text_color)
            text_x = menu_x + 10
            text_y = item_y + (self.item_height - item_surface.get_height()) // 2
            screen.blit(item_surface, (text_x, text_y))

        if len(self.entries) > self.max_visible_items:
            scroll_text = f"{self.scroll_offset + 1}-{self.scroll_offset + visible_items}/{len(self.entries)}"
            scroll_surface = self.small_font.render(scroll_text, True, (200, 200, 200))
            scroll_x = menu_x + self.menu_width - scroll_surface.get_width() - 5
            scroll_y = menu_y + menu_height - scroll_surface.get_height() - 5
            screen.blit(scroll_surface, (scroll_x, scroll_y))

class ScenarioMenu:
    """Menu for saving and loading scenarios."""

    def __init__(self, world_handler):
        self.world_handler = world_handler
        self.title = "Scenario"
        self.options = ["New", "Open", "Save"]

        self.menu_width = 150
        self.item_height = 35

        # UI settings
        self.font = pygame.font.Font(None, 20)
        self.small_font = pygame.font.Font(None, 16)
        self.bg_color = (40, 40, 40, 200)
        self.hover_color = (80, 80, 80)
        self.text_color = (255, 255, 255)
        self.border_color = (100, 100, 100)

    def _get_items(self) -> List[Tuple[str, str, bool, Optional[str]]]:
        """Return (action, label, enabled, path) tuples for menu rows."""
        items: List[Tuple[str, str, bool, Optional[str]]] = []
        recent_entries = getattr(self.world_handler, "recent_scenarios", []) or []
        for option in self.options:
            action = option.lower()
            items.append((action, option, True, None))
            if action == "open":
                for entry in recent_entries[:3]:
                    label = entry.get('name') or os.path.basename(entry.get('path', '') or '')
                    path = entry.get('path')
                    enabled = bool(path and os.path.isfile(path))
                    items.append(("recent", label, enabled, path))
        return items

    def handle_click(self, mouse_pos):
        """Handle mouse clicks on the menu."""
        # Get button position from world_handler
        button_rect = self.world_handler.open_scenario_button_rect
        if not button_rect:
            return False

        items = self._get_items()

        # Calculate menu position (to the right of button)
        menu_x = button_rect.right + 5
        menu_y = button_rect.top

        # Check each option for clicks
        for i, (action, label, enabled, path) in enumerate(items):
            item_y = menu_y + (i * self.item_height)

            # Check if click is within this item's bounds
            if (menu_x <= mouse_pos[0] <= menu_x + self.menu_width and
                item_y <= mouse_pos[1] <= item_y + self.item_height):

                # Execute the selected action
                if not enabled:
                    return True
                if action == "recent":
                    print("Opening recent scenario...")
                    self.world_handler.scenario_menu_visible = False
                    if path:
                        self.world_handler._load_scenario_from_path(path)
                    else:
                        self.world_handler._open_last_scenario_from_cache()
                elif action == "new":
                    print("Starting new scenario...")
                    self.world_handler.scenario_menu_visible = False
                    self.world_handler.reset_current_scenario()
                elif action == "open":
                    print("Opening scenario...")
                    self.world_handler.scenario_menu_visible = False
                    self.world_handler.load_scenario_with_dialog()
                elif action == "save":
                    print("Saving scenario...")
                    self.world_handler.scenario_menu_visible = False
                    self.world_handler.save_scenario_with_dialog()
                return True

        # Click outside menu - don't close it here (handled in main event loop)
        return False

    def render(self, screen, mouse_pos):
        """Render the scenario menu (horizontal layout to the right of button)."""
        # Get button position from world_handler
        button_rect = self.world_handler.open_scenario_button_rect
        if not button_rect:
            return

        items = self._get_items()

        # Position menu to the right of the button
        menu_x = button_rect.right + 5
        menu_y = button_rect.top

        # Calculate dimensions
        menu_height = len(items) * self.item_height

        # Draw semi-transparent background
        menu_surface = pygame.Surface((self.menu_width, menu_height), pygame.SRCALPHA)
        menu_surface.fill(self.bg_color)
        screen.blit(menu_surface, (menu_x, menu_y))

        # Draw border
        menu_rect = pygame.Rect(menu_x, menu_y, self.menu_width, menu_height)
        pygame.draw.rect(screen, self.border_color, menu_rect, 2)

        # Draw each option
        for i, (action, label, enabled, _path) in enumerate(items):
            item_y = menu_y + (i * self.item_height)
            item_rect = pygame.Rect(menu_x, item_y, self.menu_width, self.item_height)

            # Highlight hovered item
            is_hovered = item_rect.collidepoint(mouse_pos)
            if is_hovered:
                hover_surface = pygame.Surface((self.menu_width, self.item_height), pygame.SRCALPHA)
                hover_surface.fill(self.hover_color)
                screen.blit(hover_surface, (menu_x, item_y))

            # Draw separator line
            if i > 0:
                pygame.draw.line(screen, self.border_color,
                               (menu_x, item_y),
                               (menu_x + self.menu_width, item_y), 1)

            # Draw option text
            is_recent = action == "recent"
            text_color = (255, 255, 100) if (is_hovered and enabled) else ((180, 180, 180) if not enabled else self.text_color)
            display_label = label
            if len(display_label) > 30:
                display_label = display_label[:27] + "..."
            font = self.small_font if is_recent else self.font
            item_surface = font.render(display_label, True, text_color)
            text_x = menu_x + 10
            if is_recent:
                text_x += 10  # indent sub-row
            text_y = item_y + (self.item_height - item_surface.get_height()) // 2
            screen.blit(item_surface, (text_x, text_y))


class GPUSelectionDialog(UIWindow):
    """Modal window for selecting a GPU/port option."""

    def __init__(self, rect: pygame.Rect, manager: UIManager, options: List[Dict[str, Union[str, int]]], title: str = "Select GPU"):
        super().__init__(
            rect,
            manager,
            window_display_title=title,
            resizable=False,
            always_on_top=True,
        )
        self.set_blocking(True)
        self.options = options
        self.label_to_option = {option["label"]: option for option in options}
        self.selected_label: Optional[str] = None
        self.confirmed: bool = False

        container_width, container_height = self.get_container().get_size()
        list_rect = pygame.Rect(
            10,
            40,
            max(100, container_width - 20),
            max(60, container_height - 90),
        )

        self.selection_list = UISelectionList(
            relative_rect=list_rect,
            item_list=[option["label"] for option in options],
            manager=manager,
            container=self,
            allow_double_clicks=True,
            object_id="#gpu_selection_list",
        )

        button_width = 110
        button_height = 32
        button_y = container_height - button_height - 10

        self.cancel_button = UIButton(
            relative_rect=pygame.Rect(
                container_width - button_width - 10,
                button_y,
                button_width,
                button_height,
            ),
            text="Cancel",
            manager=manager,
            container=self,
            object_id="#gpu_cancel_button",
            anchors={
                "left": "right",
                "right": "right",
                "top": "bottom",
                "bottom": "bottom",
            },
        )

        self.ok_button = UIButton(
            relative_rect=pygame.Rect(
                container_width - (2 * button_width) - 20,
                button_y,
                button_width,
                button_height,
            ),
            text="Select",
            manager=manager,
            container=self,
            object_id="#gpu_select_button",
            anchors={
                "left": "right",
                "right": "right",
                "top": "bottom",
                "bottom": "bottom",
                "right_target": self.cancel_button,
            },
        )
        self.ok_button.disable()

    def process_event(self, event: pygame.event.Event) -> bool:
        handled = super().process_event(event)

        if event.type == UI_SELECTION_LIST_NEW_SELECTION and event.ui_element == self.selection_list:
            self.selected_label = event.text
            self.ok_button.enable()

        if event.type == UI_SELECTION_LIST_DOUBLE_CLICKED_SELECTION and event.ui_element == self.selection_list:
            self.selected_label = event.text
            self.confirm_selection()

        if event.type == UI_BUTTON_PRESSED:
            if event.ui_element == self.ok_button and self.selected_label:
                self.confirm_selection()
            elif event.ui_element == self.cancel_button:
                self.selected_label = None
                self.confirmed = False
                self.kill()

        return handled

    def confirm_selection(self):
        if self.selected_label:
            self.confirmed = True
            self.kill()

    def get_selected_option(self) -> Optional[Dict[str, Union[str, int]]]:
        if not self.selected_label:
            return None
        return self.label_to_option.get(self.selected_label)


class TextInputDialog(UIWindow):
    """Simple modal dialog for text input (used for new folder names)."""

    def __init__(self, rect: pygame.Rect, manager: UIManager, title: str, prompt: str, default_text: str = ""):
        super().__init__(
            rect,
            manager,
            window_display_title=title,
            resizable=False,
            always_on_top=True,
        )
        self.set_blocking(True)

        container_width, container_height = self.get_container().get_size()

        label_rect = pygame.Rect(10, 10, container_width - 20, 30)
        self.prompt_label = UILabel(
            relative_rect=label_rect,
            text=prompt,
            manager=manager,
            container=self,
            anchors={
                "left": "left",
                "right": "right",
                "top": "top",
                "bottom": "top",
            },
        )

        entry_rect = pygame.Rect(10, 50, container_width - 20, 30)
        self.text_entry = UITextEntryLine(
            relative_rect=entry_rect,
            manager=manager,
            container=self,
            anchors={
                "left": "left",
                "right": "right",
                "top": "top",
                "bottom": "top",
            },
        )
        self.text_entry.set_text(default_text)
        self.text_entry.select_range = [0, len(default_text)]
        self.text_entry.cursor_has_moved_recently = True
        try:
            self.text_entry.focus()
        except AttributeError:
            pass

        button_width = 72
        button_height = 28
        button_y = container_height - button_height - 12
        cancel_x = container_width - button_width - 10
        ok_x = cancel_x - button_width - 10

        self.cancel_button = UIButton(
            relative_rect=pygame.Rect(cancel_x, button_y, button_width, button_height),
            text="Cancel",
            manager=manager,
            container=self,
            object_id="#text_input_cancel",
            anchors={
                "left": "left",
                "right": "left",
                "top": "top",
                "bottom": "top",
            },
        )

        self.ok_button = UIButton(
            relative_rect=pygame.Rect(ok_x, button_y, button_width, button_height),
            text="OK",
            manager=manager,
            container=self,
            object_id="#text_input_ok",
            anchors={
                "left": "left",
                "right": "left",
                "top": "top",
                "bottom": "top",
            },
        )


class RemoteConnectionDialog(UIWindow):
    """Modal window for entering remote host and port."""

    def __init__(
        self,
        rect: pygame.Rect,
        manager: UIManager,
        default_host: str = "",
        default_port: str = "",
        show_local_button: bool = True,
    ):
        super().__init__(
            rect,
            manager,
            window_display_title="Connect to Remote Server",
            resizable=False,
            always_on_top=True,
        )
        self.set_blocking(True)
        self.show_local_button = show_local_button
        container_width, container_height = self.get_container().get_size()

        label_host_rect = pygame.Rect(10, 14, container_width - 20, 24)
        UILabel(
            relative_rect=label_host_rect,
            text="Host / IP",
            manager=manager,
            container=self,
        )

        entry_host_rect = pygame.Rect(10, 40, container_width - 20, 30)
        self.host_entry = UITextEntryLine(
            relative_rect=entry_host_rect,
            manager=manager,
            container=self,
        )
        self.host_entry.set_text(default_host or "")

        label_port_rect = pygame.Rect(10, 80, container_width - 20, 24)
        UILabel(
            relative_rect=label_port_rect,
            text="Port",
            manager=manager,
            container=self,
        )

        entry_port_rect = pygame.Rect(10, 106, container_width - 20, 30)
        self.port_entry = UITextEntryLine(
            relative_rect=entry_port_rect,
            manager=manager,
            container=self,
        )
        self.port_entry.set_text(default_port or "")

        button_width = 90
        button_height = 30
        button_y = container_height - button_height - 12

        self.local_button = UIButton(
            relative_rect=pygame.Rect(10, button_y, button_width, button_height),
            text="Local",
            manager=manager,
            container=self,
        )
        if not self.show_local_button:
            try:
                self.local_button.disable()
                self.local_button.hide()
            except Exception:
                pass

        self.cancel_button = UIButton(
            relative_rect=pygame.Rect(
                container_width - button_width - 10,
                button_y,
                button_width,
                button_height,
            ),
            text="Cancel",
            manager=manager,
            container=self,
        )
        self.ok_button = UIButton(
            relative_rect=pygame.Rect(
                container_width - (2 * button_width) - 20,
                button_y,
                button_width,
                button_height,
            ),
            text="OK",
            manager=manager,
            container=self,
        )
        self.result_action: Optional[str] = None

    def process_event(self, event: pygame.event.Event) -> bool:
        handled = super().process_event(event)

        if event.type == UI_BUTTON_PRESSED:
            if event.ui_element == self.ok_button:
                self.result_action = "ok"
                self.kill()
            elif self.show_local_button and event.ui_element == self.local_button:
                self.result_action = "local"
                self.kill()
            elif event.ui_element == self.cancel_button:
                self.result_action = "cancel"
                self.kill()

        if event.type == UI_TEXT_ENTRY_FINISHED and event.ui_element in (self.host_entry, self.port_entry):
            self.result_action = "ok"
            self.kill()

        if event.type == UI_WINDOW_CLOSE and event.ui_element == self:
            self.result_action = "cancel"

        return handled

    def get_values(self) -> Dict[str, str]:
        return {
            "host": self.host_entry.get_text(),
            "port": self.port_entry.get_text(),
            "action": self.result_action or "cancel",
        }


class WeatherControlWindow(UIWindow):
    """Floating window containing sliders to adjust CARLA weather parameters."""

    _theme_initialized: bool = False

    def __init__(
        self,
        rect: pygame.Rect,
        manager: UIManager,
        specs: Tuple[WeatherParameterSpec, ...],
        on_change_live: Callable[[str, float], None],
        on_change_commit: Optional[Callable[[str, float], None]] = None,
        *,
        keyframe_count: int = 1,
        active_index: int = 0,
        active_percentage: float = 0.0,
        percent_editable: bool = True,
        can_delete: bool = False,
        on_percentage_change: Optional[Callable[[float], None]] = None,
        on_add_keyframe: Optional[Callable[[], None]] = None,
        on_delete_keyframe: Optional[Callable[[], None]] = None,
        on_prev_keyframe: Optional[Callable[[], None]] = None,
        on_next_keyframe: Optional[Callable[[], None]] = None,
        on_close: Optional[Callable[[], None]] = None,
    ):
        self._ensure_theme(manager)
        super().__init__(
            rect,
            manager,
            window_display_title="Weather Controls",
            resizable=False,
            always_on_top=True,
        )
        self.set_blocking(False)

        self._specs = specs
        self._spec_lookup: Dict[str, WeatherParameterSpec] = {spec.name: spec for spec in specs}
        self._on_change_live = on_change_live
        self._on_change_commit = on_change_commit
        self._on_close = on_close
        self._on_percentage_change = on_percentage_change
        self._on_add_keyframe = on_add_keyframe
        self._on_delete_keyframe = on_delete_keyframe
        self._on_prev_keyframe = on_prev_keyframe
        self._on_next_keyframe = on_next_keyframe
        self._suppress_callback = False
        self._keyframe_count = max(1, int(keyframe_count))
        self._active_index = max(0, min(int(active_index), self._keyframe_count - 1))
        self._active_percentage = float(active_percentage)
        self._percent_editable = bool(percent_editable)
        self._can_delete = bool(can_delete)

        self.sliders: Dict[str, UIHorizontalSlider] = {}
        self.value_labels: Dict[str, UILabel] = {}
        self._slider_to_param: Dict[UIHorizontalSlider, str] = {}
        self.percent_slider: Optional[UIHorizontalSlider] = None
        self.percent_value_label: Optional[UILabel] = None
        self.keyframe_label: Optional[UILabel] = None
        self.prev_button: Optional[UIButton] = None
        self.next_button: Optional[UIButton] = None
        self.add_button: Optional[UIButton] = None
        self.delete_button: Optional[UIButton] = None

        # Drag tracking for commit-on-release behavior
        self._active_drag_param: Optional[str] = None
        self._drag_last_value: Optional[float] = None

        container_width, _ = self.get_container().get_size()
        margin = 14
        top_margin = 16

        # Keyframe metadata
        label_rect = pygame.Rect(margin, top_margin, container_width - (2 * margin), 22)
        self.keyframe_label = UILabel(
            label_rect,
            "",
            manager,
            container=self,
            object_id="#weather_name_label",
        )
        top_margin = label_rect.bottom + 4

        slider_height = 18
        pct_value_width = 70
        percent_slider_rect = pygame.Rect(
            margin,
            top_margin,
            max(160, container_width - (2 * margin) - pct_value_width - 8),
            slider_height,
        )
        self.percent_slider = UIHorizontalSlider(
            relative_rect=percent_slider_rect,
            start_value=max(0.0, min(100.0, self._active_percentage)),
            value_range=(0.0, 100.0),
            manager=manager,
            container=self,
            object_id="#weather_slider",
            click_increment=1.0,
        )
        percent_value_rect = pygame.Rect(
            percent_slider_rect.right + 4,
            percent_slider_rect.y,
            pct_value_width,
            slider_height,
        )
        self.percent_value_label = UILabel(
            percent_value_rect,
            "",
            manager,
            container=self,
            object_id="#weather_value_label",
        )

        min_label_rect = pygame.Rect(percent_slider_rect.x, percent_slider_rect.bottom + 2, pct_value_width, 16)
        UILabel(
            min_label_rect,
            "0",
            manager,
            container=self,
            object_id="#weather_min_label",
        )
        max_label_rect = pygame.Rect(percent_slider_rect.right - pct_value_width, percent_slider_rect.bottom + 2, pct_value_width, 16)
        UILabel(
            max_label_rect,
            "100",
            manager,
            container=self,
            object_id="#weather_max_label",
        )

        buttons_y = max_label_rect.bottom + 6
        button_height = 26
        button_spacing = 6
        button_width = max(70, int((container_width - (2 * margin) - (3 * button_spacing)) / 4))
        self.prev_button = UIButton(
            relative_rect=pygame.Rect(margin, buttons_y, button_width, button_height),
            text="Prev",
            manager=manager,
            container=self,
            object_id="#weather_tab_button",
        )
        self.next_button = UIButton(
            relative_rect=pygame.Rect(margin + (button_width + button_spacing), buttons_y, button_width, button_height),
            text="Next",
            manager=manager,
            container=self,
            object_id="#weather_tab_button",
        )
        self.add_button = UIButton(
            relative_rect=pygame.Rect(margin + 2 * (button_width + button_spacing), buttons_y, button_width, button_height),
            text="Add",
            manager=manager,
            container=self,
            object_id="#weather_tab_button",
        )
        self.delete_button = UIButton(
            relative_rect=pygame.Rect(margin + 3 * (button_width + button_spacing), buttons_y, button_width, button_height),
            text="Delete",
            manager=manager,
            container=self,
            object_id="#weather_tab_button",
        )

        top_margin = buttons_y + button_height + 14
        slider_height = 18
        columns = 2 if container_width >= 340 and len(self._specs) > 6 else 1
        items_per_column = math.ceil(len(self._specs) / columns)
        column_width = max(170, int((container_width - (margin * (columns + 1))) / max(1, columns)))
        row_height = 58
        value_label_width = 58

        for index, spec in enumerate(self._specs):
            column_index = index // items_per_column
            row_index = index % items_per_column
            x = margin + column_index * (column_width + margin)
            y = top_margin + row_index * row_height

            label_rect = pygame.Rect(x, y, max(90, column_width - value_label_width - 8), 20)
            UILabel(
                label_rect,
                spec.display_name,
                manager,
                container=self,
                object_id="#weather_name_label",
            )

            value_label_rect = pygame.Rect(x + column_width - value_label_width, y, value_label_width, 18)
            value_label = UILabel(
                value_label_rect,
                "",
                manager,
                container=self,
                object_id="#weather_value_label",
            )

            slider_rect = pygame.Rect(x, y + 20, column_width, slider_height)
            slider = UIHorizontalSlider(
                relative_rect=slider_rect,
                start_value=spec.min_value,
                value_range=(spec.min_value, spec.max_value),
                manager=manager,
                container=self,
                object_id="#weather_slider",
                click_increment=spec.step,
            )

            min_label_rect = pygame.Rect(x, slider_rect.bottom + 2, value_label_width, 16)
            UILabel(
                min_label_rect,
                self._format_value(spec.min_value, spec.decimals),
                manager,
                container=self,
                object_id="#weather_min_label",
            )

            max_label_rect = pygame.Rect(x + column_width - value_label_width, slider_rect.bottom + 2, value_label_width, 16)
            UILabel(
                max_label_rect,
                self._format_value(spec.max_value, spec.decimals),
                manager,
                container=self,
                object_id="#weather_max_label",
            )

            self.sliders[spec.name] = slider
            self.value_labels[spec.name] = value_label
            self._slider_to_param[slider] = spec.name

        self.update_keyframe_metadata(
            count=self._keyframe_count,
            index=self._active_index,
            percentage=self._active_percentage,
            percent_editable=self._percent_editable,
            can_delete=self._can_delete,
        )

    def _format_value(self, value: float, decimals: int) -> str:
        if decimals <= 0:
            return f"{int(round(value))}"
        return f"{value:.{decimals}f}"

    def _update_value_label(self, name: str, value: float) -> None:
        spec = self._spec_lookup.get(name)
        label = self.value_labels.get(name)
        if not spec or not label:
            return
        label.set_text(self._format_value(value, spec.decimals))

    def apply_weather(self, weather: "carla.WeatherParameters") -> None:
        """Update sliders to match the provided weather object."""
        self._suppress_callback = True
        try:
            for spec in self._specs:
                slider = self.sliders.get(spec.name)
                if not slider:
                    continue
                raw_value = getattr(weather, spec.name, spec.min_value)
                clamped = max(spec.min_value, min(spec.max_value, float(raw_value)))
                slider.set_current_value(clamped)
                self._update_value_label(spec.name, slider.get_current_value())
        finally:
            self._suppress_callback = False

    def update_keyframe_metadata(
        self,
        *,
        count: int,
        index: int,
        percentage: float,
        percent_editable: bool = True,
        can_delete: bool = False,
        can_add: bool = True,
    ) -> None:
        """Refresh keyframe controls (label, slider, buttons)."""
        self._keyframe_count = max(1, int(count))
        self._active_index = max(0, min(int(index), self._keyframe_count - 1))
        self._active_percentage = max(0.0, min(100.0, float(percentage)))
        self._percent_editable = bool(percent_editable)
        self._can_delete = bool(can_delete)

        label_text = f"Keyframe {self._active_index + 1}/{self._keyframe_count} @ {self._active_percentage:.1f}%"
        if self.keyframe_label:
            self.keyframe_label.set_text(label_text)

        if self.percent_slider:
            self._suppress_callback = True
            try:
                self.percent_slider.set_current_value(self._active_percentage)
            finally:
                self._suppress_callback = False
        if self.percent_value_label:
            self.percent_value_label.set_text(self._format_value(self._active_percentage, 1))

        # Enable/disable controls based on selection
        if self.percent_slider:
            if self._percent_editable:
                self.percent_slider.enable()
            else:
                self.percent_slider.disable()
        if self.delete_button:
            if self._can_delete:
                self.delete_button.enable()
            else:
                self.delete_button.disable()
        if self.add_button:
            if can_add:
                self.add_button.enable()
            else:
                self.add_button.disable()
        if self.prev_button:
            if self._active_index <= 0:
                self.prev_button.disable()
            else:
                self.prev_button.enable()
        if self.next_button:
            if self._active_index >= (self._keyframe_count - 1):
                self.next_button.disable()
            else:
                self.next_button.enable()

    def process_event(self, event: pygame.event.Event) -> bool:
        handled = super().process_event(event)

        if event.type == UI_WINDOW_CLOSE and getattr(event, "ui_element", None) == self:
            if self._on_close:
                self._on_close()
            return True

        if event.type == UI_HORIZONTAL_SLIDER_MOVED and getattr(event, "ui_element", None) == self.percent_slider:
            slider = event.ui_element
            value = float(getattr(event, "value", slider.get_current_value()))
            if self.percent_value_label:
                self.percent_value_label.set_text(self._format_value(value, 1))
            if not self._suppress_callback and self._on_percentage_change:
                self._on_percentage_change(value)
            return True

        if event.type == UI_HORIZONTAL_SLIDER_MOVED and event.ui_element in self._slider_to_param:
            slider = event.ui_element
            param = self._slider_to_param.get(slider)
            if param:
                value = float(getattr(event, "value", slider.get_current_value()))
                self._update_value_label(param, value)
                if not self._suppress_callback:
                    self._active_drag_param = param
                    self._drag_last_value = value
                    if self._on_change_live:
                        self._on_change_live(param, value)
                return True

        if event.type == pygame.USEREVENT:
            user_type = getattr(event, "user_type", None)
            if user_type == UI_HORIZONTAL_SLIDER_MOVED and event.ui_element in self._slider_to_param:
                slider = event.ui_element
                param = self._slider_to_param.get(slider)
                if param:
                    value = float(getattr(event, "value", slider.get_current_value()))
                    self._update_value_label(param, value)
                    if not self._suppress_callback:
                        self._active_drag_param = param
                        self._drag_last_value = value
                        if self._on_change_live:
                            self._on_change_live(param, value)
                    return True
            if user_type == UI_HORIZONTAL_SLIDER_MOVED and getattr(event, "ui_element", None) == self.percent_slider:
                slider = event.ui_element
                value = float(getattr(event, "value", slider.get_current_value()))
                if self.percent_value_label:
                    self.percent_value_label.set_text(self._format_value(value, 1))
                if not self._suppress_callback and self._on_percentage_change:
                    self._on_percentage_change(value)
                return True
            if user_type == UI_BUTTON_PRESSED:
                ui_element = getattr(event, "ui_element", None)
                if ui_element == self.prev_button and self._on_prev_keyframe:
                    self._on_prev_keyframe()
                    return True
                if ui_element == self.next_button and self._on_next_keyframe:
                    self._on_next_keyframe()
                    return True
                if ui_element == self.add_button and self._on_add_keyframe:
                    self._on_add_keyframe()
                    return True
                if ui_element == self.delete_button and self._on_delete_keyframe:
                    self._on_delete_keyframe()
                    return True

        return handled

    def update(self, time_delta: float) -> None:
        """Ensure slider drags commit once the mouse is released."""
        super().update(time_delta)
        if self._suppress_callback:
            return
        if not self._active_drag_param or self._drag_last_value is None:
            return
        try:
            left_pressed = bool(pygame.mouse.get_pressed(num_buttons=3)[0])
        except TypeError:
            # Older pygame versions may not accept num_buttons kwarg
            left_pressed = bool(pygame.mouse.get_pressed()[0])
        if left_pressed:
            return
        self._commit_drag_if_needed()

    def _commit_drag_if_needed(self) -> bool:
        """Commit the last dragged slider value once."""
        if self._suppress_callback:
            return False
        if not self._active_drag_param or self._drag_last_value is None:
            return False
        if self._on_change_commit:
            self._on_change_commit(self._active_drag_param, float(self._drag_last_value))
        self._active_drag_param = None
        self._drag_last_value = None
        return True

    @classmethod
    def _ensure_theme(cls, manager: UIManager) -> None:
        """Load compact font/slider theme overrides once."""
        if cls._theme_initialized:
            return
        theme = {
            "#weather_name_label": {
                "font": {"size": "18"},
                "misc": {"text_horiz_alignment": "left"}
            },
            "#weather_value_label": {
                "font": {"size": "16"},
                "misc": {"text_horiz_alignment": "right"}
            },
            "#weather_min_label": {
                "font": {"size": "14"},
                "misc": {"text_horiz_alignment": "left"}
            },
            "#weather_max_label": {
                "font": {"size": "14"},
                "misc": {"text_horiz_alignment": "right"}
            },
            "#weather_slider": {
                "misc": {
                    "sliding_button_width": "14"
                }
            }
        }
        try:
            manager.get_theme().load_theme(theme)
        except Exception as exc:
            print(f"[Weather] Warning: failed to apply weather theme overrides: {exc}")
        cls._theme_initialized = True


class EnhancedFileDialog(UIFileDialog):
    """UIFileDialog with an additional 'new folder' button."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        try:
            locale.setlocale(locale.LC_NUMERIC, "C")
        except Exception:
            pass

        # Position the button directly to the right of the existing refresh button.
        refresh_rect = self.refresh_button.relative_rect
        button_rect = pygame.Rect(
            refresh_rect.right + 4,
            refresh_rect.y,
            refresh_rect.width,
            refresh_rect.height,
        )
        self.new_folder_button = UIButton(
            relative_rect=button_rect,
            text="+",
            tool_tip_text="Create folder",
            manager=self.ui_manager,
            container=self,
            object_id="#new_folder_button",
            anchors={
                "left": "left",
                "right": "left",
                "top": "top",
            "bottom": "top",
        },
    )


class ResultWindow(UIWindow):
    """Modal window that displays scenario run results with copy/save/close controls."""

    def __init__(
        self,
        rect: pygame.Rect,
        manager: UIManager,
        text: str,
        on_copy: Callable[[], None],
        on_save: Callable[[], None],
        on_close: Callable[[], None],
        title: str = "Scenario Results",
    ):
        super().__init__(
            rect,
            manager,
            window_display_title=title,
            resizable=True,
            always_on_top=True,
        )
        self.set_blocking(True)

        self._on_copy = on_copy
        self._on_save = on_save
        self._on_close = on_close

        margin = 10
        container_width, container_height = self.get_container().get_size()

        button_height = 32
        button_spacing = 10
        button_width = 80
        button_y = container_height - button_height - margin

        text_height = max(60, button_y - margin)
        text_rect = pygame.Rect(
            margin,
            margin,
            container_width - (2 * margin),
            text_height - margin,
        )

        html_text = self._as_html(text)
        self.text_box = UITextBox(
            html_text,
            relative_rect=text_rect,
            manager=manager,
            container=self,
            object_id="#result_text_box",
        )

        buttons_total_width = (3 * button_width) + (2 * button_spacing)
        buttons_start_x = max(
            margin,
            (container_width - buttons_total_width) // 2,
        )

        self.copy_button = UIButton(
            relative_rect=pygame.Rect(buttons_start_x, button_y, button_width, button_height),
            text="Copy",
            manager=manager,
            container=self,
            object_id="#result_copy_button",
            anchors={"left": "left", "right": "left", "top": "top", "bottom": "top"},
        )
        self.save_button = UIButton(
            relative_rect=pygame.Rect(
                buttons_start_x + button_width + button_spacing,
                button_y,
                button_width,
                button_height,
            ),
            text="Save",
            manager=manager,
            container=self,
            object_id="#result_save_button",
            anchors={"left": "left", "right": "left", "top": "top", "bottom": "top"},
        )
        self.close_button = UIButton(
            relative_rect=pygame.Rect(
                buttons_start_x + (2 * (button_width + button_spacing)),
                button_y,
                button_width,
                button_height,
            ),
            text="Close",
            manager=manager,
            container=self,
            object_id="#result_close_button",
            anchors={"left": "left", "right": "left", "top": "top", "bottom": "top"},
        )

    @staticmethod
    def _as_html(text: str) -> str:
        """Render plain text with preserved whitespace in a monospace block."""
        safe = html.escape(text)
        safe = safe.replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;")
        safe = safe.replace(" ", "&nbsp;")
        safe = safe.replace("\n", "<br>")
        return f'<font face="monospace">{safe}</font>'

    def process_event(self, event: pygame.event.Event) -> bool:
        handled = super().process_event(event)
        if event.type == UI_BUTTON_PRESSED:
            if event.ui_element == self.copy_button:
                if self._on_copy:
                    self._on_copy()
                return True
            if event.ui_element == self.save_button:
                if self._on_save:
                    self._on_save()
                return True
            if event.ui_element == self.close_button:
                if self._on_close:
                    self._on_close()
                self.kill()
                return True

        if event.type == UI_WINDOW_CLOSE and event.ui_element == self:
            if self._on_close:
                self._on_close()
            self.kill()
            return True

        return handled

@dataclass
class InfoPanelFieldSpec:
    name: str
    label: str
    kind: str  # 'text' or 'checkbox'
    value: Union[str, bool]
    editable: bool = True
    choices: Optional[List[str]] = None
    metadata: Optional[Dict[str, object]] = None


class InfoPanel:
    """
    UI panel for displaying and editing properties of waypoints, vehicles, and traffic lights.
    Supports property editing, scenario runner integration, and state restoration.
    """
    
    def __init__(self, camera_processor=None):
        self.camera_processor = camera_processor
        self.visible = False
        self.panel_width = 280
        self.panel_height = 400
        self.margin = 10
        self.font = pygame.font.Font(None, 20)
        self.small_font = pygame.font.Font(None, 16)
        self.background_color = (40, 40, 40, 230)
        self.text_color = (255, 255, 255)
        self.field_color = (60, 60, 60)
        self.active_field_color = (80, 80, 120)
        self.button_color = (70, 70, 70)
        self.button_hover_color = (90, 90, 90)
        
        # Current selection
        self.selected_object = None
        self.object_type = None  # 'waypoint', 'vehicle', 'pedestrian', or 'traffic_light'
        self.waypoint_vehicle_id = None  # For waypoint references
        self.waypoint_index = None
        
        # Editable fields
        self.fields = {}
        self.field_specs: List[InfoPanelFieldSpec] = []
        self.active_field = None
        self.field_positions = {}
        self.checkbox_fields = set()  # Track which fields are checkboxes
        self.readonly_fields = set()
        self.field_kinds: Dict[str, str] = {}
        self.field_metadata: Dict[str, Dict[str, object]] = {}
        self.dropdown_fields: Dict[str, List[str]] = {}
        self.dropdown_open_field: Optional[str] = None
        self.dropdown_option_rects: List[Tuple[str, str, pygame.Rect]] = []
        self.extra_click_zones: List[Dict[str, object]] = []
        self._traffic_light_sequence_meta: Dict[int, Dict[str, str]] = {}
        self.field_spec_map: Dict[str, InfoPanelFieldSpec] = {}
        self._select_all_on_edit = False

        # Input handling
        self.text_input = ""
        self.editing = False

        # Buttons
        self.buttons = {}
        self.button_positions = {}

        # Scenario execution state is now in WorldHandler
        # (Play button has been moved to top-right corner)
        self.scenario_starting_point = None  # Legacy single marker reference
        self.scenario_starting_points = {}  # Mapping of vehicle_id -> marker data
    
    def show(self, obj, obj_type, screen_width, screen_height, vehicle_id=None, wp_index=None):
        """Show the info panel for a selected object"""
        # Stop any active editing when switching to a new object
        self._stop_editing()
        
        self.visible = True
        self.selected_object = obj
        self.object_type = obj_type
        self.waypoint_vehicle_id = vehicle_id
        self.waypoint_index = wp_index
        
        # Initialize fields based on object type
        self._initialize_fields()
        
        # Initialize buttons based on object type
        self._initialize_buttons()

        # Position panel relative to current window dimensions
        self._update_layout(screen_width, screen_height, recalc_height=True)
    
    def hide(self):
        """Hide the info panel"""
        self.visible = False
        self.selected_object = None
        self.object_type = None
        self.waypoint_vehicle_id = None
        self.waypoint_index = None
        self.active_field = None
        self.editing = False
        self.field_specs = []
        self.fields.clear()
        self.field_positions.clear()
        self.checkbox_fields.clear()
        self.readonly_fields.clear()
        self.buttons.clear()
        self.button_positions.clear()
        self._select_all_on_edit = False
        self.field_kinds.clear()
        self.field_metadata.clear()
        self.dropdown_fields.clear()
        self.dropdown_open_field = None
        self.dropdown_option_rects = []
        self.extra_click_zones = []
        self._traffic_light_sequence_meta = {}
    
    def _calculate_panel_height(self):
        """Calculate panel height based on content"""
        base_height = 100 + self._get_waypoint_tip_block_height()  # Title, padding, and tip (if shown)
        if not self.field_specs:
            self.panel_height = base_height
            return

        total_height = 0
        for spec in self.field_specs:
            if spec.kind == 'checkbox':
                total_height += 48
            else:
                total_height += 42

        button_block = 0
        if self.buttons:
            button_block = 10 + len(self.buttons) * 35

        dropdown_extra = 0
        if self.dropdown_open_field and self.dropdown_open_field in self.dropdown_fields:
            options = self.dropdown_fields[self.dropdown_open_field]
            dropdown_extra += max(0, len(options)) * 24 + (10 if options else 0)

        self.panel_height = base_height + total_height + button_block + dropdown_extra

    def _should_show_waypoint_split_tip(self) -> bool:
        """Return True if the waypoint split tip should be visible."""
        return self.object_type == 'waypoint'

    def _get_waypoint_tip_block_height(self) -> int:
        """Return the vertical space used by the waypoint tip block."""
        if not self._should_show_waypoint_split_tip():
            return 0
        line_height = self.small_font.get_linesize()
        return line_height + 10

    def _render_waypoint_split_tip(self, surface: pygame.Surface, y_offset: int) -> int:
        """Render the waypoint split hint and return consumed height."""
        if not self._should_show_waypoint_split_tip():
            return 0

        tip_text = "Tip: Ctrl+Left click to split this waypoint"
        tip_surface = self.small_font.render(tip_text, True, (200, 200, 200))
        surface.blit(tip_surface, (self.margin, y_offset))
        return tip_surface.get_height() + 10
    
    def _initialize_fields(self):
        """Initialize editable fields based on object type."""
        specs = self._build_field_specs()
        self._apply_field_specs(specs)
        self.field_positions.clear()

    def _build_field_specs(self) -> List[InfoPanelFieldSpec]:
        specs: List[InfoPanelFieldSpec] = []
        if not self.selected_object:
            return specs

        if self.object_type == 'waypoint':
            waypoint = self.selected_object
            waypoint_index = waypoint.get(
                'index',
                self.waypoint_index if self.waypoint_index is not None else 0,
            )

            if waypoint_index == "destination":
                waypoint_name = "Waypoint (Destination)"
            else:
                try:
                    waypoint_name = f"Waypoint {int(waypoint_index) + 1}"
                except (ValueError, TypeError):
                    waypoint_name = f"Waypoint {waypoint_index}"

            speed_value = waypoint.get('speed_km_h', 50)
            if (
                waypoint.get('is_destination')
                and self.camera_processor
                and self.waypoint_vehicle_id is not None
            ):
                cached_speed = self.camera_processor.get_vehicle_destination_speed(
                    self.waypoint_vehicle_id
                )
                if cached_speed is not None:
                    speed_value = cached_speed

            specs.append(
                InfoPanelFieldSpec('name', 'Name:', 'text', waypoint_name, editable=False)
            )
            specs.append(
                InfoPanelFieldSpec('x', 'X:', 'text', f"{waypoint['x']:.2f}")
            )
            specs.append(
                InfoPanelFieldSpec('y', 'Y:', 'text', f"{waypoint['y']:.2f}")
            )
            specs.append(
                InfoPanelFieldSpec('z', 'Z:', 'text', f"{waypoint['z']:.2f}")
            )
            specs.append(
                InfoPanelFieldSpec(
                    'speed_km_h', 'Speed (km/h):', 'text', f"{speed_value:.0f}"
                )
            )
            deviation_value = waypoint.get('speed_deviation_km_h', 0)
            try:
                deviation_value = int(float(deviation_value or 0))
            except Exception:
                deviation_value = 0
            if deviation_value < 0:
                deviation_value = 0
            specs.append(
                InfoPanelFieldSpec(
                    'speed_deviation_km_h',
                    'Speed Deviation (km/h):',
                    'text',
                    str(deviation_value),
                )
            )
            specs.append(
                InfoPanelFieldSpec(
                    'idle_time_s', 'Idle Time (sim s):', 'text', f"{waypoint.get('idle_time_s', 0.0):.1f}"
                )
            )
            if self._is_pedestrian_waypoint():
                specs.append(
                    InfoPanelFieldSpec(
                        'turn_time_s',
                        'Turn Time (sim s):',
                        'text',
                        f"{waypoint.get('turn_time_s', 0.0):.1f}",
                    )
                )

            snap_status = "Snapped" if waypoint.get('snapped', False) else "Normal"
            specs.append(
                InfoPanelFieldSpec(
                    'snap_status', 'Snap Status:', 'text', snap_status, editable=False
                )
            )

        elif self.object_type in ('vehicle', 'pedestrian'):
            actor = self.selected_object
            if not actor or not actor.is_alive:
                return specs

            location = actor.get_location()
            rotation = actor.get_transform().rotation
            actor_type = actor.type_id.split('.')[-1] if hasattr(actor, 'type_id') else "Unknown"
            label_prefix = "Pedestrian" if self.object_type == 'pedestrian' else "Vehicle"

            if self.camera_processor:
                default_actor_speed = 5 if actor.type_id.startswith('walker.') else 50
                actor_speed = self.camera_processor.get_vehicle_speed(actor.id, default_actor_speed)
                idle_time = self.camera_processor.get_actor_idle_time(actor.id, 0.0)
            else:
                actor_speed = 5 if actor.type_id.startswith('walker.') else 50
                idle_time = 0.0

            specs.append(
                InfoPanelFieldSpec(
                    'name',
                    'Name:',
                    'text',
                    f"{label_prefix} ({actor_type})",
                    editable=False,
                )
            )
            specs.append(InfoPanelFieldSpec('x', 'X:', 'text', f"{location.x:.2f}"))
            specs.append(InfoPanelFieldSpec('y', 'Y:', 'text', f"{location.y:.2f}"))
            specs.append(InfoPanelFieldSpec('z', 'Z:', 'text', f"{location.z:.2f}"))
            specs.append(InfoPanelFieldSpec('yaw', 'Yaw:', 'text', f"{rotation.yaw:.2f}"))
            specs.append(
                InfoPanelFieldSpec(
                    'speed_km_h', 'Speed (km/h):', 'text', f"{actor_speed:.0f}"
                )
            )
            specs.append(
                InfoPanelFieldSpec('idle_time_s', 'Idle Time (sim s):', 'text', f"{idle_time:.1f}")
            )

            if self.object_type == 'pedestrian':
                turn_time = (
                    self.camera_processor.get_actor_turn_time(actor.id, 0.0)
                    if self.camera_processor
                    else 0.0
                )
                specs.append(
                    InfoPanelFieldSpec(
                        'turn_time_s', 'Turn Time (sim s):', 'text', f"{turn_time:.1f}"
                    )
                )

                # Add trigger radius for pedestrians
                if self.camera_processor and actor.id in self.camera_processor.pedestrian_trigger_radii:
                    trigger_radius = self.camera_processor.pedestrian_trigger_radii[actor.id]
                    specs.append(
                        InfoPanelFieldSpec(
                            'trigger_radius',
                            'Trigger Radius (m):',
                            'text',
                            f"{float(trigger_radius):.2f}",
                            metadata={'type': 'pedestrian_trigger_radius'},
                        )
                    )

            if self.object_type == 'vehicle' and self.camera_processor:
                max_lat_acc_value = self.camera_processor.get_vehicle_max_lat_acc(actor.id, 3.0)
                specs.append(
                    InfoPanelFieldSpec(
                        'max_lat_acc',
                        'Maximum Lateral Acceleration (m/s^2):',
                        'text',
                        f"{float(max_lat_acc_value):.2f}",
                        metadata={'type': 'vehicle_max_lat_acc'},
                    )
                )
                if (actor.id in self.camera_processor.vehicle_trigger_radii and
                        not self.camera_processor.is_ego_vehicle(actor.id)):
                    trigger_radius = self.camera_processor.vehicle_trigger_radii[actor.id]
                    specs.append(
                        InfoPanelFieldSpec(
                            'trigger_radius',
                            'Trigger Radius (m):',
                            'text',
                            f"{float(trigger_radius):.2f}",
                            metadata={'type': 'vehicle_trigger_radius'},
                        )
                    )
                flags = self.camera_processor.get_vehicle_ignore_flags(actor.id)
                specs.append(
                    InfoPanelFieldSpec(
                        'ignore_traffic_lights',
                        'Ignore Traffic Lights:',
                        'checkbox',
                        flags['traffic_lights'],
                    )
                )
                specs.append(
                    InfoPanelFieldSpec(
                        'ignore_stop_signs',
                        'Ignore Stop Signs:',
                        'checkbox',
                        flags['stop_signs'],
                    )
                )
                specs.append(
                    InfoPanelFieldSpec(
                        'ignore_vehicles',
                        'Ignore Vehicles:',
                        'checkbox',
                        flags['vehicles'],
                    )
                )

        elif self.object_type == 'traffic_light':
            group = self.selected_object  # TrafficLightGroupData
            if not group or not group.lights:
                return specs

            if group.sequence is None:
                group.sequence = []

            has_trigger = group.has_trigger()

            specs.append(
                InfoPanelFieldSpec(
                    'group_size',
                    'Lights in Group:',
                    'text',
                    f"{len(group.lights)}",
                    editable=False,
                )
            )
            specs.append(
                InfoPanelFieldSpec(
                    'light_ids',
                    'Light IDs:',
                    'text',
                    f"{', '.join(str(lid) for lid in sorted(group.ids))}",
                    editable=False,
                )
            )

            # Add trigger radius field if trigger exists
            if has_trigger and group.trigger_radius is not None:
                specs.append(
                    InfoPanelFieldSpec(
                        'trigger_radius',
                        'Trigger Radius (m):',
                        'text',
                        f"{float(group.trigger_radius):.2f}",
                        metadata={'type': 'traffic_light_trigger_radius'},
                    )
                )

            self._traffic_light_sequence_meta = {}
            if has_trigger:
                if group.sequence:
                    specs.append(
                        InfoPanelFieldSpec(
                            'sequence_header',
                            'Sequence Steps:',
                            'text',
                            'Configured order of light states',
                            editable=False,
                            metadata={'type': 'traffic_light_sequence_header'},
                        )
                    )
                else:
                    specs.append(
                        InfoPanelFieldSpec(
                            'sequence_empty',
                            'Sequence Steps:',
                            'text',
                            'No sequence defined. Use "Add Step" to begin.',
                            editable=False,
                            metadata={'type': 'traffic_light_sequence_header'},
                        )
                    )

                for idx, entry in enumerate(group.sequence):
                    color_field = f"seq_color_{idx}"
                    duration_field = f"seq_duration_{idx}"
                    self._traffic_light_sequence_meta[idx] = {
                        'color_field': color_field,
                        'duration_field': duration_field,
                    }

                    specs.append(
                        InfoPanelFieldSpec(
                            color_field,
                            f"Step {idx + 1} Color:",
                            'dropdown',
                            str(entry.get('color', 'Red')),
                            choices=['Red', 'Yellow', 'Green', 'Off'],
                            metadata={'type': 'traffic_light_sequence_color', 'index': idx, 'paired_field': duration_field},
                        )
                    )
                    specs.append(
                        InfoPanelFieldSpec(
                            duration_field,
                            f"Step {idx + 1} Duration (sim s):",
                            'text',
                            f"{float(entry.get('duration_s', 1.0)):.2f}",
                            metadata={'type': 'traffic_light_sequence_duration', 'index': idx, 'paired_color': color_field},
                        )
                    )

        return specs

    def _apply_field_specs(self, specs: List[InfoPanelFieldSpec]):
        self.field_specs = specs
        self.fields = {}
        self.checkbox_fields = set()
        self.readonly_fields = set()
        self.field_positions.clear()
        previous_dropdown = self.dropdown_open_field
        self.field_kinds = {}
        self.field_metadata = {}
        self.dropdown_fields = {}
        self.dropdown_option_rects = []
        self.extra_click_zones = []
        self._traffic_light_sequence_meta = {}

        for spec in specs:
            self.fields[spec.name] = spec.value
            self.field_kinds[spec.name] = spec.kind
            if spec.metadata:
                self.field_metadata[spec.name] = spec.metadata
            if spec.kind == 'checkbox':
                self.checkbox_fields.add(spec.name)
            elif not spec.editable:
                self.readonly_fields.add(spec.name)
            if spec.kind == 'dropdown' and spec.choices:
                self.dropdown_fields[spec.name] = list(spec.choices)

        self.field_spec_map = {spec.name: spec for spec in specs}

        if previous_dropdown not in self.dropdown_fields:
            self.dropdown_open_field = None
        else:
            self.dropdown_open_field = previous_dropdown

        self._calculate_panel_height()

    def _initialize_buttons(self):
        """Initialize buttons based on object type"""
        self.buttons.clear()
        self.button_positions.clear()

        if self.object_type == 'traffic_light':
            group = cast(Optional[TrafficLightGroupData], self.selected_object)
            if group and group.has_trigger():
                self.buttons['add_traffic_light_step'] = '+ Add Step'
                if getattr(group, 'sequence', None):
                    self.buttons['clear_traffic_light_steps'] = 'Clear Steps'

    def _update_layout(self, screen_width, screen_height, recalc_height=False):
        """Keep the panel anchored to the window edge during resizes."""
        if not self.visible:
            return

        if recalc_height:
            self._calculate_panel_height()

        # Anchor to the right, but keep a margin so it never floats off-screen
        self.panel_x = max(self.margin, screen_width - self.panel_width - self.margin)

        top_offset = 90
        panel_top = top_offset + self.margin
        if self.camera_processor and getattr(self.camera_processor, 'editor', None):
            editor = self.camera_processor.editor
            top_offset = getattr(editor, 'top_ui_height', top_offset)
            panel_top = getattr(editor, 'side_panel_top', top_offset + self.margin)

        max_panel_y = max(self.margin, screen_height - self.panel_height - self.margin)
        self.panel_y = max(self.margin, min(panel_top, max_panel_y))

    def _is_pedestrian_waypoint(self):
        """Determine if the currently selected waypoint belongs to a pedestrian actor."""
        if not self.camera_processor or self.waypoint_vehicle_id is None:
            return False
        if hasattr(self.camera_processor, '_is_pedestrian_actor'):
            return self.camera_processor._is_pedestrian_actor(self.waypoint_vehicle_id)
        return False
    
    def _refresh_fields(self):
        """Refresh field values in real-time during movement/rotation"""
        if not self.visible or not self.selected_object or self.editing:
            return

        specs = self._build_field_specs()
        self._apply_field_specs(specs)
    
    def handle_click(self, mouse_pos):
        """Handle mouse clicks on the info panel"""
        if not self.visible:
            return False
        
        # Check if click is within panel bounds
        if not self._is_point_in_panel(mouse_pos):
            self.dropdown_open_field = None
            return False
        
        # Check custom click zones (e.g., delete buttons)
        for zone in list(self.extra_click_zones):
            rect = zone.get('rect')
            if rect and rect.collidepoint(mouse_pos):
                zone_type = zone.get('type')
                if zone_type == 'traffic_light_delete_step':
                    idx = int(zone.get('index', -1))
                    self._delete_traffic_light_sequence_step(idx)
                    return True

        # Check dropdown option selections before buttons to prioritize list choices
        for field_name, option_value, rect in list(self.dropdown_option_rects):
            if rect.collidepoint(mouse_pos):
                self.dropdown_open_field = None
                self.fields[field_name] = option_value
                metadata = self.field_metadata.get(field_name)
                if metadata and metadata.get('type') == 'traffic_light_sequence_color':
                    idx = int(metadata.get('index', -1))
                    self._update_traffic_light_sequence_color(idx, option_value)
                    self._initialize_fields()
                    self._initialize_buttons()
                return True

        # Check button clicks first
        for button_name, rect in self.button_positions.items():
            if rect.collidepoint(mouse_pos):
                self._handle_button_click(button_name)
                return True
        
        # Check field clicks
        for field_name, rect in self.field_positions.items():
            if rect.collidepoint(mouse_pos):
                field_kind = self.field_kinds.get(field_name)
                if field_name in self.checkbox_fields:
                    # Toggle checkbox
                    self.fields[field_name] = not self.fields[field_name]
                    for spec in self.field_specs:
                        if spec.name == field_name:
                            spec.value = self.fields[field_name]
                            break
                    # Update the storage dictionary
                    if self.camera_processor and self.selected_object:
                        vehicle_id = self.selected_object.id
                        flags = self.camera_processor.get_vehicle_ignore_flags(vehicle_id)
                        if field_name == 'ignore_traffic_lights':
                            flags['traffic_lights'] = self.fields[field_name]
                        elif field_name == 'ignore_stop_signs':
                            flags['stop_signs'] = self.fields[field_name]
                        elif field_name == 'ignore_vehicles':
                            flags['vehicles'] = self.fields[field_name]
                        self.camera_processor.set_vehicle_ignore_flags(vehicle_id, flags)
                    return True
                elif field_kind == 'dropdown':
                    if self.dropdown_open_field == field_name:
                        self.dropdown_open_field = None
                    else:
                        self.dropdown_open_field = field_name
                    return True
                elif field_name not in self.readonly_fields:
                    self._start_editing_field(field_name)
                    return True

        # Click elsewhere in panel - stop editing
        self._stop_editing()
        self.dropdown_open_field = None
        return True
    
    def handle_key_input(self, event):
        """Handle keyboard input for editing fields"""
        if not self.editing or not self.active_field:
            return False
        
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                self._apply_field_change()
                return True
            elif event.key == pygame.K_ESCAPE:
                self._cancel_editing()
                return True
            elif event.key == pygame.K_BACKSPACE:
                if self._select_all_on_edit:
                    self.text_input = ""
                    self._select_all_on_edit = False
                else:
                    self.text_input = self.text_input[:-1]
                return True
            else:
                # Add character to input
                char = event.unicode
                if char.isprintable():
                    # Filter input based on field type
                    if self.active_field in ['x', 'y', 'z']:
                        # Allow numbers, decimal point, minus sign
                        if char.isdigit() or char in '.-':
                            self._append_char(char)
                    elif self.active_field == 'speed_km_h':
                        # Allow only positive numbers
                        if char.isdigit() or char == '.':
                            self._append_char(char)
                    elif self.active_field == 'speed_deviation_km_h':
                        # Allow only non-negative integers
                        if char.isdigit():
                            self._append_char(char)
                    elif self.active_field == 'idle_time_s':
                        if char.isdigit() or char == '.':
                            self._append_char(char)
                    elif self.active_field == 'turn_time_s':
                        if char.isdigit() or char == '.':
                            self._append_char(char)
                    elif self.active_field == 'max_lat_acc':
                        if char.isdigit() or char == '.':
                            self._append_char(char)
                    elif self.active_field == 'trigger_radius':
                        # Allow only positive numbers for trigger radius
                        if char.isdigit() or char == '.':
                            self._append_char(char)
                    else:
                        metadata = self.field_metadata.get(self.active_field)
                        if metadata and metadata.get('type') == 'traffic_light_sequence_duration':
                            if char.isdigit() or char == '.':
                                self._append_char(char)
                    return True

        return False

    def _append_char(self, char: str) -> None:
        if self._select_all_on_edit:
            self.text_input = char
            self._select_all_on_edit = False
        else:
            self.text_input += char
    
    def _start_editing_field(self, field_name):
        """Start editing a field"""
        self.active_field = field_name
        self.editing = True
        self.text_input = self.fields[field_name]
        self._select_all_on_edit = True
    
    def _stop_editing(self):
        """Stop editing without applying changes"""
        self.active_field = None
        self.editing = False
        self.text_input = ""
        self._select_all_on_edit = False
    
    def _cancel_editing(self):
        """Cancel editing and restore original value"""
        self._stop_editing()
    
    def _handle_button_click(self, button_name):
        """Handle button clicks"""
        if self.object_type == 'traffic_light':
            if button_name == 'add_traffic_light_step':
                self._add_traffic_light_sequence_step()
                return
            if button_name == 'clear_traffic_light_steps':
                self._clear_traffic_light_sequence()
                return

    def _apply_field_change(self):
        """Apply the field change"""
        if not self.active_field or not self.text_input:
            self._stop_editing()
            return
        
        try:
            # Validate and convert input
            if self.active_field in ['x', 'y', 'z']:
                new_value = float(self.text_input)
                self._update_coordinate(self.active_field, new_value)
            elif self.active_field == 'speed_km_h':
                new_value = max(0, float(self.text_input))  # Ensure positive
                self._update_speed(new_value)
            elif self.active_field == 'speed_deviation_km_h':
                new_value = max(0, int(float(self.text_input)))  # Ensure non-negative
                self._update_speed_deviation(new_value)
                self.text_input = str(new_value)
            elif self.active_field == 'idle_time_s':
                new_value = max(0.0, float(self.text_input))
                self._update_idle_time(new_value)
            elif self.active_field == 'turn_time_s':
                new_value = max(0.0, float(self.text_input))
                self._update_turn_time(new_value)
            elif self.active_field == 'trigger_radius' and self.object_type == 'traffic_light':
                # Clamp trigger radius to reasonable values (2m - 100m) for traffic lights
                new_value = max(MIN_PERSONAL_TRIGGER_RADIUS, min(100.0, float(self.text_input)))
                self._update_traffic_light_trigger_radius(new_value)
                self.text_input = f"{new_value:.2f}"
            else:
                metadata = self.field_metadata.get(self.active_field)
                if metadata and metadata.get('type') == 'traffic_light_sequence_duration':
                    idx = int(metadata.get('index', -1))
                    new_value = max(0.0, float(self.text_input))
                    self._update_traffic_light_sequence_duration(idx, new_value)
                    self.text_input = f"{new_value:.2f}"
                elif metadata and metadata.get('type') == 'traffic_light_trigger_radius':
                    # Clamp trigger radius to reasonable values (2m - 100m)
                    new_value = max(MIN_PERSONAL_TRIGGER_RADIUS, min(100.0, float(self.text_input)))
                    self._update_traffic_light_trigger_radius(new_value)
                    self.text_input = f"{new_value:.2f}"
                elif metadata and metadata.get('type') == 'pedestrian_trigger_radius':
                    # Clamp trigger radius to minimum 2m (no maximum)
                    new_value = max(MIN_PERSONAL_TRIGGER_RADIUS, float(self.text_input))
                    self._update_pedestrian_trigger_radius(new_value)
                    self.text_input = f"{new_value:.2f}"
                elif metadata and metadata.get('type') == 'vehicle_trigger_radius':
                    new_value = max(MIN_PERSONAL_TRIGGER_RADIUS, float(self.text_input))
                    self._update_vehicle_trigger_radius(new_value)
                    self.text_input = f"{new_value:.2f}"
                elif metadata and metadata.get('type') == 'vehicle_max_lat_acc':
                    new_value = max(0.1, float(self.text_input))
                    self._update_vehicle_max_lat_acc(new_value)
                    self.text_input = f"{new_value:.2f}"
                else:
                    raise ValueError("Unsupported editable field")

            # Update field display
            self.fields[self.active_field] = self.text_input
            
        except ValueError:
            # Invalid input - ignore
            pass
        
        self._stop_editing()
    
    def _update_coordinate(self, coord_type, new_value):
        """Update waypoint or vehicle coordinates"""
        if self.object_type == 'waypoint':
            waypoint = self.selected_object
            old_value = waypoint[coord_type]
            old_snapped = waypoint.get('snapped', False)
            new_snapped = False  # Manual coordinate editing always unsnaps
            
            # Only create command if value actually changed
            if abs(old_value - new_value) > 0.001:  # Avoid floating point precision issues
                command = UpdateWaypointPropertyCommand(
                    self.camera_processor, 
                    self.waypoint_vehicle_id, 
                    self.waypoint_index, 
                    coord_type, 
                    old_value, 
                    new_value,
                    old_snapped,  # Track snapped state change
                    new_snapped   # Unsnap when manually editing coordinates
                )
                
                # Execute command through editor if available
                if self.camera_processor.editor:
                    self.camera_processor.editor.execute_command(command)
                else:
                    # Fallback to direct execution
                    command.execute()
                
                # Update the field display
                self.fields[coord_type] = f"{new_value:.2f}"
                print(f"Updated waypoint {coord_type}: {old_value:.2f} -> {new_value:.2f} (unsnapped)")
            
        elif self.object_type in ('vehicle', 'pedestrian'):
            vehicle = self.selected_object
            if vehicle and vehicle.is_alive:
                current_transform = vehicle.get_transform()
                current_loc = current_transform.location
                current_rot = current_transform.rotation
                
                # Get old value for comparison
                if coord_type == 'x':
                    old_value = current_loc.x
                elif coord_type == 'y':
                    old_value = current_loc.y
                elif coord_type == 'z':
                    old_value = current_loc.z
                elif coord_type == 'yaw':
                    old_value = current_rot.yaw
                else:
                    return  # Unknown coordinate type
                
                # Only create command if value actually changed
                if abs(old_value - new_value) > 0.001:  # Avoid floating point precision issues
                    # Create new transform with updated coordinate
                    if coord_type == 'x':
                        new_loc = carla.Location(new_value, current_loc.y, current_loc.z)
                        new_transform = carla.Transform(new_loc, current_rot)
                    elif coord_type == 'y':
                        new_loc = carla.Location(current_loc.x, new_value, current_loc.z)
                        new_transform = carla.Transform(new_loc, current_rot)
                    elif coord_type == 'z':
                        new_loc = carla.Location(current_loc.x, current_loc.y, new_value)
                        new_transform = carla.Transform(new_loc, current_rot)
                    elif coord_type == 'yaw':
                        new_rot = carla.Rotation(current_rot.pitch, new_value, current_rot.roll)
                        new_transform = carla.Transform(current_loc, new_rot)
                    
                    command = UpdateVehiclePropertyCommand(
                        self.camera_processor,
                        vehicle.id,
                        coord_type,
                        old_value,
                        new_value,
                        current_transform,
                        new_transform
                    )
                    
                    # Execute command through editor if available
                    if self.camera_processor.editor:
                        self.camera_processor.editor.execute_command(command)
                    else:
                        # Fallback to direct execution
                        command.execute()
                    
                    if coord_type == 'yaw':
                        print(f"Rotated vehicle yaw: {current_rot.yaw:.2f} -> {new_value:.2f}")
                    else:
                        print(f"Moved vehicle {coord_type}: {getattr(current_loc, coord_type):.2f} -> {new_value:.2f}")
    
    def _update_speed(self, new_speed):
        """Update speed for waypoint or vehicle"""
        if self.object_type == 'waypoint':
            waypoint = self.selected_object
            old_speed = waypoint.get('speed_km_h', 50)  # Default speed if not set
            
            # Only create command if value actually changed
            if abs(old_speed - new_speed) > 0.1:  # Avoid small floating point differences
                command = UpdateWaypointPropertyCommand(
                    self.camera_processor,
                    self.waypoint_vehicle_id,
                    self.waypoint_index,
                    'speed_km_h',
                    old_speed,
                    new_speed
                )
                
                # Execute command through editor if available
                if self.camera_processor.editor:
                    self.camera_processor.editor.execute_command(command)
                else:
                    # Fallback to direct execution
                    command.execute()
                
                print(f"Updated waypoint speed: {old_speed:.0f} -> {new_speed:.0f} km/h")
                
        elif self.object_type in ('vehicle', 'pedestrian'):
            actor = self.selected_object
            if actor and actor.is_alive and self.camera_processor:
                old_speed = self.camera_processor.get_vehicle_speed(actor.id, 50)  # Default speed

                if abs(old_speed - new_speed) > 0.1:  # Avoid small floating point differences
                    command = UpdateVehiclePropertyCommand(
                        self.camera_processor,
                        actor.id,
                        'speed_km_h',
                        old_speed,
                        new_speed
                    )

                    if self.camera_processor.editor:
                        self.camera_processor.editor.execute_command(command)
                    else:
                        command.execute()

                    label = "pedestrian" if self.object_type == 'pedestrian' else 'vehicle'
                    print(f"Updated {label} speed: {old_speed:.0f} -> {new_speed:.0f} km/h")

    def _update_speed_deviation(self, new_deviation_km_h: int) -> None:
        """Update speed deviation (km/h) for a waypoint."""
        if self.object_type != 'waypoint':
            return

        waypoint = self.selected_object
        old_deviation = waypoint.get('speed_deviation_km_h', 0)
        try:
            old_deviation = int(float(old_deviation or 0))
        except Exception:
            old_deviation = 0
        if old_deviation < 0:
            old_deviation = 0

        new_deviation_km_h = max(0, int(new_deviation_km_h))
        if old_deviation == new_deviation_km_h:
            return

        command = UpdateWaypointPropertyCommand(
            self.camera_processor,
            self.waypoint_vehicle_id,
            self.waypoint_index,
            'speed_deviation_km_h',
            old_deviation,
            new_deviation_km_h,
        )

        if self.camera_processor and self.camera_processor.editor:
            self.camera_processor.editor.execute_command(command)
        else:
            command.execute()

        if 'speed_deviation_km_h' in self.fields:
            self.fields['speed_deviation_km_h'] = str(new_deviation_km_h)
        print(
            f"Updated waypoint speed deviation: {old_deviation} -> {new_deviation_km_h} km/h"
        )

    def _update_idle_time(self, new_idle_time):
        """Update idle time for vehicles, pedestrians, and waypoints."""
        if self.object_type == 'waypoint':
            waypoint = self.selected_object
            old_idle = waypoint.get('idle_time_s', 0.0)

            if abs(old_idle - new_idle_time) > 0.01:
                snapped_state = waypoint.get('snapped', False)
                command = UpdateWaypointPropertyCommand(
                    self.camera_processor,
                    self.waypoint_vehicle_id,
                    self.waypoint_index,
                    'idle_time_s',
                    old_idle,
                    new_idle_time,
                    snapped_state,
                    snapped_state
                )

                if self.camera_processor and self.camera_processor.editor:
                    self.camera_processor.editor.execute_command(command)
                else:
                    command.execute()

                self.fields['idle_time_s'] = f"{new_idle_time:.1f}"
                print(f"Updated waypoint idle time: {old_idle:.1f}s -> {new_idle_time:.1f}s")

        elif self.object_type in ('vehicle', 'pedestrian'):
            actor = self.selected_object
            if not actor or not actor.is_alive:
                return

            old_idle = 0.0
            if self.camera_processor and hasattr(self.camera_processor, 'actor_idle_times'):
                old_idle = self.camera_processor.actor_idle_times.get(actor.id, 0.0)

            if abs(old_idle - new_idle_time) > 0.01:
                command = UpdateVehiclePropertyCommand(
                    self.camera_processor,
                    actor.id,
                    'idle_time_s',
                    old_idle,
                    new_idle_time
                )

                if self.camera_processor and self.camera_processor.editor:
                    self.camera_processor.editor.execute_command(command)
                else:
                    command.execute()

                self.fields['idle_time_s'] = f"{new_idle_time:.1f}"
                actor_label = 'vehicle' if self.object_type == 'vehicle' else 'pedestrian'
                print(f"Updated {actor_label} idle time: {old_idle:.1f}s -> {new_idle_time:.1f}s")

    def _update_turn_time(self, new_turn_time):
        """Update turn time for pedestrian actors or waypoints."""
        if self.object_type == 'waypoint':
            waypoint = self.selected_object
            old_turn = waypoint.get('turn_time_s', 0.0)

            if abs(old_turn - new_turn_time) > 0.01:
                snapped_state = waypoint.get('snapped', False)
                command = UpdateWaypointPropertyCommand(
                    self.camera_processor,
                    self.waypoint_vehicle_id,
                    self.waypoint_index,
                    'turn_time_s',
                    old_turn,
                    new_turn_time,
                    snapped_state,
                    snapped_state
                )

                if self.camera_processor and self.camera_processor.editor:
                    self.camera_processor.editor.execute_command(command)
                else:
                    command.execute()

                self.fields['turn_time_s'] = f"{new_turn_time:.1f}"
                print(f"Updated waypoint turn time: {old_turn:.1f}s -> {new_turn_time:.1f}s")

        elif self.object_type == 'pedestrian':
            actor = self.selected_object
            if not actor or not actor.is_alive:
                return

            old_turn = 1.0
            if self.camera_processor and hasattr(self.camera_processor, 'actor_turn_times'):
                old_turn = self.camera_processor.actor_turn_times.get(actor.id, 0.0)

            if abs(old_turn - new_turn_time) > 0.01:
                command = UpdateVehiclePropertyCommand(
                    self.camera_processor,
                    actor.id,
                    'turn_time_s',
                    old_turn,
                    new_turn_time
                )

                if self.camera_processor and self.camera_processor.editor:
                    self.camera_processor.editor.execute_command(command)
                else:
                    command.execute()

                self.fields['turn_time_s'] = f"{new_turn_time:.1f}"
                print(f"Updated pedestrian turn time: {old_turn:.1f}s -> {new_turn_time:.1f}s")

    def _traffic_light_default_duration(self) -> float:
        return 5.0

    def _traffic_light_seconds_to_ticks(self, seconds: float) -> int:
        if seconds <= 0.0:
            return 0
        delta = 0.05
        try:
            if self.camera_processor and self.camera_processor.world:
                settings = self.camera_processor.world.get_settings()
                if settings.fixed_delta_seconds and settings.fixed_delta_seconds > 0:
                    delta = settings.fixed_delta_seconds
        except Exception:
            pass
        return max(1, int(round(seconds / delta)))

    def _ensure_traffic_light_sequence(self) -> Optional[TrafficLightGroupData]:
        if self.object_type != 'traffic_light':
            return None
        group = cast(Optional[TrafficLightGroupData], self.selected_object)
        if not group:
            return None
        if group.sequence is None:
            group.sequence = []
        return group

    def _add_traffic_light_sequence_step(self):
        group = self._ensure_traffic_light_sequence()
        if not group or not group.has_trigger():
            return
        duration_s = self._traffic_light_default_duration()
        old_seq = copy.deepcopy(group.sequence)
        new_seq = copy.deepcopy(group.sequence)
        new_seq.append({
            'color': 'Red',
            'duration_s': duration_s,
            'duration_ticks': self._traffic_light_seconds_to_ticks(duration_s),
        })
        command = UpdateTrafficLightSequenceCommand(
            self.camera_processor,
            group,
            old_seq,
            new_seq,
        )
        editor = getattr(self.camera_processor, "editor", None)
        success = editor.execute_command(command) if editor else command.execute()
        if success is False:
            print("Failed to add traffic light sequence step.")
            return
        self._initialize_fields()
        self._initialize_buttons()

    def _clear_traffic_light_sequence(self):
        group = self._ensure_traffic_light_sequence()
        if not group or not group.has_trigger() or not group.sequence:
            return
        old_seq = copy.deepcopy(group.sequence)
        new_seq = []
        command = UpdateTrafficLightSequenceCommand(
            self.camera_processor,
            group,
            old_seq,
            new_seq,
        )
        editor = getattr(self.camera_processor, "editor", None)
        success = editor.execute_command(command) if editor else command.execute()
        if success is False:
            print("Failed to clear traffic light sequence.")
            return
        self._initialize_fields()
        self._initialize_buttons()

    def _delete_traffic_light_sequence_step(self, index: int):
        group = self._ensure_traffic_light_sequence()
        if not group or not group.has_trigger() or not group.sequence:
            return
        if 0 <= index < len(group.sequence):
            old_seq = copy.deepcopy(group.sequence)
            new_seq = copy.deepcopy(group.sequence)
            del new_seq[index]
            command = UpdateTrafficLightSequenceCommand(
                self.camera_processor,
                group,
                old_seq,
                new_seq,
            )
            editor = getattr(self.camera_processor, "editor", None)
            success = editor.execute_command(command) if editor else command.execute()
            if success is False:
                print("Failed to delete traffic light sequence step.")
                return
            self._initialize_fields()
            self._initialize_buttons()

    def _update_traffic_light_sequence_color(self, index: int, color: str):
        group = self._ensure_traffic_light_sequence()
        if not group or not group.has_trigger() or not group.sequence:
            return
        if 0 <= index < len(group.sequence):
            old_seq = copy.deepcopy(group.sequence)
            new_seq = copy.deepcopy(group.sequence)
            new_seq[index]['color'] = color
            command = UpdateTrafficLightSequenceCommand(
                self.camera_processor,
                group,
                old_seq,
                new_seq,
            )
            editor = getattr(self.camera_processor, "editor", None)
            success = editor.execute_command(command) if editor else command.execute()
            if success is False:
                print("Failed to update traffic light sequence color.")
                return
            self.fields[f"seq_color_{index}"] = color
            if self.camera_processor:
                self.camera_processor._cache_traffic_light_sequence(group)

    def _update_traffic_light_sequence_duration(self, index: int, duration_s: float):
        group = self._ensure_traffic_light_sequence()
        if not group or not group.has_trigger() or not group.sequence:
            return
        duration_s = max(0.0, duration_s)
        if 0 <= index < len(group.sequence):
            old_seq = copy.deepcopy(group.sequence)
            new_seq = copy.deepcopy(group.sequence)
            new_seq[index]['duration_s'] = duration_s
            new_seq[index]['duration_ticks'] = self._traffic_light_seconds_to_ticks(duration_s)
            command = UpdateTrafficLightSequenceCommand(
                self.camera_processor,
                group,
                old_seq,
                new_seq,
            )
            editor = getattr(self.camera_processor, "editor", None)
            success = editor.execute_command(command) if editor else command.execute()
            if success is False:
                print("Failed to update traffic light sequence duration.")
                return
            self.fields[f"seq_duration_{index}"] = f"{duration_s:.2f}"
            if self.camera_processor:
                self.camera_processor._cache_traffic_light_sequence(group)

    def _update_traffic_light_trigger_radius(self, new_radius: float):
        """Update the trigger radius for the selected traffic light group."""
        if self.object_type != 'traffic_light' or not self.camera_processor:
            return

        # Get the current selected group from camera processor (source of truth)
        group = self.camera_processor.selected_traffic_light_group
        if not group or not group.has_trigger():
            return

        new_radius = max(MIN_PERSONAL_TRIGGER_RADIUS, min(100.0, new_radius))
        center_snapshot = group.trigger_center or {}
        cached_center, _, resolved_key = self.camera_processor._get_traffic_light_trigger_data(group=group)
        if not center_snapshot and cached_center:
            center_snapshot = dict(cached_center)
        key = self.camera_processor._traffic_light_trigger_key(group=group) or resolved_key
        old_radius = group.trigger_radius
        selection = {
            'kind': 'traffic_light',
            'group': group,
            'key': key,
        }
        command = SetPersonalTriggerCommand(
            self.camera_processor,
            selection,
            dict(center_snapshot) if center_snapshot else None,
            new_radius,
            old_center=copy.deepcopy(center_snapshot) if center_snapshot else None,
            old_radius=old_radius,
        )
        editor = getattr(self.camera_processor, "editor", None)
        if editor:
            success = editor.execute_command(command)
        else:
            success = command.execute()
        if success is False:
            print("Failed to update traffic light trigger radius.")
            return

        # Refresh from the authoritative data after command execution
        group_ids = group.ids
        applied_radius = group.trigger_radius if group.trigger_radius is not None else new_radius
        self.fields['trigger_radius'] = f"{applied_radius:.2f}"
        print(f"Updated traffic light trigger radius: {applied_radius:.2f} m for IDs {sorted(group_ids)}")
        current = self.camera_processor.selected_personal_trigger
        if current and current.get('kind') == 'traffic_light':
            self.camera_processor.update_personal_trigger_menu_position(force=True)

    def _update_pedestrian_trigger_radius(self, new_radius: float):
        """Update the trigger radius for the selected pedestrian."""
        if self.object_type != 'pedestrian' or not self.camera_processor:
            return

        # Get the selected pedestrian actor
        actor = self.selected_object
        if not actor or not actor.is_alive:
            return

        pedestrian_id = actor.id
        if not self.camera_processor._ensure_pedestrian_trigger(pedestrian_id):
            return

        # Clamp to minimum radius (no maximum)
        new_radius = max(MIN_PERSONAL_TRIGGER_RADIUS, new_radius)

        center_snapshot = self.camera_processor.pedestrian_trigger_centers.get(pedestrian_id)
        old_radius = self.camera_processor.pedestrian_trigger_radii.get(pedestrian_id)
        selection = {'kind': 'pedestrian', 'id': pedestrian_id}
        command = SetPersonalTriggerCommand(
            self.camera_processor,
            selection,
            dict(center_snapshot) if center_snapshot else None,
            new_radius,
            old_center=copy.deepcopy(center_snapshot) if center_snapshot else None,
            old_radius=old_radius,
        )
        editor = getattr(self.camera_processor, "editor", None)
        if editor:
            success = editor.execute_command(command)
        else:
            success = command.execute()
        if success is False:
            print("Failed to update pedestrian trigger radius.")
            return
        # Fetch the stored radius in case clamping changed it during execution.
        applied_radius = self.camera_processor.pedestrian_trigger_radii.get(pedestrian_id, new_radius)

        # Update the field display
        self.fields['trigger_radius'] = f"{applied_radius:.2f}"

        # Print confirmation
        print(f"Updated pedestrian trigger radius: {applied_radius:.2f} m for ID {pedestrian_id}")
        current = self.camera_processor.selected_personal_trigger
        if current and current.get('kind') == 'pedestrian' and current.get('id') == pedestrian_id:
            self.camera_processor.update_personal_trigger_menu_position(force=True)

    def _update_vehicle_max_lat_acc(self, new_value: float):
        """Update the lateral acceleration cap for the selected vehicle."""
        if self.object_type != 'vehicle' or not self.camera_processor:
            return

        actor = self.selected_object
        if not actor or not actor.is_alive:
            return

        vehicle_id = actor.id
        old_value = self.camera_processor.get_vehicle_max_lat_acc(vehicle_id, 3.0)
        if abs(old_value - new_value) < 1e-3:
            self.fields['max_lat_acc'] = f"{new_value:.2f}"
            return

        command = UpdateVehiclePropertyCommand(
            self.camera_processor,
            vehicle_id,
            'max_lat_acc',
            old_value,
            new_value,
        )

        if self.camera_processor and self.camera_processor.editor:
            self.camera_processor.editor.execute_command(command)
        else:
            command.execute()

        self.fields['max_lat_acc'] = f"{new_value:.2f}"
        print(f"Updated vehicle max lateral acceleration: {old_value:.2f} -> {new_value:.2f} m/s^2")

    def _update_vehicle_trigger_radius(self, new_radius: float):
        """Update the trigger radius for the selected vehicle."""
        if self.object_type != 'vehicle' or not self.camera_processor:
            return

        actor = self.selected_object
        if not actor or not actor.is_alive:
            return

        vehicle_id = actor.id
        if vehicle_id not in self.camera_processor.vehicle_trigger_radii:
            return

        if not self.camera_processor._ensure_vehicle_trigger(vehicle_id):
            return
        new_radius = max(MIN_PERSONAL_TRIGGER_RADIUS, new_radius)
        center_snapshot = self.camera_processor.vehicle_trigger_centers.get(vehicle_id)
        old_radius = self.camera_processor.vehicle_trigger_radii.get(vehicle_id)
        selection = {'kind': 'vehicle', 'id': vehicle_id}
        command = SetPersonalTriggerCommand(
            self.camera_processor,
            selection,
            dict(center_snapshot) if center_snapshot else None,
            new_radius,
            old_center=copy.deepcopy(center_snapshot) if center_snapshot else None,
            old_radius=old_radius,
        )
        editor = getattr(self.camera_processor, "editor", None)
        if editor:
            success = editor.execute_command(command)
        else:
            success = command.execute()
        if success is False:
            print("Failed to update vehicle trigger radius.")
            return

        applied_radius = self.camera_processor.vehicle_trigger_radii.get(vehicle_id, new_radius)
        self.fields['trigger_radius'] = f"{applied_radius:.2f}"
        print(f"Updated vehicle trigger radius: {applied_radius:.2f} m for ID {vehicle_id}")
        current = self.camera_processor.selected_personal_trigger
        if current and current.get('kind') == 'vehicle' and current.get('id') == vehicle_id:
            self.camera_processor.update_personal_trigger_menu_position(force=True)

    def _is_point_in_panel(self, point):
        """Check if a point is within the panel bounds"""
        return (self.panel_x <= point[0] <= self.panel_x + self.panel_width and
                self.panel_y <= point[1] <= self.panel_y + self.panel_height)
    
    def render(self, screen, tooltip_manager=None):
        """Render the info panel"""
        if not self.visible:
            return

        self._update_layout(screen.get_width(), screen.get_height(), recalc_height=True)
        
        # Create surface with alpha for transparency
        panel_surface = pygame.Surface((self.panel_width, self.panel_height), pygame.SRCALPHA)
        panel_surface.fill(self.background_color)

        y_offset = 20

        # Title
        if self.object_type == 'waypoint':
            title = f"Waypoint Info"
        elif self.object_type == 'vehicle':
            title = f"Vehicle Info"
        elif self.object_type == 'pedestrian':
            title = f"Pedestrian Info"
        elif self.object_type == 'traffic_light':
            title = "Traffic Lights Info"
        else:
            title = "Object Info"

        title_text = self.font.render(title, True, self.text_color)
        panel_surface.blit(title_text, (self.margin, y_offset))
        y_offset += 40

        # Reset per-render collections
        self.field_positions.clear()
        self.dropdown_option_rects = []
        self.extra_click_zones = []

        # Waypoint-specific tip block
        tip_height = self._render_waypoint_split_tip(panel_surface, y_offset)
        if tip_height:
            y_offset += tip_height

        # Render fields
        processed_fields: Set[str] = set()

        for spec in self.field_specs:
            field_name = spec.name
            if field_name in processed_fields:
                continue

            field_value = self.fields.get(field_name, "")
            metadata = self.field_metadata.get(field_name)
            field_kind = self.field_kinds.get(field_name, spec.kind)

            if field_kind == 'checkbox':
                label_text = self.small_font.render(spec.label, True, self.text_color)
                panel_surface.blit(label_text, (self.margin, y_offset))

                checkbox_size = 20
                checkbox_rect = pygame.Rect(self.margin, y_offset + 20, checkbox_size, checkbox_size)
                absolute_rect = pygame.Rect(
                    self.panel_x + checkbox_rect.x,
                    self.panel_y + checkbox_rect.y,
                    checkbox_rect.width,
                    checkbox_rect.height,
                )
                self.field_positions[field_name] = absolute_rect

                pygame.draw.rect(panel_surface, self.field_color, checkbox_rect)
                pygame.draw.rect(panel_surface, self.text_color, checkbox_rect, 1)

                if field_value:
                    pygame.draw.line(
                        panel_surface,
                        self.text_color,
                        (checkbox_rect.left + 3, checkbox_rect.top + 3),
                        (checkbox_rect.right - 3, checkbox_rect.bottom - 3),
                        2,
                    )
                    pygame.draw.line(
                        panel_surface,
                        self.text_color,
                        (checkbox_rect.right - 3, checkbox_rect.top + 3),
                        (checkbox_rect.left + 3, checkbox_rect.bottom - 3),
                        2,
                    )

                y_offset += 48
                continue

            if field_kind == 'dropdown' and metadata and metadata.get('type') == 'traffic_light_sequence_color':
                paired_field = metadata.get('paired_field')
                processed_fields.add(field_name)
                paired_spec = self.field_spec_map.get(paired_field) if paired_field else None
                paired_value = self.fields.get(paired_field, "") if paired_field else ""

                delete_button_width = 28
                column_gap = 12
                available_width = self.panel_width - 2 * self.margin - delete_button_width - column_gap
                column_width = max(60, available_width // 2)

                color_label_text = spec.label.replace(' Color:', '').strip()
                color_label_surface = self.small_font.render(color_label_text, True, self.text_color)
                panel_surface.blit(color_label_surface, (self.margin, y_offset))

                duration_label_text = 'Duration (sim s)'
                if paired_spec:
                    raw_label = paired_spec.label
                    if 'Duration' in raw_label:
                        duration_label_text = raw_label.split('Duration', 1)[-1].strip(': ')
                        if not duration_label_text:
                            duration_label_text = 'Duration (sim s)'
                    elif raw_label:
                        duration_label_text = raw_label
                duration_label_surface = self.small_font.render(duration_label_text, True, self.text_color)
                duration_label_x = self.margin + column_width + column_gap
                panel_surface.blit(duration_label_surface, (duration_label_x, y_offset))

                color_rect = pygame.Rect(self.margin, y_offset + 18, column_width, 24)
                color_abs = pygame.Rect(
                    self.panel_x + color_rect.x,
                    self.panel_y + color_rect.y,
                    color_rect.width,
                    color_rect.height,
                )
                self.field_positions[field_name] = color_abs

                is_open = self.dropdown_open_field == field_name
                pygame.draw.rect(panel_surface, self.field_color, color_rect)
                pygame.draw.rect(panel_surface, self.text_color, color_rect, 1)

                display_text = str(field_value)
                text_surface = self.small_font.render(display_text, True, self.text_color)
                text_rect = text_surface.get_rect()
                text_rect.left = color_rect.left + 6
                text_rect.centery = color_rect.centery
                panel_surface.blit(text_surface, text_rect)

                if is_open:
                    arrow_points = [
                        (color_rect.right - 16, color_rect.centery + 4),
                        (color_rect.right - 8, color_rect.centery + 4),
                        (color_rect.right - 12, color_rect.centery - 4),
                    ]
                else:
                    arrow_points = [
                        (color_rect.right - 16, color_rect.centery - 4),
                        (color_rect.right - 8, color_rect.centery - 4),
                        (color_rect.right - 12, color_rect.centery + 4),
                    ]
                pygame.draw.polygon(panel_surface, self.text_color, arrow_points)

                option_block_height = 0
                options = self.dropdown_fields.get(field_name, [])
                if is_open and options:
                    option_height = 24
                    option_block_height = len(options) * option_height
                    option_rect = pygame.Rect(color_rect.left, color_rect.bottom, color_rect.width, option_block_height)
                    pygame.draw.rect(panel_surface, self.field_color, option_rect)
                    pygame.draw.rect(panel_surface, self.text_color, option_rect, 1)

                    for idx_opt, choice in enumerate(options):
                        opt_y = option_rect.top + idx_opt * option_height
                        choice_rect = pygame.Rect(option_rect.left + 2, opt_y + 2, option_rect.width - 4, option_height - 4)
                        choice_abs = pygame.Rect(
                            self.panel_x + choice_rect.x,
                            self.panel_y + choice_rect.y,
                            choice_rect.width,
                            choice_rect.height,
                        )
                        pygame.draw.rect(panel_surface, self.field_color, choice_rect)
                        if choice == field_value:
                            pygame.draw.rect(panel_surface, self.button_hover_color, choice_rect)
                        pygame.draw.rect(panel_surface, self.text_color, choice_rect, 1)
                        choice_text = self.small_font.render(choice, True, self.text_color)
                        panel_surface.blit(choice_text, (choice_rect.x + 4, choice_rect.y + 3))
                        self.dropdown_option_rects.append((field_name, choice, choice_abs))

                duration_rect = pygame.Rect(duration_label_x, y_offset + 18, column_width, 24)
                duration_abs = pygame.Rect(
                    self.panel_x + duration_rect.x,
                    self.panel_y + duration_rect.y,
                    duration_rect.width,
                    duration_rect.height,
                )
                if paired_field:
                    self.field_positions[paired_field] = duration_abs

                active_duration = paired_field and self.active_field == paired_field and self.editing
                duration_bg = self.active_field_color if active_duration else self.field_color
                pygame.draw.rect(panel_surface, duration_bg, duration_rect)
                pygame.draw.rect(panel_surface, self.text_color, duration_rect, 1)

                duration_display = str(paired_value)
                if active_duration:
                    duration_display = self.text_input if self._select_all_on_edit else self.text_input + "|"
                duration_text = self.small_font.render(duration_display, True, self.text_color)
                duration_text_rect = duration_text.get_rect()
                duration_text_rect.left = duration_rect.left + 5
                duration_text_rect.centery = duration_rect.centery
                panel_surface.blit(duration_text, duration_text_rect)

                delete_rect = pygame.Rect(
                    duration_rect.right + 6,
                    y_offset + 18,
                    delete_button_width - 6,
                    24,
                )
                delete_rect.x = min(delete_rect.x, self.panel_width - self.margin - delete_rect.width)
                delete_abs = pygame.Rect(
                    self.panel_x + delete_rect.x,
                    self.panel_y + delete_rect.y,
                    delete_rect.width,
                    delete_rect.height,
                )
                pygame.draw.rect(panel_surface, (120, 50, 50), delete_rect)
                pygame.draw.rect(panel_surface, self.text_color, delete_rect, 1)
                pygame.draw.line(
                    panel_surface,
                    self.text_color,
                    (delete_rect.left + 5, delete_rect.top + 5),
                    (delete_rect.right - 5, delete_rect.bottom - 5),
                    2,
                )
                pygame.draw.line(
                    panel_surface,
                    self.text_color,
                    (delete_rect.right - 5, delete_rect.top + 5),
                    (delete_rect.left + 5, delete_rect.bottom - 5),
                    2,
                )
                self.extra_click_zones.append(
                    {
                        'type': 'traffic_light_delete_step',
                        'index': metadata.get('index', -1),
                        'rect': delete_abs,
                    }
                )

                if paired_field:
                    processed_fields.add(paired_field)
                y_offset += 42 + option_block_height
                continue

            # Fallback for other dropdowns (if any)
            if field_kind == 'dropdown':
                label_text = self.small_font.render(spec.label, True, self.text_color)
                panel_surface.blit(label_text, (self.margin, y_offset))

                field_rect = pygame.Rect(self.margin, y_offset + 18, self.panel_width - 2 * self.margin, 24)
                absolute_rect = pygame.Rect(
                    self.panel_x + field_rect.x,
                    self.panel_y + field_rect.y,
                    field_rect.width,
                    field_rect.height,
                )
                self.field_positions[field_name] = absolute_rect

                is_open = self.dropdown_open_field == field_name
                pygame.draw.rect(panel_surface, self.field_color, field_rect)
                pygame.draw.rect(panel_surface, self.text_color, field_rect, 1)

                display_text = str(field_value)
                text_surface = self.small_font.render(display_text, True, self.text_color)
                text_rect = text_surface.get_rect()
                text_rect.left = field_rect.left + 6
                text_rect.centery = field_rect.centery
                panel_surface.blit(text_surface, text_rect)

                if is_open:
                    arrow_points = [
                        (field_rect.right - 16, field_rect.centery + 4),
                        (field_rect.right - 8, field_rect.centery + 4),
                        (field_rect.right - 12, field_rect.centery - 4),
                    ]
                else:
                    arrow_points = [
                        (field_rect.right - 16, field_rect.centery - 4),
                        (field_rect.right - 8, field_rect.centery - 4),
                        (field_rect.right - 12, field_rect.centery + 4),
                    ]
                pygame.draw.polygon(panel_surface, self.text_color, arrow_points)

                option_block_height = 0
                options = self.dropdown_fields.get(field_name, [])
                if is_open and options:
                    option_height = 24
                    option_block_height = len(options) * option_height
                    option_rect = pygame.Rect(field_rect.left, field_rect.bottom, field_rect.width, option_block_height)
                    pygame.draw.rect(panel_surface, self.field_color, option_rect)
                    pygame.draw.rect(panel_surface, self.text_color, option_rect, 1)

                    for idx_opt, choice in enumerate(options):
                        opt_y = option_rect.top + idx_opt * option_height
                        choice_rect = pygame.Rect(option_rect.left + 2, opt_y + 2, option_rect.width - 4, option_height - 4)
                        choice_abs = pygame.Rect(
                            self.panel_x + choice_rect.x,
                            self.panel_y + choice_rect.y,
                            choice_rect.width,
                            choice_rect.height,
                        )
                        pygame.draw.rect(panel_surface, self.field_color, choice_rect)
                        if choice == field_value:
                            pygame.draw.rect(panel_surface, self.button_hover_color, choice_rect)
                        pygame.draw.rect(panel_surface, self.text_color, choice_rect, 1)
                        choice_text = self.small_font.render(choice, True, self.text_color)
                        panel_surface.blit(choice_text, (choice_rect.x + 4, choice_rect.y + 3))
                        self.dropdown_option_rects.append((field_name, choice, choice_abs))

                y_offset += 42 + option_block_height
                continue

            label_text = self.small_font.render(spec.label, True, self.text_color)
            panel_surface.blit(label_text, (self.margin, y_offset))

            if metadata and metadata.get('type') == 'traffic_light_sequence_header':
                message = str(field_value)
                message_surface = self.small_font.render(message, True, (200, 200, 200))
                panel_surface.blit(message_surface, (self.margin, y_offset + 20))
                y_offset += 36
                continue

            field_rect = pygame.Rect(
                self.margin, y_offset + 18, self.panel_width - 2 * self.margin, 24
            )
            absolute_rect = pygame.Rect(
                self.panel_x + field_rect.x,
                self.panel_y + field_rect.y,
                field_rect.width,
                field_rect.height,
            )
            self.field_positions[field_name] = absolute_rect

            if self.active_field == field_name and self.editing:
                field_bg_color = self.active_field_color
                display_text = self.text_input if self._select_all_on_edit else self.text_input + "|"
            else:
                field_bg_color = self.field_color
                display_text = str(field_value)

            pygame.draw.rect(panel_surface, field_bg_color, field_rect)
            pygame.draw.rect(panel_surface, self.text_color, field_rect, 1)

            text_color = self.text_color if spec.editable else (200, 200, 200)
            field_text = self.small_font.render(display_text, True, text_color)
            text_rect = field_text.get_rect()
            text_rect.left = field_rect.left + 5
            text_rect.centery = field_rect.centery
            panel_surface.blit(field_text, text_rect)

            y_offset += 42
        
        # Render buttons
        if self.buttons:
            y_offset += 10  # Add some spacing before buttons
            for button_name, button_text in self.buttons.items():
                button_rect = pygame.Rect(self.margin, y_offset, self.panel_width - 2 * self.margin, 30)
                
                # Store button position for click detection
                absolute_rect = pygame.Rect(
                    self.panel_x + button_rect.x,
                    self.panel_y + button_rect.y,
                    button_rect.width,
                    button_rect.height
                )
                self.button_positions[button_name] = absolute_rect
                
                # Check if mouse is hovering over button
                mouse_pos = pygame.mouse.get_pos()
                is_hovering = absolute_rect.collidepoint(mouse_pos)
                
                # Button background color
                button_bg_color = self.button_hover_color if is_hovering else self.button_color
                
                # Draw button background
                pygame.draw.rect(panel_surface, button_bg_color, button_rect)
                pygame.draw.rect(panel_surface, self.text_color, button_rect, 1)
                
                # Draw button text
                button_text_surface = self.small_font.render(button_text, True, self.text_color)
                text_rect = button_text_surface.get_rect()
                text_rect.center = button_rect.center
                panel_surface.blit(button_text_surface, text_rect)

                # Register hover for tooltip
                if tooltip_manager and is_hovering:
                    tooltip_text = INFO_PANEL_BUTTON_TOOLTIPS.get(button_name, "")
                    if tooltip_text:
                        tooltip_manager.register_hover(
                            f"info_panel_button_{button_name}",
                            absolute_rect,
                            tooltip_text,
                        )

                y_offset += 35
        
        # Draw panel border
        pygame.draw.rect(panel_surface, self.text_color, panel_surface.get_rect(), 2)
        
        # Blit panel to screen
        screen.blit(panel_surface, (self.panel_x, self.panel_y))

############################################################
# Main Editor Class & Event Loop
############################################################
class VisualScenarioEditor:
    """
    Main application class for the Visual Scenario Editor.
    Orchestrates UI, CARLA interaction, event loop, undo/redo, and scenario management.
    """

    def _handle_quit_event(self):
        """Shared quit handler for window close shortcuts."""
        if self.show_exit_confirmation():
            if self.camera_processor:
                self.camera_processor.cleanup_all_vehicles()
            self.keep_server_running_on_exit = False
            self.server_manager.set_auto_stop_enabled(True)
            return False
        return True

    def _handle_keydown(self, event, scenario_running):
        """Process KEYDOWN events. Returns False to exit, True if handled, or None to fall through."""
        if self.info_panel.handle_key_input(event):
            return True

        manual_arrow_consumed = False
        if self.camera_processor:
            manual_arrow_consumed = self.camera_processor.handle_manual_control_key(event.key, True)

        keys = pygame.key.get_pressed()
        ctrl_pressed = is_ctrl_pressed(keys)
        shift_pressed = is_shift_pressed(keys)

        # Check if this key is part of a keyboard shortcut before adding to keys_pressed
        is_keyboard_shortcut = (
            ctrl_pressed and event.key in {pygame.K_s, pygame.K_l, pygame.K_z, pygame.K_y}
        )

        if not manual_arrow_consumed and not is_keyboard_shortcut:
            self.keys_pressed.add(event.key)
            if event.key not in self.key_hold_times:
                self.key_hold_times[event.key] = 0.0

        if event.key == pygame.K_F4 and (keys[pygame.K_LALT] or keys[pygame.K_RALT]):
            if not self._handle_quit_event():
                return False
            return True

        if event.key == pygame.K_ESCAPE:
            if self.map_menu_visible:
                self.map_menu_visible = False
                print("Map menu closed")
            elif self.scenario_menu_visible:
                self.scenario_menu_visible = False
                print("Scenario menu closed")
            elif self.camera_processor and self.camera_processor.creating_waypoint:
                self.camera_processor.stop_waypoint_creation()
                print("Waypoint creation cancelled")
            elif self.camera_processor and self.camera_processor.placing_trigger:
                self.camera_processor.stop_trigger_placement()
                self._reset_right_click_cancel_state()
                print("Trigger placement cancelled")
            elif self.camera_processor and self.camera_processor.pending_personal_trigger:
                self.camera_processor.cancel_personal_trigger_placement()
                self._reset_right_click_cancel_state()
                print("Personal trigger placement cancelled")
            elif self.camera_processor and self.camera_processor.moving_waypoint:
                self.camera_processor.moving_waypoint = False
                self.camera_processor.selected_waypoint_vehicle_id = None
                self.camera_processor.selected_waypoint_index = None
                print("Waypoint movement cancelled")
            elif self.camera_processor and self.camera_processor.selected_vehicle:
                self.camera_processor.clear_vehicle_selection()
                print("Vehicle selection cleared")
            else:
                print("ESC pressed - Use Alt+F4 or close button to exit")
            return True

        if event.key == pygame.K_o:
            if not self.ready:
                print("World is not ready yet. Please wait for map to finish loading.")
            elif self.scenario_running:
                return True  # Disable toggle during playback
            elif self.camera_processor:
                self.camera_processor.toggle_opendrive_overlay()
            return True

        if event.key == pygame.K_t:
            if not self.ready:
                print("World is not ready yet. Please wait for map to finish loading.")
            elif self.scenario_running:
                return True  # Disable toggle during playback
            elif self.camera_processor:
                self.camera_processor.traffic_lights_visible = not self.camera_processor.traffic_lights_visible
                status = "ENABLED" if self.camera_processor.traffic_lights_visible else "DISABLED"
                print(f"Traffic light stop lines overlay {status}")
                if not self.camera_processor.traffic_lights_visible:
                    self.camera_processor.clear_traffic_light_selection()
                    if (self.camera_processor.selected_personal_trigger
                            and self.camera_processor.selected_personal_trigger.get('kind') == 'traffic_light'):
                        self.camera_processor.clear_personal_trigger_selection()
                    self.camera_processor._last_visible_traffic_light_trigger_key = None
            return True

        if event.key == pygame.K_F3 and self.camera_processor:
            self.camera_processor.debug_raycast = not self.camera_processor.debug_raycast
            self.camera_processor.coordinate_detector.debug_raycast = self.camera_processor.debug_raycast
            status = "ENABLED" if self.camera_processor.debug_raycast else "DISABLED"
            print(f"\n[DEBUG MODE] Raycast coordinate debugging {status}")
            print(f"[DEBUG MODE] This will show detailed coordinate information when spawning vehicles")
            if self.camera_processor.debug_raycast:
                cached = self._safe_get_world_map(refresh=False)
                map_name = cached.name if cached else "unknown"
                print(f"[DEBUG MODE] Map: {map_name}\n")
            return True

        if event.key == pygame.K_s and ctrl_pressed:
            if self.camera_processor:
                if self.current_scenario_path and self.current_scenario_name:
                    try:
                        result = self.camera_processor.save_waypoint_data_to_file(self.current_scenario_path)
                        if result is False:
                            print(f"Save failed for scenario: {self.current_scenario_name}")
                        else:
                            live_sig = self._compute_scene_signature()
                            disk_sig = self._compute_disk_scene_signature()
                            self._mark_scene_saved(live_sig, disk_sig)
                            print(f"Saved to scenario: {self.current_scenario_name}")
                    except Exception as exc:
                        print(f"Save failed: {exc}")
                else:
                    print("No scenario loaded. Opening save dialog...")
                    self.save_scenario_with_dialog()
            return True

        if event.key == pygame.K_l and ctrl_pressed:
            print("Opening load scenario dialog...")
            self.load_scenario_with_dialog()
            return True

        if event.key == pygame.K_z and ctrl_pressed:
            if shift_pressed:
                self.redo_last_command()
            else:
                self.undo_last_command()
            return True

        if event.key == pygame.K_y and ctrl_pressed:
            self.redo_last_command()
            return True

        if event.key == pygame.K_DELETE and self.camera_processor:
            if (self.info_panel.visible and self.info_panel.selected_object and
                    self.info_panel.object_type in ('vehicle', 'pedestrian')):
                self.camera_processor.delete_selected_vehicle()
            elif self.camera_processor.selected_trigger_index is not None:
                self.camera_processor.delete_selected_trigger()
            else:
                success = self.camera_processor.delete_selected_waypoint()
                if not success and (self.camera_processor.selected_waypoint_vehicle_id is None):
                    print("No waypoint selected. Click on a waypoint first to select it for deletion.")
            return True

        return True

    def _handle_keyup(self, event):
        """Process KEYUP events."""
        if self.camera_processor:
            self.camera_processor.handle_manual_control_key(event.key, False)

        release_keys = {pygame.K_w, pygame.K_a, pygame.K_s, pygame.K_d}
        arrow_keys = {pygame.K_UP, pygame.K_DOWN, pygame.K_LEFT, pygame.K_RIGHT}
        manual_active = bool(
            self.camera_processor
            and (self.camera_processor.manual_control_enabled or self.camera_processor.manual_control_pending)
        )
        if event.key in release_keys or (event.key in arrow_keys and not manual_active):
            if event.key in self.keys_pressed:
                self.camera_moved_with_wasd = True

        self.keys_pressed.discard(event.key)
        self.key_hold_times.pop(event.key, None)

        if (self.camera_moved_with_wasd and not (self.keys_pressed &
            {pygame.K_w, pygame.K_a, pygame.K_s, pygame.K_d,
             pygame.K_UP, pygame.K_DOWN, pygame.K_LEFT, pygame.K_RIGHT})):
            if self.camera_controller and self.world:
                # Prototype: camera navigation performs no terrain raycasts.
                self.camera_moved_with_wasd = False
                if self.camera_processor:
                    self.camera_processor.restore_vehicle_menu_after_camera_pan()
            if self.camera_processor:
                self.camera_processor.end_manual_camera_free_look("keyboard_pan")

    def _handle_left_click(self, pos, scenario_running):
        """Process left-click (button 1) interactions."""
        if self.scenario_menu_visible and self.scenario_menu and self.scenario_menu.handle_click(pos):
            return True

        if self.map_menu_visible and self.map_menu and self.map_menu.handle_click(pos):
            return True

        if self.rendering_toggle_rect and self.rendering_toggle_rect.collidepoint(pos):
            current_rendering = self.rendering_enabled if self.ready and self.world else self._rendering_desired_enabled
            target_state = not current_rendering
            if self.ready and self.world:
                self._apply_rendering_mode(desired_enabled=target_state, reason="user toggle", force=True)
            else:
                self._rendering_desired_enabled = target_state
                self.rendering_enabled = target_state
                print("[Rendering] Preference updated; will apply once the CARLA world is ready.")
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if self.connection_button_rect and self.connection_button_rect.collidepoint(pos):
            self.connect_to_remote()
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if self.open_map_button_rect and self.open_map_button_rect.collidepoint(pos):
            self.show_open_map_dialog()
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if self.open_scenario_button_rect and self.open_scenario_button_rect.collidepoint(pos):
            self.show_open_scenario_dialog()
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        for rect, option in self.resolution_option_rects:
            if rect.collidepoint(pos):
                self._set_stream_resolution(option)
                self._close_all_dropdowns()
                return True

        if self.resolution_button_rect and self.resolution_button_rect.collidepoint(pos):
            was_open = self.resolution_menu_open
            self._close_all_dropdowns()
            self.resolution_menu_open = not was_open
            return True

        if self._using_remote_server():
            for rect, fps_value in self.fps_option_rects:
                if rect.collidepoint(pos):
                    self._set_stream_fps(fps_value)
                    self._close_all_dropdowns()
                    return True

            if self.fps_button_rect and self.fps_button_rect.collidepoint(pos):
                was_open = self.fps_menu_open
                self._close_all_dropdowns()
                self.fps_menu_open = not was_open
                return True

        if self.manual_tick_button_rect and self.manual_tick_button_rect.collidepoint(pos):
            self.manual_tick_enabled = not self.manual_tick_enabled
            state = "ENABLED" if self.manual_tick_enabled else "DISABLED"
            print(f"[Manual Tick] Drive Clock {state} by user request.")
            if self.manual_tick_enabled:
                if self.manual_tick_required:
                    self.manual_tick_accumulator = self.manual_tick_interval
                else:
                    self.manual_tick_accumulator = 0.0
                self.manual_tick_recommendation = False
                if not self.manual_tick_required:
                    print("[Manual Tick] Waiting for synchronous mode; Drive Clock will advance ticks once required.")
            else:
                self.manual_tick_accumulator = 0.0
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if self.weather_button_rect and self.weather_button_rect.collidepoint(pos):
            if self.weather_button_enabled:
                self.toggle_weather_window()
            else:
                print("Weather controls will be available once the CARLA world is ready.")
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if getattr(self, 'agent_button_rect', None) and self.agent_button_rect and self.agent_button_rect.collidepoint(pos):
            if getattr(self, "agent_button_enabled", False):
                if getattr(self, "agent_path", None):
                    self._clear_last_agent_cache(remove_file=True)
                    print("[Agent] Cleared playback agent.")
                else:
                    picked = self._prompt_agent_file_path()
                    if picked:
                        self._remember_last_agent(picked)
                        print(f"[Agent] Selected playback agent: {picked}")
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if hasattr(self, 'play_button_rect') and self.play_button_rect and self.play_button_rect.collidepoint(pos):
            if self.play_button_enabled:
                scenario_active = bool(
                    self.scenario_running or (self.scenario_process and self.scenario_process.poll() is None)
                )
                if scenario_active:
                    self.stop_scenario()
                else:
                    self.run_scenario()
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if self.info_panel.handle_click(pos):
            return True

        if not scenario_running and self.handle_mode_toggle_click(pos):
            return True

        active_menu = self.get_active_selection_menu() if not scenario_running else None
        if active_menu and active_menu.handle_click(pos):
            return True

        if (self.camera_processor and self.camera_processor.creating_waypoint and pos[1] > 80):
            print(f"Placing waypoint at click position: {pos}")
            self.camera_processor.place_waypoint_at_click(pos[0], pos[1])
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if (self.camera_processor and self.camera_processor.creating_destination and pos[1] > 80):
            print(f"Placing destination at click position: {pos}")
            self.camera_processor.place_destination_at_click(pos[0], pos[1])
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if (self.camera_processor and self.camera_processor.placing_trigger and pos[1] > 80):
            print(f"Placing trigger at click position: {pos}")
            self.camera_processor.place_trigger_at_click(pos[0], pos[1])
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True
        if (self.camera_processor and self.camera_processor.pending_personal_trigger and pos[1] > 80):
            placed = self.camera_processor.place_personal_trigger_at_click(pos[0], pos[1])
            if placed:
                self.resolution_menu_open = False
                self.fps_menu_open = False
            return True

        if scenario_running or pos[1] <= 80:
            if not (self.resolution_button_rect and self.resolution_button_rect.collidepoint(pos)):
                self.resolution_menu_open = False
                self.fps_menu_open = False
            return False

        if (self.camera_processor and self.camera_processor.selected_vehicle and
                self.camera_processor.vehicle_menu_position and
                not self.camera_processor.creating_waypoint):
            menu_action = self.camera_processor.check_menu_icon_click(pos[0], pos[1])
            if menu_action:
                if menu_action == 'rotate' and not self.camera_processor.selected_vehicle_is_pedestrian:
                    self.camera_processor.start_vehicle_rotation(pos[1])
                elif menu_action == 'delete':
                    self.camera_processor.delete_selected_vehicle()
                elif menu_action == 'move':
                    keys = pygame.key.get_pressed()
                    snap_to_lane = not is_shift_pressed(keys)
                    if self.camera_processor.selected_vehicle_is_pedestrian:
                        snap_to_lane = False
                    self.camera_processor.start_vehicle_movement(pos, snap_to_lane=snap_to_lane)
                elif menu_action == 'ego_destination':
                    if (self.camera_processor.selected_vehicle and
                            self.camera_processor.is_ego_vehicle(self.camera_processor.selected_vehicle.id)):
                        # Always start fresh when choosing ego destination placement
                        self.camera_processor.start_waypoint_creation(reset_existing=True)
                elif menu_action == 'waypoint':
                    if (self.camera_processor.selected_vehicle and
                            self.camera_processor.is_ego_vehicle(self.camera_processor.selected_vehicle.id)):
                        print("Ego vehicle does not support waypoint creation.")
                    else:
                        self.camera_processor.start_waypoint_creation()
                elif menu_action == 'autoroute':
                    if (self.camera_processor.selected_vehicle and
                            not self.camera_processor.selected_vehicle_is_pedestrian):
                        self.camera_processor.start_auto_route_to_destination(
                            self.camera_processor.selected_vehicle
                        )
                elif menu_action == 'add_trigger':
                    selected_actor = self.camera_processor.selected_vehicle
                    if not selected_actor:
                        return True
                    actor_type = 'pedestrian' if self.camera_processor.selected_vehicle_is_pedestrian else 'vehicle'
                    self.camera_processor.start_personal_trigger_placement(actor_type, actor=selected_actor)
                elif menu_action == 'remove_trigger':
                    selected_actor = self.camera_processor.selected_vehicle
                    if not selected_actor:
                        return True
                    actor_id = selected_actor.id
                    if self.camera_processor.selected_vehicle_is_pedestrian:
                        self.camera_processor.delete_pedestrian_trigger(actor_id)
                    elif not self.camera_processor.is_ego_vehicle(actor_id):
                        self.camera_processor.delete_vehicle_trigger(actor_id)
                return True

        if (self.camera_processor and pos[1] > 80
                and self.camera_processor.handle_personal_trigger_click(pos[0], pos[1])):
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        keys = pygame.key.get_pressed()
        snap_to_lane = not is_shift_pressed(keys)
        if self.placement_mode == PlacementMode.PEDESTRIAN:
            snap_to_lane = False
        ctrl_pressed = is_ctrl_pressed(keys)

        if ctrl_pressed and self.camera_processor:
            if self.camera_processor.split_waypoint_at_click(pos[0], pos[1]):
                return True

        spawn_vehicle = ctrl_pressed

        if self.placement_mode == PlacementMode.TRIGGER and spawn_vehicle:
            if not self.ready:
                print("World is not ready yet. Please wait for map to finish loading.")
                return True
            if self.camera_processor:
                self.camera_processor.place_trigger_instantly(pos[0], pos[1])
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        if spawn_vehicle:
            if not self.ready:
                print("World is not ready yet. Please wait for map to finish loading.")
                return True
            if not self.camera_processor:
                return True
            detector = self.camera_processor.coordinate_detector
            print(f"\nVehicle placement click: Screen({pos[0]}, {pos[1]})")
            coordinates = detector.screen_to_world_coordinates(
                pos[0], pos[1], self.screen_width, self.screen_height
            )
            if coordinates['success']:
                print(f"Screen-to-world result: World({coordinates['x']:.2f}, {coordinates['y']:.2f}, {coordinates['z']:.2f})")
                if snap_to_lane:
                    lane_result = detector.find_closest_lane_point(
                        coordinates['x'], coordinates['y'], coordinates['z']
                    )
                    if lane_result['success']:
                        coordinates = lane_result
                        coordinates['snapped'] = True
                    else:
                        coordinates['snapped'] = False
                else:
                    coordinates['snapped'] = False
            else:
                coordinates['snapped'] = False

            spawn_role = "npc"
            if self.placement_mode == PlacementMode.PEDESTRIAN:
                coordinates['snapped'] = False
                selected_blueprint = self.pedestrian_menu.get_selected_pedestrian()
                spawn_role = "pedestrian"
            elif self.placement_mode == PlacementMode.EGO:
                selected_blueprint = self.ego_vehicle_menu.get_selected_ego_vehicle()
                spawn_role = "ego"
            else:
                selected_blueprint = self.vehicle_menu.get_selected_vehicle()

            if selected_blueprint:
                self.camera_processor.spawn_vehicle_at_marker(selected_blueprint, coordinates, role=spawn_role)
            self.resolution_menu_open = False
            self.fps_menu_open = False
            return True

        traffic_light_action_clicked = False
        if self.camera_processor:
            traffic_light_action_clicked = self.camera_processor.handle_traffic_light_action_click(pos[0], pos[1])

        if traffic_light_action_clicked:
            return True

        trigger_clicked = False
        if self.camera_processor:
            trigger_clicked = self.camera_processor.handle_trigger_click(pos[0], pos[1])

        if trigger_clicked:
            return True

        waypoint_clicked = False
        if self.camera_processor:
            waypoint_clicked = self.camera_processor.handle_waypoint_click(pos[0], pos[1])

        if waypoint_clicked:
            return True

        if self.camera_processor and self.camera_processor.handle_traffic_light_click(pos[0], pos[1]):
            return True

        if self.camera_processor and self.camera_processor.handle_vehicle_click(pos[0], pos[1]):
            return True

        if self.camera_processor:
            self.camera_processor.clear_vehicle_selection()
            self.camera_processor.waypoint_display_vehicle_id = None
            self.camera_processor.selected_trigger_index = None
            self.camera_processor.trigger_action_menu_position = None
            self.camera_processor.clear_traffic_light_selection()
        self.resolution_menu_open = False
        self.fps_menu_open = False
        return True

    def _reset_right_click_cancel_state(self):
        """Clear pending right-click waypoint cancel tracking."""
        self.right_click_cancel_pending = False
        self.right_click_cancel_start_pos = None

    def _arm_right_click_cancel(self, pos):
        """Begin tracking right-click movement for waypoint cancel handling."""
        self.right_click_cancel_pending = True
        self.right_click_cancel_start_pos = pos

    def _begin_mouse_pan(self, pos, button):
        """Start a mouse-drag pan for the given button."""
        self.mouse_dragging = True
        self.mouse_drag_button = button
        self.last_mouse_pos = pos
        if self.camera_processor:
            self.camera_processor.begin_manual_camera_free_look("mouse_pan")

    def _end_mouse_pan(self):
        """Finish a mouse-drag pan and restore camera state."""
        self.mouse_dragging = False
        self.mouse_drag_button = None
        if self.camera_panned_with_mouse and self.camera_controller and self.world:
            # Prototype: camera navigation performs no terrain raycasts.
            self.camera_panned_with_mouse = False
            if self.camera_processor:
                self.camera_processor.restore_vehicle_menu_after_camera_pan()
        if self.camera_processor:
            self.camera_processor.end_manual_camera_free_look("mouse_pan")

    def _handle_right_click_down(self, event):
        """Handle right mouse button down."""
        keys = pygame.key.get_pressed()
        in_scene_click = event.pos[1] > 80

        # Check if we're in any trigger placement mode
        cancel_trigger = (
            self.camera_processor
            and (self.camera_processor.placing_trigger
                 or self.camera_processor.pending_personal_trigger)
        )

        cancel_waypoint = (
            self.camera_processor
            and self.camera_processor.creating_waypoint
        )

        if is_shift_pressed(keys):
            if not in_scene_click or not self.camera_processor:
                return True
            self.camera_processor.suppress_vehicle_menu_for_camera_pan()
            self.camera_processor.handle_mouse_click(event.pos[0], event.pos[1], move_camera=True)
            self.camera_processor.update_camera_position()
            self.camera_processor.notify_manual_camera_adjustment()
            self.camera_panned_with_mouse = False
            self._reset_right_click_cancel_state()
            return True
        else:
            if cancel_trigger or cancel_waypoint:
                self._arm_right_click_cancel(event.pos)
            else:
                self._reset_right_click_cancel_state()
            self._begin_mouse_pan(event.pos, event.button)
        return True

    def _handle_mouse_button_down(self, event, scenario_running):
        """Dispatch mouse button down events."""
        if event.button == 1:
            return self._handle_left_click(event.pos, scenario_running)
        if event.button == 2:
            self._reset_right_click_cancel_state()
            self._begin_mouse_pan(event.pos, event.button)
            return True
        if event.button == 3:
            return self._handle_right_click_down(event)
        return False

    def _handle_mouse_button_up(self, event):
        """Handle mouse button releases."""
        if event.button == 1:
            if self.weather_window and self.weather_window.alive():
                try:
                    self.weather_window._commit_drag_if_needed()
                except Exception:
                    pass
            if self.camera_processor and self.camera_processor.rotating_vehicle:
                self.camera_processor.stop_vehicle_rotation()
            elif self.camera_processor and self.camera_processor.moving_vehicle:
                self.camera_processor.stop_vehicle_movement()
            elif self.camera_processor and self.camera_processor.moving_waypoint:
                self.camera_processor.stop_waypoint_movement()
            elif self.camera_processor and self.camera_processor.moving_trigger:
                self.camera_processor.stop_trigger_movement()
            elif self.camera_processor and self.camera_processor.moving_personal_trigger:
                self.camera_processor.stop_personal_trigger_movement()
            elif self.camera_processor and self.camera_processor.scaling_traffic_light_trigger:
                self.camera_processor.stop_traffic_light_trigger_scaling()
            elif self.camera_processor and self.camera_processor.scaling_pedestrian_trigger:
                self.camera_processor.stop_pedestrian_trigger_scaling()
            elif self.camera_processor and self.camera_processor.scaling_vehicle_trigger:
                self.camera_processor.stop_vehicle_trigger_scaling()
            elif self.camera_processor and self.camera_processor.scaling_trigger:
                self.camera_processor.stop_trigger_scaling()
            elif self.camera_processor:
                self.camera_processor.handle_waypoint_mouse_release()
        elif event.button in (2, 3):
            if event.button == 3 and self.right_click_cancel_pending and self.camera_processor:
                # Check waypoint first (existing behavior)
                if self.camera_processor.creating_waypoint:
                    print("Right click detected - cancelling waypoint creation mode")
                    self.camera_processor.stop_waypoint_creation()
                # Then check global trigger placement
                elif self.camera_processor.placing_trigger:
                    print("Right click detected - cancelling trigger placement mode")
                    self.camera_processor.stop_trigger_placement()
                # Then check personal trigger placement
                elif self.camera_processor.pending_personal_trigger:
                    print("Right click detected - cancelling personal trigger placement mode")
                    self.camera_processor.cancel_personal_trigger_placement()
            if event.button == 3:
                self._reset_right_click_cancel_state()
            if self.mouse_dragging and self.mouse_drag_button == event.button:
                self._end_mouse_pan()

    def _handle_mouse_motion(self, event):
        """Handle mouse motion. Returns True if the camera moved."""
        camera_moved = False
        if self.info_panel.visible and self.info_panel._is_point_in_panel(event.pos):
            return False

        buttons = pygame.mouse.get_pressed()
        if (self.camera_processor and self.camera_processor.rotating_vehicle and buttons[0]):
            self.camera_processor.update_vehicle_rotation(event.pos[1])
            if (self.info_panel.visible and self.info_panel.object_type in ('vehicle', 'pedestrian') and
                    self.info_panel.selected_object == self.camera_processor.selected_vehicle):
                self.info_panel._refresh_fields()
        elif (self.camera_processor and self.camera_processor.moving_vehicle and buttons[0]):
            self.camera_processor.update_vehicle_movement(event.pos)
            if (self.info_panel.visible and self.info_panel.object_type in ('vehicle', 'pedestrian') and
                    self.info_panel.selected_object == self.camera_processor.selected_vehicle):
                self.info_panel._refresh_fields()
        elif (self.camera_processor and buttons[0] and
              not self.camera_processor.creating_waypoint and
              (self.camera_processor.moving_waypoint or self.camera_processor.waypoint_drag_armed)):
            self.camera_processor.update_waypoint_movement(event.pos)
            if (self.info_panel.visible and self.info_panel.object_type == 'waypoint' and
                    self.camera_processor.selected_waypoint_vehicle_id is not None and
                    self.camera_processor.selected_waypoint_index is not None):
                self.info_panel._refresh_fields()
        elif (self.camera_processor and self.camera_processor.moving_trigger and buttons[0]):
            self.camera_processor.update_trigger_movement(event.pos)
        elif (self.camera_processor and self.camera_processor.moving_personal_trigger and buttons[0]):
            self.camera_processor.update_personal_trigger_movement(event.pos)
        elif (self.camera_processor and self.camera_processor.scaling_traffic_light_trigger and buttons[0]):
            self.camera_processor.update_traffic_light_trigger_scaling(event.pos)
            # Refresh info panel to update trigger radius display in real-time
            if (self.info_panel.visible and self.info_panel.object_type == 'traffic_light'):
                panel_group = self.info_panel.selected_object
                scaling_group = self.camera_processor._traffic_light_scaling_group
                if panel_group and scaling_group and panel_group.ids == scaling_group.ids:
                    self.info_panel._refresh_fields()
        elif (self.camera_processor and self.camera_processor.scaling_pedestrian_trigger and buttons[0]):
            self.camera_processor.update_pedestrian_trigger_scaling(event.pos)
            # Refresh info panel to update trigger radius display in real-time
            if (self.info_panel.visible and self.info_panel.object_type == 'pedestrian'):
                panel_actor = self.info_panel.selected_object
                if panel_actor and panel_actor.id == self.camera_processor._pedestrian_scaling_id:
                    self.info_panel._refresh_fields()
        elif (self.camera_processor and self.camera_processor.scaling_vehicle_trigger and buttons[0]):
            self.camera_processor.update_vehicle_trigger_scaling(event.pos)
            if (self.info_panel.visible and self.info_panel.object_type == 'vehicle'):
                panel_actor = self.info_panel.selected_object
                if panel_actor and panel_actor.id == self.camera_processor._vehicle_scaling_id:
                    self.info_panel._refresh_fields()
        elif (self.camera_processor and self.camera_processor.scaling_trigger and buttons[0]):
            self.camera_processor.update_trigger_scaling(event.pos)
        elif self.mouse_dragging and self.camera_controller:
            dx = event.pos[0] - self.last_mouse_pos[0]
            dy = event.pos[1] - self.last_mouse_pos[1]

            allow_pan = True
            if self.right_click_cancel_pending and self.mouse_drag_button == 3:
                if self.right_click_cancel_start_pos is None:
                    self.right_click_cancel_start_pos = self.last_mouse_pos
                total_dx = event.pos[0] - self.right_click_cancel_start_pos[0]
                total_dy = event.pos[1] - self.right_click_cancel_start_pos[1]
                deadzone_sq = self.right_click_cancel_deadzone * self.right_click_cancel_deadzone
                if (total_dx * total_dx + total_dy * total_dy) >= deadzone_sq:
                    self._reset_right_click_cancel_state()
                else:
                    allow_pan = False

            if allow_pan:
                if (dx != 0 or dy != 0) and self.camera_processor:
                    self.camera_processor.suppress_vehicle_menu_for_camera_pan()
                base_scale = 0.1
                navigation_height = self.camera_controller.get_navigation_height()
                height_scale = navigation_height / 400.0
                scale = base_scale * height_scale
                world_dx = -dx * scale
                world_dy = -dy * scale
                self.camera_controller.pan(world_dx, world_dy, 1.0)
                camera_moved = True
                self.camera_panned_with_mouse = True

            self.last_mouse_pos = event.pos
        return camera_moved

    def _handle_mouse_wheel(self, event, scenario_running):
        """Handle mouse wheel scrolling. Returns True if the camera moved."""
        active_menu = self.get_active_selection_menu() if not scenario_running else None
        if active_menu and active_menu.handle_scroll(pygame.mouse.get_pos(), event.y):
            return False
        if self.map_menu_visible and self.map_menu and self.map_menu.handle_scroll(
                pygame.mouse.get_pos(), event.y):
            return False
        if self.camera_controller:
            if self.camera_processor:
                self.camera_processor.suppress_vehicle_menu_for_camera_pan()
            zoom_delta = -event.y
            self.camera_controller.zoom(zoom_delta)
            if self.camera_processor:
                self.camera_processor.update_camera_position()
                self.camera_processor.notify_manual_camera_adjustment()
                self.camera_processor.restore_vehicle_menu_after_camera_pan()
            return True
        return False

    def _handle_resize(self, event):
        """Handle window resize events."""
        new_width = event.w
        new_height = event.h
        if (abs(self.screen_width - new_width) > 10 or abs(self.screen_height - new_height) > 10):
            self.screen_width = new_width
            self.screen_height = new_height
            if not self.maximized:
                self.windowed_width = new_width
                self.windowed_height = new_height
            if self.camera_processor:
                self.camera_processor.update_screen_size(self.screen_width, self.screen_height)
            print(f"Window resized to: {self.screen_width}x{self.screen_height}")
            if self.ui_manager:
                self.ui_manager.set_window_resolution((self.screen_width, self.screen_height))
            if self.tooltip_manager:
                self.tooltip_manager.update_screen_size(self.screen_width, self.screen_height)

    def _center_dialog_rect(self, width: int, height: int) -> pygame.Rect:
        """Return a rectangle centered in the current window."""
        rect = pygame.Rect(0, 0, width, height)
        rect.center = (self.screen_width // 2, self.screen_height // 2)
        return rect

    def _render_dialog_background(self) -> None:
        """Re-render a clean background (with menus closed) for modal dialogs."""
        self.screen.fill(self.colors['background'])
        if not self.ready:
            return

        if self.camera_processor:
            latest_image = self.camera_processor.get_latest_image()
            if self.camera_stream_enabled and latest_image:
                self.screen.blit(latest_image, (0, 0))
            elif not self.camera_stream_enabled:
                self.screen.fill((0, 0, 0))

        self.render_crosshair()
        self.render_ui()
        self.render_mode_toggle()

        active_menu = self.get_active_selection_menu()
        if active_menu and not self.scenario_running:
            active_menu.render(self.screen)

        if self.camera_processor:
            self.camera_processor.render_all_overlays(self.screen)

        self.info_panel.render(self.screen, tooltip_manager=self.tooltip_manager)

        fps_rect = self.render_fps_meter()
        self.render_rendering_toggle(fps_rect)

    def _run_modal_window(self, dialog: UIWindow, event_handler) -> Optional[Union[bool, str, Dict[str, Union[str, int]]]]:
        """
        Run a blocking modal loop around the supplied window.

        Args:
            dialog: The pygame_gui window to display.
            event_handler: Callback taking a pygame event and returning a tuple
                ``(should_stop, result)``. When ``should_stop`` is True the loop exits
                and ``result`` is returned.

        Returns:
            The result provided by the handler, or None if the dialog was cancelled.
        """
        self._close_all_dropdowns(keep_info_panel=True)
        self._render_dialog_background()

        clock = pygame.time.Clock()
        snapshot = self.screen.copy()
        shade = pygame.Surface(self.screen.get_size(), pygame.SRCALPHA)
        shade.fill((0, 0, 0, 160))

        mouse_visible = pygame.mouse.get_visible()
        mouse_grabbed = pygame.event.get_grab()
        pygame.mouse.set_visible(True)
        if mouse_grabbed:
            pygame.event.set_grab(False)

        result = None
        running = True

        while running and dialog.alive():
            time_delta = clock.tick(60) / 1000.0

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    dialog.kill()
                    running = False
                    result = None
                    break

                if self.ui_manager:
                    self.ui_manager.process_events(event)

                should_stop, handled_result = event_handler(event)
                if should_stop:
                    result = handled_result
                    if dialog.alive():
                        dialog.kill()
                    running = False
                    break

            if self.ui_manager:
                self.ui_manager.update(time_delta)

            self.screen.blit(snapshot, (0, 0))
            self.screen.blit(shade, (0, 0))
            if self.ui_manager:
                self.ui_manager.draw_ui(self.screen)
            pygame.display.flip()

        if dialog.alive():
            dialog.kill()

        pygame.mouse.set_visible(mouse_visible)
        pygame.event.set_grab(mouse_grabbed)

        if self.ui_manager:
            self.ui_manager.update(0.0)

        return result

    def _prompt_text_input(self, title: str, prompt: str, default: str = "") -> Optional[str]:
        """Display a simple text input modal and return the user entry."""
        self._close_all_dropdowns(keep_info_panel=True)
        dialog_rect = self._center_dialog_rect(360, 200)
        dialog = TextInputDialog(
            rect=dialog_rect,
            manager=self.ui_manager,
            title=title,
            prompt=prompt,
            default_text=default,
        )

        def handler(event: pygame.event.Event):
            if event.type == UI_BUTTON_PRESSED:
                if event.ui_element == dialog.ok_button:
                    return True, dialog.text_entry.get_text()
                if event.ui_element == dialog.cancel_button:
                    return True, None
            if event.type == UI_TEXT_ENTRY_FINISHED and event.ui_element == dialog.text_entry:
                return True, dialog.text_entry.get_text()
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, None
            return False, None

        result = self._run_modal_window(dialog, handler)
        if result is None:
            return None
        result = str(result).strip()
        return result or None
    
    def __init__(self, carla_path=None, port=2000, *, debug: bool = False):
        self.keep_server_running_on_exit = False
        # Initialize Pygame
        pygame.init()

        # Screen settings
        self.windowed_width = 1200
        self.windowed_height = 800
        self.screen_width = self.windowed_width
        self.screen_height = self.windowed_height
        self.maximized = False
        self.stream_resolution = (1280, 720)
        self.camera_stream_enabled = True
        base_resolution_options = list(REMOTE_STREAM_RESOLUTIONS)
        self.remote_resolution_options: List[Optional[Tuple[int, int]]] = [None] + base_resolution_options
        if self.stream_resolution in base_resolution_options:
            self.remote_resolution_index = self.remote_resolution_options.index(self.stream_resolution)
        elif base_resolution_options:
            first_resolution = base_resolution_options[0]
            self.stream_resolution = first_resolution
            self.remote_resolution_index = self.remote_resolution_options.index(first_resolution)
        else:
            self.remote_resolution_index = 0
            self.camera_stream_enabled = False
        self.stream_fps = 10
        self.remote_fps_min = 1
        self.remote_fps_max = 20
        self.resolution_menu_open = False
        self.fps_menu_open = False
        self.resolution_option_rects: List[Tuple[pygame.Rect, Optional[Tuple[int, int]]]] = []
        self.fps_option_rects: List[Tuple[pygame.Rect, int]] = []
        self._dropdown_draw_ops: List[Tuple[pygame.Rect, Tuple[int, int, int], pygame.Surface]] = []
        self._dropdown_capture_rects: List[pygame.Rect] = []
        self._dropdown_mouse_captured = False
        self.result_window: Optional[ResultWindow] = None
        self._pending_result_dialog: Optional[Dict[str, object]] = None
        self._no_camera_resolution_override: Optional[Tuple[int, int]] = None
        self._no_camera_saved_pose: Optional[Tuple[float, float, float]] = None

        env_windowed_width = os.environ.get('VSE_WINDOWED_WIDTH')
        env_windowed_height = os.environ.get('VSE_WINDOWED_HEIGHT')
        env_screen_width = os.environ.get('VSE_SCREEN_WIDTH')
        env_screen_height = os.environ.get('VSE_SCREEN_HEIGHT')
        env_maximized = os.environ.get('VSE_WINDOW_MAXIMIZED')

        try:
            if env_windowed_width:
                windowed_width = int(env_windowed_width)
                if windowed_width > 0:
                    self.windowed_width = windowed_width
        except ValueError:
            pass

        try:
            if env_windowed_height:
                windowed_height = int(env_windowed_height)
                if windowed_height > 0:
                    self.windowed_height = windowed_height
        except ValueError:
            pass

        try:
            if env_screen_width:
                screen_width = int(env_screen_width)
                if screen_width > 0:
                    self.screen_width = screen_width
        except ValueError:
            pass

        try:
            if env_screen_height:
                screen_height = int(env_screen_height)
                if screen_height > 0:
                    self.screen_height = screen_height
        except ValueError:
            pass

        if env_maximized:
            self.maximized = env_maximized == '1'

        # Check for pending scenario load from map change
        pending_scenario = os.environ.get('VSE_PENDING_SCENARIO')
        if pending_scenario:
            self.pending_scenario_load = pending_scenario
            print(f"Restored pending scenario from environment: {pending_scenario}")

        os.environ.pop('VSE_WINDOWED_WIDTH', None)
        os.environ.pop('VSE_WINDOWED_HEIGHT', None)
        os.environ.pop('VSE_SCREEN_WIDTH', None)
        os.environ.pop('VSE_SCREEN_HEIGHT', None)
        os.environ.pop('VSE_WINDOW_MAXIMIZED', None)
        os.environ.pop('VSE_PENDING_SCENARIO', None)

        # Create windowed screen initially
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height), pygame.RESIZABLE)
        pygame.display.set_caption("Visual Scenario Editor")

        # pygame_gui manager
        self.ui_manager = UIManager((self.screen_width, self.screen_height))

        # Tooltip manager for hover help
        self.tooltip_manager = TooltipManager(self.screen_width, self.screen_height)

        # Colors
        self.colors = {
            'background': (50, 50, 50),
            'text': (255, 255, 255),
            'ui_bg': (30, 30, 30, 180),
            'loading': (100, 100, 255),
            'error': (255, 100, 100),
            'coordinates': (255, 255, 0),  # Yellow overlays
            'fps': (255, 255, 0),          # Yellow FPS meter
            'toggle_on': (80, 150, 80),
            'toggle_off': (70, 70, 70),
            'button': (70, 70, 70),
            'button_hover': (90, 90, 90),
        }

        self.top_ui_height = 90
        self.side_panel_top = self.top_ui_height + 60
        self.mode_button_base_x = 10
        self.mode_button_width = 140
        self.mode_button_height = 28
        self.mode_button_spacing = 10

        # Font for UI
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 18)
        self.tiny_font = pygame.font.Font(None, 14)
        self.micro_font = pygame.font.Font(None, 12)
        self.fps_font = pygame.font.Font(None, 18)
        self._fps_display = 0.0
        self._fps_smoothing = 0.85
        self._world_tick_times: Deque[float] = deque()
        self._world_tick_window = 3.0
        self._world_tick_fps = 0.0
        self.rendering_enabled = False
        self._rendering_desired_enabled = False
        self.rendering_toggle_rect: Optional[pygame.Rect] = None
        self._rendering_apply_in_progress = False
        self._fps_text_rect: Optional[pygame.Rect] = None
        self.large_map_active = False
        try:
            self.large_map_ui_delay = float(os.environ.get("VSE_LARGE_MAP_UI_DELAY", "0.2"))
        except ValueError:
            self.large_map_ui_delay = 5.0

        # UI integration state
        self.open_map_button_rect = None
        self.connection_button_rect = None
        self.gpu_button_rect = None
        self.manual_tick_button_rect = None
        self.resolution_button_rect = None
        self.fps_button_rect = None
        self.open_scenario_button_rect = None
        self.last_map_directory = self._resolve_default_map_directory()
        
        # CARLA components
        self.camera_processor = None
        self.info_panel = None
        self.server_manager = CarlaServerManager(carla_path, port)
        self.local_port = port
        self._default_engine_ini_backup_path: Optional[Path] = None
        self._restore_default_engine_ini_backup_if_present()

        profile_override_raw = os.environ.pop('VSE_PROFILE_JSON', None)
        self._launched_with_profile_override = bool(profile_override_raw)
        override_profile = None
        override_label = None
        override_port = None
        if profile_override_raw:
            try:
                profile_data = json.loads(profile_override_raw)
                override_profile = ConnectionProfile(
                    name=profile_data.get('name', 'remote'),
                    host=profile_data.get('host', '127.0.0.1'),
                    port=int(profile_data.get('port', port)),
                    manage_server=bool(profile_data.get('manage_server', False)),
                    display_name=profile_data.get('display_name', profile_data.get('host', 'Remote CARLA')),
                    description=profile_data.get('description', ''),
                    map_hint=profile_data.get('map_hint')
                )
                override_label = profile_data.get('label')
                override_port = int(profile_data.get('port', port))
            except Exception as exc:
                print(f"Failed to parse connection profile override: {exc}")
                override_profile = None

        self.connection_profile = override_profile or self._create_local_profile()
        self.server_manager.set_port(self.local_port)
        self._previous_connection_profile = None
        self.remote_connection_active = self.connection_profile.is_remote
        self.cached_map = None
        self._map_refresh_disabled = False
        self.remote_map_hint = "tartu_demo"
        self._load_last_remote_cache()
        self._load_last_agent_cache()
        if override_profile and override_profile.is_remote:
            self.active_remote_label = override_label or f"{override_profile.host}:{override_profile.port}"
            self.active_remote_port = override_port
            if not getattr(self, "last_remote_host", None):
                self.last_remote_host = override_profile.host
            if override_port is not None and not getattr(self, "last_remote_port", None):
                self.last_remote_port = str(override_port)
        else:
            self.active_remote_label = None
            self.active_remote_port = None
        self.pending_profile_switch = None
        self.pending_profile_switch_label = None
        self.pending_map_switch = None
        self.pending_remote_map = os.environ.pop('VSE_PENDING_MAP', None)
        self.client = None
        self.world = None
        self.world_map = None
        self.manual_tick_required = False
        self.manual_tick_interval = 0.05
        self.manual_tick_accumulator = 0.0
        self.manual_tick_enabled = False
        self.manual_tick_recommendation = False
        self._large_map_bootstrap_ticking = False  # Temporary ticking until external ego connects on large maps
        self._bootstrap_tick_warned = False  # Suppress repeated bootstrap tick warnings
        self._pending_external_ego_data = None  # Saved ego data to apply to external ego on large maps
        self._bootstrap_original_camera_transform = None  # Save camera position before moving to spawn point
        self._external_ego_present_last_check = False
        self._last_external_ego_scan_time = 0.0
        self._manual_tick_last_required_time = 0.0
        self._external_ego_scenario_reloaded = False
        self._external_ego_prompt_pending_id = None
        # When True, external ego detection should never auto-adopt/move the actor.
        # Used for "New Scenario" resets where the external ego must remain untouched.
        self._suppress_external_ego_adoption = False
        self._scenario_run_in_progress = False  # Track scenario launch phase to prevent bootstrap during playback
        self._external_swap_active = False
        self._external_swap_current_id = None
        self._external_swap_last_transform = None
        self._external_swap_last_blueprint = None
        self._external_swap_last_color = None
        self._external_swap_pre_run_transform = None
        self._external_swap_overlay = False
        self._external_swap_overlay_message: Optional[str] = None
        self._external_swap_overlay_started_at: float = 0.0
        self._external_swap_overlay_keep_until: float = 0.0
        # Camera systems
        self.camera_controller = None
        self.camera_processor = None
        self.camera_debug_enabled = bool(debug)
        self.debug_mode = bool(debug)
        self._pending_camera_focus_target: Optional[Tuple[float, float, float]] = None
        self._pending_camera_focus_not_before: float = 0.0
        self._pending_camera_focus_until: float = 0.0
        self._pending_camera_focus_last_attempt: float = 0.0
        self._pending_camera_focus_reason: Optional[str] = None
        self._pending_camera_focus_debug_logged: bool = False
        
        # Input states
        self.keys_pressed = set()
        self.mouse_dragging = False
        self.mouse_drag_button = None
        self.right_click_cancel_pending = False
        self.right_click_cancel_start_pos = None
        self.right_click_cancel_deadzone = 8  # pixels of tolerance before treating right-drag as a pan
        self.last_mouse_pos = (0, 0)

        # Camera movement tracking for dynamic min height
        self.camera_panned_with_mouse = False  # Track if mouse (right/middle) pan occurred
        self.camera_moved_with_wasd = False    # Track if WASD movement occurred
        
        # Key acceleration tracking
        self.key_hold_times = {}
        self.max_acceleration_time = 2.0
        self.acceleration_curve = 3.0
        
        # Startup state
        self.loading_stage = "Checking for existing CARLA server..."
        self.ready = False
        self.startup_error = None
        self.start_screen_active = False
        self.start_screen_open_scenario_rect: Optional[pygame.Rect] = None
        self.start_screen_open_map_rect: Optional[pygame.Rect] = None
        self.start_screen_connect_remote_rect: Optional[pygame.Rect] = None
        self.start_screen_recent_scenario_rects: List[Tuple[pygame.Rect, Optional[str]]] = []
        self._startup_requested = False
        self._startup_thread_started = False
        self._startup_selected_map_name: Optional[str] = None
        self._startup_selected_map_package: Optional[str] = None
        self._startup_selected_scenario_path: Optional[str] = None

        # Check for startup map package from environment (for INI patching before CARLA starts)
        # This is used when reloading after external ego removal on large maps
        startup_map_package = os.environ.get('VSE_STARTUP_MAP_PACKAGE')
        if startup_map_package:
            self._startup_selected_map_package = startup_map_package
            self._startup_selected_map_name = startup_map_package.split('/')[-1]
            print(f"[Startup] Restored startup map package from environment: {startup_map_package}")
            os.environ.pop('VSE_STARTUP_MAP_PACKAGE', None)

        self.restart_thread = None
        self.restart_in_progress = False
        self.relaunch_process = None
        self.restart_start_time = None
        self.restart_wait_duration = 30.0
        self.pending_exit = False
        self.handoff_read_fd = None
        self.wait_for_child = False
        handoff_fd_env = os.environ.get('VSE_HANDOFF_FD')
        if handoff_fd_env is not None:
            try:
                self.handoff_write_fd = int(handoff_fd_env)
            except ValueError:
                self.handoff_write_fd = None
            os.environ.pop('VSE_HANDOFF_FD', None)
        else:
            self.handoff_write_fd = None

        auto_start = bool(
            self.handoff_write_fd is not None
            or getattr(self, "pending_scenario_load", None)
            or self.pending_remote_map
            or self._launched_with_profile_override
            or self._startup_selected_map_package is not None
            or getattr(self.server_manager, "assume_existing_server_pid", None) is not None
        )
        if auto_start:
            self.start_screen_active = False
            self._startup_requested = True
        else:
            self.start_screen_active = True
            self._startup_requested = False
            try:
                self.server_manager.kill_existing_carla_processes()
            except Exception as exc:
                print(f"[Startup] Warning: failed to kill existing CARLA processes: {exc}")
        
        # Selection menus
        self.vehicle_menu = VehicleSelectionMenu()
        self.selected_vehicle_type = None
        self.pedestrian_menu = PedestrianSelectionMenu()
        self.selected_pedestrian_type = None
        self.ego_vehicle_menu = EgoVehicleSelectionMenu()
        self.selected_ego_vehicle_type = None
        self.traffic_light_group_menu = TrafficLightGroupSelectionMenu()
        self.placement_mode = PlacementMode.VEHICLE
        self.mode_button_rects = {}
        self.weather_button_rect = None
        self.weather_button_enabled = False
        self.weather_window: Optional[WeatherControlWindow] = None
        self._weather_state: Dict[str, float] = {}
        self._weather_spec_lookup: Dict[str, WeatherParameterSpec] = {
            spec.name: spec for spec in WEATHER_PARAMETER_SPECS
        }
        self._weather_keyframes: List[Dict[str, float]] = []
        self._active_weather_index: int = 0
        self._pending_weather_pct: float = 0.0
        self._weather_drag_snapshot: Optional[Dict[str, object]] = None
        self._baseline_weather_state: Optional[Dict[str, float]] = None

        self.vehicle_menu.set_vertical_offset(self.side_panel_top)
        self.pedestrian_menu.set_vertical_offset(self.side_panel_top)
        self.ego_vehicle_menu.set_vertical_offset(self.side_panel_top)
        self.traffic_light_group_menu.set_vertical_offset(self.side_panel_top)
        self.vehicle_menu.set_camera_processor(None)
        self.pedestrian_menu.set_camera_processor(None)
        self.ego_vehicle_menu.set_camera_processor(None)
        self.traffic_light_group_menu.set_camera_processor(None)
        for _menu in (self.vehicle_menu, self.pedestrian_menu, self.ego_vehicle_menu):
            _menu.on_dropdown_open = (lambda menu_ref=_menu: self._close_all_dropdowns(except_menu=menu_ref))

        # Map selection menu
        self.map_menu = None  # Will be initialized after world is created
        self.map_menu_visible = False

        # Scenario selection menu
        self.scenario_menu = None  # Will be initialized after world is created
        self.scenario_menu_visible = False
        self.current_scenario_name = None  # Name of currently loaded scenario
        self.current_scenario_path = None  # Full path to currently loaded scenario JSON
        self.recent_scenarios: List[Dict[str, str]] = []  # Cached recent scenarios (most recent first)
        self.last_scenario_path: Optional[str] = None  # Cached recent scenario path (first entry)
        self.last_scenario_name: Optional[str] = None  # Cached recent scenario name (first entry)
        self.last_scenario_map: Optional[str] = None   # Cached map name (first entry)
        # pending_scenario_load is set earlier from environment variable if present
        if not hasattr(self, 'pending_scenario_load'):
            self.pending_scenario_load = None  # Scenario to load after map change
        self._load_last_scenario_cache()

        # Scenario runner state (for Play button functionality)
        self.scenario_running = False
        self.scenario_process = None
        self.scenario_stop_requested = False
        self.saved_scene_vehicles = []
        self.external_ego_actor = None
        self.external_ego_actor_id = None
        self.scene_preview_destroyed = False
        self._world_settings_signature = None
        self._scenario_preserved_waypoint_vehicle_id = None
        self._scenario_preserved_waypoints = None
        self._scenario_preserved_actor_blueprint = None
        self._scenario_preserved_actor_location = None
        self._scenario_preserved_actor_is_pedestrian = False
        self._scenario_preserved_info_panel_visible = False
        self._scenario_preserved_waypoint_signature = None
        self._scenario_preserved_traffic_light_ids: Optional[Tuple[int, ...]] = None
        self._scenario_preserved_traffic_light_info_visible = False
        self._scenario_active_traffic_light_trigger: Optional[Dict[str, object]] = None
        self._scenario_preserved_traffic_lights_visible = False
        self._scenario_preserved_lane_overlay_enabled = False
        self._scenario_pending_actor_reselect = False
        self._scenario_pending_actor_reselect_attempts = 0
        self._scenario_pending_actor_reselect = False
        self._scenario_pending_actor_reselect_attempts = 0
        self._scenario_pending_actor_reselect_max_attempts = 120
        self._camera_restore_state: Optional[Tuple[float, float, float]] = None
        self._restore_in_progress: bool = False
        self._restore_invoked_for_run: bool = False
        self._restore_once_lock = threading.Lock()
        self._debug_last_pose_label: Optional[str] = None
        self._scenario_active_override: bool = False
        self.loaded_scenario_data: Optional[dict] = None

        # Scene change tracking
        self._scene_dirty_hint = False
        self._saved_scene_signature: Optional[str] = None  # legacy snapshot (deprecated)
        self._saved_disk_signature: Optional[str] = None   # legacy snapshot (deprecated)
        self._history_position = 0  # Monotonic counter of applied edits
        self._saved_history_position = 0  # Counter at last save/load

        # World reset detection and recovery
        self._world_reset_candidate_world = None
        self._world_tick_subscription = None
        self._world_last_episode = None
        self._world_last_frame = None
        self._world_reset_lock = threading.Lock()
        self._world_reset_pending = False
        self._world_reset_detected_at = 0.0
        self._world_reset_in_progress = False
        self._world_reset_wait_thread = None
        self._world_reset_ready_world = None
        self._world_reset_finalize_pending = False

        # Info panel for waypoint/vehicle editing will be initialized in startup_sequence
        
        # Undo/Redo system
        self.command_history = []  # List of executed commands
        self.undo_stack = []       # Commands that can be undone (max 25)
        self.redo_stack = []       # Commands that can be redone
        self.max_undo_history = 25

    def _camera_debug(self, message: str) -> None:
        """Emit camera-related debug logs when debug mode is enabled."""
        if self.camera_debug_enabled:
            print(message)

    def _debug_camera_pose(self, label: str):
        """Print current camera center/height for debugging jumps."""
        if not self.camera_debug_enabled:
            return
        ctrl = getattr(self, "camera_controller", None)
        if not ctrl:
            self._camera_debug(f"[CameraDebug] {label}: camera_controller unavailable")
            return
        try:
            pose = f"({ctrl.center_x:.2f}, {ctrl.center_y:.2f}) h={getattr(ctrl, 'height', 0.0):.2f}"
            self._camera_debug(f"[CameraDebug] {label}: center={pose}")
            self._debug_last_pose_label = label
        except Exception as exc:
            self._camera_debug(f"[CameraDebug] {label}: unable to read camera pose ({exc})")

    def _auto_camera_allowed(self) -> bool:
        """Return True if automatic camera moves are allowed."""
        return bool(getattr(self, "camera_stream_enabled", False))

    def _schedule_camera_focus(
        self,
        location: Optional[carla.Location],
        *,
        delay_s: float = 0.0,
        keep_s: float = 2.0,
        reason: Optional[str] = None,
    ) -> None:
        """Schedule repeated camera focusing for a short window (used to survive async actor teleports)."""
        if location is None:
            return
        try:
            target = (float(location.x), float(location.y), float(location.z))
        except Exception:
            return
        now = time.time()
        delay_s = max(0.0, float(delay_s))
        keep_s = max(0.1, float(keep_s))
        self._pending_camera_focus_target = target
        self._pending_camera_focus_not_before = now + delay_s
        self._pending_camera_focus_until = now + delay_s + keep_s
        self._pending_camera_focus_last_attempt = 0.0
        self._pending_camera_focus_reason = reason
        self._pending_camera_focus_debug_logged = False

    def _process_pending_camera_focus(self) -> None:
        """Apply any scheduled camera focus requests (main-thread)."""
        target = getattr(self, "_pending_camera_focus_target", None)
        if not target:
            return
        now = time.time()
        if now < getattr(self, "_pending_camera_focus_not_before", 0.0):
            return
        if now > getattr(self, "_pending_camera_focus_until", 0.0):
            self._pending_camera_focus_target = None
            self._pending_camera_focus_reason = None
            self._pending_camera_focus_debug_logged = False
            return
        last_attempt = getattr(self, "_pending_camera_focus_last_attempt", 0.0)
        if now - last_attempt < 0.12:
            return
        self._pending_camera_focus_last_attempt = now
        cp = self.camera_processor
        if not cp:
            return
        try:
            x, y, z = target
            focus_loc = carla.Location(x=float(x), y=float(y), z=float(z))
        except Exception:
            self._pending_camera_focus_target = None
            self._pending_camera_focus_reason = None
            self._pending_camera_focus_debug_logged = False
            return
        if self.camera_debug_enabled and not self._pending_camera_focus_debug_logged:
            try:
                self._camera_debug(
                    f"[CameraDebug] Pending focus scheduled ({self._pending_camera_focus_reason or 'unspecified'}) "
                    f"→ ({focus_loc.x:.2f}, {focus_loc.y:.2f}, {focus_loc.z:.2f})"
                )
                self._debug_camera_pose("pending-focus-before")
            except Exception:
                pass
            self._pending_camera_focus_debug_logged = True
        try:
            cp.focus_camera_on_location(focus_loc)
        except Exception:
            return
        if self.camera_debug_enabled and self._pending_camera_focus_debug_logged:
            try:
                self._debug_camera_pose("pending-focus-after")
            except Exception:
                pass

    def _get_cached_map(self, refresh=False):
        if self.cached_map is not None:
            return self.cached_map

        editor = getattr(self, 'editor', None)
        if editor is not None:
            map_obj = editor._safe_get_world_map(refresh=refresh)
            if map_obj is not None:
                self.cached_map = map_obj
            return map_obj

        if refresh and self.world:
            try:
                self.cached_map = self.world.get_map()
            except Exception as exc:
                print(f"[Map] Unable to refresh cached map from camera processor: {exc}")
        return self.cached_map


    def connect_to_remote(self):
        """Prompt for remote host/port and switch to it."""
        self.map_menu_visible = False
        selection = self._show_remote_connection_dialog()
        if not selection:
            print("Remote connection cancelled.")
            if self.start_screen_active:
                self.startup_error = None
            return False

        action = selection.get('action') or "cancel"
        host = (selection.get('host') or "").strip()
        port_raw = (selection.get('port') or "").strip()

        if action == "local":
            return self._confirm_switch_to_local()

        if action != "ok":
            print("Remote connection cancelled.")
            if self.start_screen_active:
                self.startup_error = None
            return False

        self._remember_last_remote(host, port_raw)

        if not host:
            print("[Remote] Host is required.")
            if self.start_screen_active:
                self.startup_error = "Remote host is required."
            return False
        try:
            port = int(port_raw)
        except ValueError:
            print("[Remote] Port must be a number.")
            if self.start_screen_active:
                self.startup_error = "Remote port must be a number."
            return False

        profile = self._create_remote_profile(host, port)
        if (
            self.connection_profile
            and self.connection_profile.is_remote
            and self.connection_profile.host == profile.host
            and self.connection_profile.port == profile.port
        ):
            print(f"[Remote] Already connected to {host}:{port}.")
            if self.start_screen_active:
                self.startup_error = f"Already connected to {host}:{port}."
            return False

        if not self._probe_remote_connection(profile.host, profile.port, max_attempts=3, timeout=3.0):
            print(f"[Remote] Cannot reach {profile.host}:{profile.port}. Leaving current session untouched.")
            if self.start_screen_active:
                self.startup_error = f"Cannot reach {profile.host}:{profile.port}."
            else:
                self._show_error_overlay(f"Cannot connect to {profile.host}:{profile.port}")
            return False

        label = f"{host}:{port}"
        print(f"[Remote] Connecting to {label}...")
        self.active_remote_label = label
        self.active_remote_port = port
        self.manual_tick_enabled = False
        self.manual_tick_accumulator = 0.0
        self.manual_tick_recommendation = False
        self.resolution_menu_open = False
        self.fps_menu_open = False
        started = self._restart_with_profile(profile, label=label)
        if started and self.start_screen_active:
            self.start_screen_active = False
        return started

    def _show_remote_connection_dialog(self):
        """Prompt the user for remote host/port."""
        self._close_all_dropdowns(keep_info_panel=True)
        default_host = getattr(self, "last_remote_host", None) or ""
        default_port = getattr(self, "last_remote_port", None) or ""
        if (not default_host or not default_port) and self.connection_profile and self.connection_profile.is_remote:
            default_host = default_host or self.connection_profile.host
            default_port = default_port or str(self.connection_profile.port)
        show_local_button = bool(self.connection_profile and self.connection_profile.is_remote)
        dialog_rect = self._center_dialog_rect(420, 220)
        dialog = RemoteConnectionDialog(
            rect=dialog_rect,
            manager=self.ui_manager,
            default_host=default_host,
            default_port=default_port,
            show_local_button=show_local_button,
        )

        def handler(event: pygame.event.Event):
            if not dialog.alive():
                return True, dialog.get_values()
            if event.type == UI_BUTTON_PRESSED:
                if event.ui_element in (dialog.ok_button, dialog.cancel_button) or (
                    dialog.show_local_button and event.ui_element == dialog.local_button
                ):
                    return True, dialog.get_values()
            if event.type == UI_TEXT_ENTRY_FINISHED and event.ui_element in (dialog.host_entry, dialog.port_entry):
                return True, dialog.get_values()
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, dialog.get_values()
            return False, None

        return self._run_modal_window(dialog, handler)

    def _using_remote_server(self) -> bool:
        profile = self.connection_profile
        return bool(profile and profile.is_remote)

    def _apply_stream_settings(self):
        if not self.camera_processor:
            return
        target_fps = self.stream_fps if self._using_remote_server() else 0
        if not self.camera_stream_enabled and getattr(self, "large_map_active", False):
            self.camera_processor.pause_camera_stream()
            return
        self.camera_processor.enable_camera_sensor()

        if self.camera_stream_enabled:
            self.camera_processor.apply_stream_settings(
                resolution=self.stream_resolution,
                fps=target_fps,
            )
            return

        candidates: List[Tuple[int, int]] = []
        if self._no_camera_resolution_override:
            candidates.append(self._no_camera_resolution_override)
        for option in NO_CAMERA_STREAM_RESOLUTIONS:
            if option not in candidates:
                candidates.append(option)

        last_error: Optional[Exception] = None
        for option in candidates:
            try:
                self.camera_processor.apply_stream_settings(
                    resolution=option,
                    fps=target_fps,
                )
            except Exception as exc:
                last_error = exc
                print(
                    f"[Stream] Failed to apply placeholder camera resolution "
                    f"{option[0]}x{option[1]}: {exc}"
                )
                continue

            self._no_camera_resolution_override = option
            if option != NO_CAMERA_STREAM_RESOLUTIONS[0]:
                print(
                    f"[Stream] Using fallback placeholder camera resolution "
                    f"{option[0]}x{option[1]}"
                )
            return

        print("[Stream] Unable to maintain placeholder camera feed; disabling sensor.")
        if last_error:
            print(f"[Stream] Last placeholder error: {last_error}")
        self.camera_processor.disable_camera_sensor()
        self._no_camera_resolution_override = None

    def _cache_camera_pose_for_no_camera(self) -> None:
        """Remember the current camera pose so we can restore it after 'No Camera'."""
        if self._no_camera_saved_pose is not None:
            return
        ctrl = getattr(self, "camera_controller", None)
        if not ctrl:
            return
        self._no_camera_saved_pose = (
            float(getattr(ctrl, "center_x", 0.0)),
            float(getattr(ctrl, "center_y", 0.0)),
            float(getattr(ctrl, "height", 0.0)),
        )
        self._camera_debug(
            f"[CameraDebug] Cached pose before disabling stream: "
            f"({self._no_camera_saved_pose[0]:.1f}, {self._no_camera_saved_pose[1]:.1f}) "
            f"h={self._no_camera_saved_pose[2]:.1f}"
        )

    def _apply_camera_pose(self, pose: Tuple[float, float, float]) -> None:
        """Apply a raw camera pose and sync the CARLA spectator/sensor."""
        ctrl = getattr(self, "camera_controller", None)
        if not ctrl:
            return
        ctrl.center_x, ctrl.center_y, ctrl.height = pose
        if self.camera_processor:
            self.camera_processor.update_camera_position()
            self.camera_processor.notify_manual_camera_adjustment()
            self.camera_processor.restore_vehicle_menu_after_camera_pan()
        if hasattr(ctrl, "stop_moving"):
            ctrl.stop_moving()

    def _jump_camera_to_no_camera_pose(self) -> None:
        """Move the camera out of view when the stream is disabled."""
        if getattr(self, "large_map_active", False):
            self._camera_debug("[CameraDebug] Large map: keeping camera pose for 'No Camera'.")
            return
        placeholder_pose = (-1000.0, -1000.0, 0.0)
        self._camera_debug(
            f"[CameraDebug] Moving camera to placeholder pose: "
            f"({placeholder_pose[0]:.1f}, {placeholder_pose[1]:.1f}) h={placeholder_pose[2]:.1f}"
        )
        self._apply_camera_pose(placeholder_pose)

    def _restore_camera_pose_after_no_camera(self) -> None:
        """Restore the cached pose after re-enabling a camera stream."""
        if not self._no_camera_saved_pose:
            return
        pose = self._no_camera_saved_pose
        self._no_camera_saved_pose = None
        self._camera_debug(
            f"[CameraDebug] Restoring camera pose after re-enabling stream: "
            f"({pose[0]:.1f}, {pose[1]:.1f}) h={pose[2]:.1f}"
        )
        self._apply_camera_pose(pose)

    def _set_stream_resolution(self, resolution: Optional[Tuple[int, int]]):
        label = "[Remote]" if self._using_remote_server() else "[Stream]"
        if resolution is None:
            if self.camera_stream_enabled:
                self._cache_camera_pose_for_no_camera()
            self.camera_stream_enabled = False
            if None in self.remote_resolution_options:
                self.remote_resolution_index = self.remote_resolution_options.index(None)
            else:
                self.remote_resolution_index = 0
            print(f"{label} Camera feed disabled (No Camera).")
            self._jump_camera_to_no_camera_pose()
            self._apply_stream_settings()
            return

        was_disabled = not self.camera_stream_enabled
        self.camera_stream_enabled = True
        width, height = int(resolution[0]), int(resolution[1])
        self.stream_resolution = (width, height)
        if resolution in self.remote_resolution_options:
            self.remote_resolution_index = self.remote_resolution_options.index(resolution)
        else:
            self.remote_resolution_index = 0
        if was_disabled:
            self._restore_camera_pose_after_no_camera()
        print(f"{label} Stream resolution set to {width}x{height}")
        self._apply_stream_settings()

    def _set_stream_fps(self, fps: int):
        fps = int(fps)
        if fps < self.remote_fps_min:
            fps = self.remote_fps_min
        elif fps > self.remote_fps_max:
            fps = self.remote_fps_max
        if fps == self.stream_fps:
            return
        self.stream_fps = fps
        print(f"[Remote] Stream FPS set to {self.stream_fps}")
        self._apply_stream_settings()

    def _cycle_remote_resolution(self):
        if not self.remote_resolution_options:
            return
        self.remote_resolution_index = (self.remote_resolution_index + 1) % len(
            self.remote_resolution_options
        )
        self._set_stream_resolution(self.remote_resolution_options[self.remote_resolution_index])

    def _advance_stream_fps(self):
        next_fps = self.stream_fps + 1
        if next_fps > self.remote_fps_max:
            next_fps = self.remote_fps_min
        self._set_stream_fps(next_fps)

    def _capture_world_settings_signature(self, settings) -> Optional[Tuple[bool, bool, Optional[float], bool]]:
        """Return a tuple describing settings that matter to the editor for change detection."""
        if not settings:
            return None
        return (
            getattr(settings, "synchronous_mode", False),
            getattr(settings, "synchronous_mode_wait_for_vehicle_control_command", False),
            getattr(settings, "fixed_delta_seconds", None),
            getattr(settings, "no_rendering_mode", False),
        )

    def _apply_rendering_mode(
        self,
        desired_enabled: Optional[bool] = None,
        *,
        reason: Optional[str] = None,
        force: bool = False,
        world=None,
    ) -> bool:
        """
        Apply the preferred rendering mode to the active CARLA world.

        Args:
            desired_enabled: When provided, the user preference to enforce (True enables scene rendering).
            reason: Optional context string used in log output.
            force: When True, skip current-state short-circuit checks.
            world: Explicit world reference to update (defaults to self.world).

        Returns:
            True when the change was applied or already reflected in the world.
        """
        if desired_enabled is not None:
            self._rendering_desired_enabled = bool(desired_enabled)
        desired_enabled = bool(self._rendering_desired_enabled)

        target_world = world or self.world
        if not target_world:
            return False

        try:
            settings = target_world.get_settings()
        except Exception as exc:
            print(f"[Rendering] Unable to read world settings: {exc}")
            return False

        desired_no_render = not desired_enabled
        current_no_render = getattr(settings, "no_rendering_mode", False)

        if not force and current_no_render == desired_no_render:
            self.rendering_enabled = desired_enabled
            self._world_settings_signature = self._capture_world_settings_signature(settings)
            return True

        settings.no_rendering_mode = desired_no_render
        no_render_active = not desired_enabled
        state_label = "enabled" if no_render_active else "disabled"
        suffix = f" ({reason})" if reason else ""

        try:
            self._rendering_apply_in_progress = True
            target_world.apply_settings(settings)
            print(f"[Rendering] No-rendering mode {state_label}{suffix}.")
        except Exception as exc:
            print(f"[Rendering] Failed to set no-rendering mode to {state_label}: {exc}")
            try:
                refreshed = target_world.get_settings()
                actual_no_render = getattr(refreshed, "no_rendering_mode", False)
                self.rendering_enabled = not actual_no_render
                self._rendering_desired_enabled = self.rendering_enabled
                self._world_settings_signature = self._capture_world_settings_signature(refreshed)
            except Exception:
                pass
            return False
        finally:
            self._rendering_apply_in_progress = False

        self.rendering_enabled = desired_enabled
        self._rendering_desired_enabled = desired_enabled
        self._world_settings_signature = self._capture_world_settings_signature(settings)
        return True

    def _check_world_replacement(self):
        """Poll CARLA client to detect world reloads when tick callbacks are lost."""
        if self._world_reset_in_progress:
            return
        if not self.client:
            return
        try:
            current_world = self.client.get_world()
        except Exception:
            return

        if current_world is None:
            return

        try:
            snapshot = current_world.get_snapshot()
            episode = getattr(snapshot.timestamp, "episode", None)
            frame = snapshot.frame
        except Exception:
            snapshot = None
            episode = None
            frame = None

        try:
            settings = current_world.get_settings()
            signature = self._capture_world_settings_signature(settings)
        except Exception:
            settings = None
            signature = None

        if signature != self._world_settings_signature:
            self._world_settings_signature = signature
            self._handle_world_settings_change(settings)

        trigger_reset = False

        with self._world_reset_lock:
            if self.world and current_world is not self.world:
                self._world_reset_candidate_world = current_world
            elif self._world_reset_candidate_world is None and self.world is None:
                self._world_reset_candidate_world = current_world

            if episode is not None:
                if self._world_last_episode is None:
                    self._world_last_episode = episode
                    self._world_last_frame = frame
                else:
                    if episode != self._world_last_episode:
                        trigger_reset = True
                    elif (
                        frame is not None
                        and self._world_last_frame is not None
                        and frame < self._world_last_frame
                    ):
                        trigger_reset = True

                    self._world_last_episode = episode
                    self._world_last_frame = frame

        if trigger_reset and not self._world_reset_in_progress:
            with self._world_reset_lock:
                if not self._world_reset_pending:
                    self._world_reset_pending = True
                    self._world_reset_detected_at = time.time()
                    if self._world_reset_candidate_world is None:
                        self._world_reset_candidate_world = current_world

    def _register_world_tick_handler(self):
        """Subscribe to CARLA world ticks so we can detect world resets."""
        if not self.world:
            return
        self._unregister_world_tick_handler()
        self._world_tick_times.clear()
        self._world_tick_fps = 0.0
        try:
            snapshot = self.world.get_snapshot()
            self._world_last_episode = getattr(snapshot.timestamp, "episode", None)
            self._world_last_frame = snapshot.frame
        except Exception:
            self._world_last_episode = None
            self._world_last_frame = None
        try:
            self._world_tick_subscription = self.world.on_tick(self._on_world_tick)
        except Exception as exc:
            print(f"[World Reset] Failed to register on_tick handler: {exc}")
            self._world_tick_subscription = None

    def _handle_world_settings_change(self, settings):
        """React to runtime changes in CARLA world settings (e.g., synchronous mode)."""
        if not settings:
            return

        actual_rendering = not getattr(settings, "no_rendering_mode", False)
        if actual_rendering != self.rendering_enabled:
            self.rendering_enabled = actual_rendering
        if (
            not self._rendering_apply_in_progress
            and actual_rendering != self._rendering_desired_enabled
            and self.world
        ):
            preferred = self._rendering_desired_enabled
            mode_state = "enabled" if not preferred else "disabled"
            print(f"[Rendering] Detected external change; reapplying no-rendering mode {mode_state}.")
            self._apply_rendering_mode(
                desired_enabled=preferred,
                reason="restoring preference after external change",
                force=True,
                world=self.world,
            )

        synchronous = getattr(settings, "synchronous_mode", False)
        wait_for_control = getattr(settings, "synchronous_mode_wait_for_vehicle_control_command", False)
        fixed_delta = getattr(settings, "fixed_delta_seconds", None) or 0.05
        if synchronous:
            self.manual_tick_required = True
            self.manual_tick_interval = max(fixed_delta, 0.001)
            self.manual_tick_recommendation = not self.manual_tick_enabled
            self._manual_tick_last_required_time = time.time()
            print(
                "[World Settings] Server entered synchronous mode"
                f"{' (waiting for external control commands)' if wait_for_control else ''}."
            )
            self._map_refresh_disabled = True
            if self.camera_processor:
                self.camera_processor.restart_camera_sensor()

            # On large maps, save ego data from scenario for applying to external ego later
            # Note: The ROS bridge reloads the map, destroying VSE's ego actor - so we save from scenario data
            is_large_map = getattr(self, 'large_map_active', False)
            should_bootstrap = (
                is_large_map
                and self.external_ego_actor is None
                and not self.scenario_running  # Don't bootstrap during playback
                and not getattr(self, '_scenario_run_in_progress', False)  # Don't bootstrap during run setup
            )
            if should_bootstrap:
                cp = self.camera_processor
                # Get ego data from the loaded scenario (survives map reload by ROS bridge)
                scenario_ego_data = None
                if cp and hasattr(cp, 'loaded_scenario_data') and cp.loaded_scenario_data:
                    scenario_ego_data = cp.loaded_scenario_data.get('ego_vehicle')

                if scenario_ego_data:
                    self._pending_external_ego_data = scenario_ego_data
                    loc = scenario_ego_data.get('location', {})
                    print(f"[Bootstrap] Large map: saved ego position from scenario ({loc.get('x', 0):.1f}, {loc.get('y', 0):.1f}, {loc.get('z', 0):.1f})")

                    # Move camera to awmini spawn point to ensure spawned ego is visible
                    # On large maps, actors are only loaded near the spectator/camera position
                    if self.camera_processor and hasattr(self.camera_processor, 'camera_sensor'):
                        # Save current camera transform for restoration later
                        current_transform = self.camera_processor.camera_sensor.get_transform()
                        self._bootstrap_original_camera_transform = current_transform

                        # Move to awmini spawn point (0, 0, 36) + some height for better visibility
                        spawn_location = carla.Location(x=0.0, y=0.0, z=50.0)
                        spawn_rotation = carla.Rotation(pitch=-15.0, yaw=0.0, roll=0.0)
                        spawn_transform = carla.Transform(spawn_location, spawn_rotation)
                        self.camera_processor.camera_sensor.set_transform(spawn_transform)
                        print("[Bootstrap] Moved camera to spawn point (0, 0, 50) for external ego detection")
                else:
                    print("[Bootstrap] Large map sync mode - no scenario ego data found")

                # Enable ticking immediately so awmini can spawn ego vehicle
                self._set_large_map_bootstrap_ticking(
                    True,
                    log_message="[Bootstrap] Enabled Drive Clock for large map bootstrap",
                )

            self._detect_external_ego_vehicle()
        else:
            if self.manual_tick_required:
                print("[World Settings] Server returned to asynchronous mode.")
            self.manual_tick_required = False
            self.manual_tick_enabled = False
            self.manual_tick_accumulator = 0.0
            self.manual_tick_recommendation = False
            self._map_refresh_disabled = False
            self._external_ego_present_last_check = False
            self._manual_tick_last_required_time = 0.0

    def _switch_world_to_async_if_safe(self, reason: Optional[str] = None, *, force: bool = False) -> bool:
        """Return the CARLA world to asynchronous mode when we can (or when forced)."""
        # Skip on large maps - apply_settings() crashes server when ROS bridge is connected
        is_large_map = getattr(self, 'large_map_active', False)
        if is_large_map and not force:
            if not getattr(self, '_large_map_async_skip_warned', False):
                print("[World Settings] Skipping async switch on large map - external bridge controls simulation")
                self._large_map_async_skip_warned = True
            return False
        if is_large_map and force:
            # Still avoid apply_settings() while an external bridge/ego is present. This mirrors the
            # normal-map behavior ("restore local ego then return to async") but only after the
            # external ego has been removed and VSE is the sole simulation controller again.
            external_present = (
                getattr(self, "external_ego_actor", None) is not None
                or getattr(self, "external_ego_actor_id", None) is not None
                or getattr(self, "_external_swap_active", False)
            )
            if external_present or getattr(self, "_large_map_bootstrap_ticking", False):
                if not getattr(self, '_large_map_async_skip_warned', False):
                    print("[World Settings] Skipping async switch on large map - external bridge controls simulation")
                    self._large_map_async_skip_warned = True
                return False

        profile = getattr(self, "connection_profile", None)
        if profile is not None and not profile.manage_server and not force:
            return False

        world = self._get_current_world()
        if not world:
            return False

        try:
            settings = world.get_settings()
        except Exception as exc:
            print(f"[World Settings] Unable to read current settings for async switch: {exc}")
            return False

        synchronous = getattr(settings, "synchronous_mode", False)
        wait_for_control = getattr(settings, "synchronous_mode_wait_for_vehicle_control_command", False)
        if not synchronous and not wait_for_control:
            return False

        settings.synchronous_mode = False
        settings.synchronous_mode_wait_for_vehicle_control_command = False
        try:
            settings.fixed_delta_seconds = 0.0
        except Exception:
            pass

        try:
            try:
                world.apply_settings(settings, timeout=5.0)  # type: ignore[call-arg]
            except TypeError:
                try:
                    world.apply_settings(settings, 5.0)  # type: ignore[misc]
                except TypeError:
                    world.apply_settings(settings)
        except Exception as exc:
            print(f"[World Settings] Failed to switch to asynchronous mode: {exc}")
            return False

        message = "[World Settings] Switched to asynchronous mode"
        if reason:
            message += f" ({reason})."
        else:
            message += "."
        print(message)

        # If we had adopted an external ego and the bridge/frames stopped, treat this
        # as a disconnect signal and attempt to restore the local ego immediately.
        if self._external_swap_active or self.external_ego_actor_id is not None:
            try:
                self._handle_external_ego_disconnect()
            except Exception as exc:
                print(f"[External Ego] Restore on async switch failed: {exc}")

        self._handle_world_settings_change(settings)
        self._world_settings_signature = self._capture_world_settings_signature(settings)
        if self.camera_processor:
            self.camera_processor.restart_camera_sensor()
        return True

    def _set_large_map_bootstrap_ticking(
        self,
        enabled: bool,
        *,
        log_message: Optional[str] = None,
        disable_manual_tick: bool = False,
        clear_pending_external_ego: bool = False,
    ) -> None:
        """Toggle large-map bootstrap ticking without altering existing behavior."""
        if enabled:
            self._large_map_bootstrap_ticking = True
            self._bootstrap_tick_warned = False
            self.manual_tick_enabled = True
            self.manual_tick_accumulator = 0.0
        else:
            self._large_map_bootstrap_ticking = False
            if disable_manual_tick:
                self.manual_tick_enabled = False
            if clear_pending_external_ego:
                self._pending_external_ego_data = None

        if log_message:
            print(log_message)

    def _external_ego_can_prompt(self) -> bool:
        """Return True if it is safe to automatically adopt an external ego."""
        if self.scenario_running:
            return False
        cp = self.camera_processor
        if cp and (getattr(cp, "manual_control_enabled", False) or getattr(cp, "manual_control_pending", False)):
            return False
        return True

    def _transfer_ego_metadata(self, old_id: Optional[int], new_id: Optional[int], cp: Optional["CameraImageProcessor"]) -> None:
        """Move ego metadata (waypoints/speeds/flags/color) from one actor id to another."""
        if not cp or old_id is None or new_id is None or old_id == new_id:
            return

        waypoints = cp.get_vehicle_waypoints(old_id)
        if waypoints:
            try:
                cp.set_vehicle_waypoints(new_id, clone_waypoint_sequence(waypoints))
            except Exception:
                try:
                    cp.set_vehicle_waypoints(new_id, [dict(wp) for wp in waypoints])
                except Exception:
                    pass

        speed_val = cp.get_vehicle_speed(old_id, None)
        if speed_val is not None:
            cp.set_vehicle_speed(new_id, speed_val)

        dest_speed = cp.get_vehicle_destination_speed(old_id)
        if dest_speed is not None:
            cp.set_vehicle_destination_speed(new_id, dest_speed)

        ignore_flags = cp.get_vehicle_ignore_flags(old_id)
        if ignore_flags is not None:
            cp.set_vehicle_ignore_flags(new_id, ignore_flags)

        max_lat_acc = cp.get_vehicle_max_lat_acc(old_id, None)
        if max_lat_acc is not None:
            cp.set_vehicle_max_lat_acc(new_id, max_lat_acc)

        color_val = cp.get_vehicle_color(old_id)
        if color_val is not None:
            cp.set_vehicle_color(new_id, color_val)

        cp.clear_vehicle_metadata(old_id, clear_waypoints=True)

    def _show_external_swap_overlay(self, message: Optional[str] = None) -> None:
        """Enable a non-blocking on-screen overlay during external ego adoption."""
        now = time.time()
        self._external_swap_overlay = True
        self._external_swap_overlay_message = message or "Adopting external ego..."
        self._external_swap_overlay_started_at = now
        self._external_swap_overlay_keep_until = now + 1.0  # keep visible briefly even if swap completes fast

    def _clear_external_swap_overlay(self) -> None:
        """Hide the external ego adoption overlay."""
        now = time.time()
        if self._external_swap_overlay and now < self._external_swap_overlay_keep_until:
            return
        self._external_swap_overlay = False
        self._external_swap_overlay_message = None
        self._external_swap_overlay_started_at = 0.0
        self._external_swap_overlay_keep_until = 0.0

    def _show_error_overlay(self, message: str, duration: float = 4.0) -> None:
        """Show a temporary error overlay message in editor mode."""
        now = time.time()
        self._error_overlay_active = True
        self._error_overlay_message = message
        self._error_overlay_until = now + duration

    def _render_error_overlay(self) -> None:
        """Render the error overlay if active."""
        if not getattr(self, "_error_overlay_active", False):
            return
        if time.time() > self._error_overlay_until:
            self._error_overlay_active = False
            return
        # Dark semi-transparent overlay
        overlay = pygame.Surface((self.screen_width, self.screen_height), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        # Error message in red
        msg = self._error_overlay_message
        text = self.font.render(msg, True, self.colors['error'])
        rect = text.get_rect(center=(self.screen_width // 2, self.screen_height // 2))
        self.screen.blit(text, rect)

    def _perform_external_ego_swap(self, actor: Optional[carla.Actor]) -> bool:
        """Replace the editor ego with the provided external actor."""
        cp = self.camera_processor
        if not cp or not actor or not actor.is_alive:
            return False
        self._show_external_swap_overlay("Adopting external ego...")
        try:
            self._render_external_swap_overlay_immediate()
            try:
                print(f"[External Ego] Performing swap to actor {actor.id} ({actor.type_id})")
            except Exception:
                pass

            previous_ego_id = getattr(cp, "ego_vehicle_id", None)
            try:
                actor_transform_pre_swap = actor.get_transform()
            except Exception:
                actor_transform_pre_swap = None

            def _origin_like_transform(transform: Optional[carla.Transform]) -> bool:
                if not transform:
                    return True
                try:
                    loc = transform.location
                    if not (math.isfinite(loc.x) and math.isfinite(loc.y) and math.isfinite(loc.z)):
                        return True
                    return (abs(loc.x) + abs(loc.y) + abs(loc.z)) < 0.5
                except Exception:
                    return True

            origin_transform = getattr(cp, "ego_vehicle_transform", None)
            if origin_transform and _origin_like_transform(origin_transform):
                origin_transform = None
            if origin_transform is None:
                try:
                    json_spawn = self._get_ego_spawn_from_json()
                except Exception:
                    json_spawn = None
                if json_spawn and json_spawn.get("transform") is not None:
                    candidate_transform = json_spawn["transform"]
                    if not _origin_like_transform(candidate_transform):
                        origin_transform = candidate_transform
            focus_location = None
            if origin_transform:
                # Snap to ground for stability when adopting external ego
                try:
                    ground_z = cp.get_ground_height_at_location(
                        origin_transform.location.x,
                        origin_transform.location.y,
                        origin_transform.location.z,
                    )
                    origin_transform.location.z = ground_z + 0.2
                except Exception:
                    pass
                try:
                    actor.set_transform(origin_transform)
                    actor.set_target_velocity(carla.Vector3D())
                    actor.set_target_angular_velocity(carla.Vector3D())
                except Exception:
                    pass
                try:
                    actor.set_simulate_physics(True)
                except Exception:
                    pass
                try:
                    focus_location = carla.Location(
                        x=float(origin_transform.location.x),
                        y=float(origin_transform.location.y),
                        z=float(origin_transform.location.z),
                    )
                except Exception:
                    focus_location = origin_transform.location
                self._schedule_camera_focus(
                    focus_location,
                    keep_s=2.5,
                    reason="external ego swap",
                )
            elif actor_transform_pre_swap:
                try:
                    focus_location = carla.Location(
                        x=float(actor_transform_pre_swap.location.x),
                        y=float(actor_transform_pre_swap.location.y),
                        z=float(actor_transform_pre_swap.location.z),
                    )
                except Exception:
                    focus_location = actor_transform_pre_swap.location
                self._schedule_camera_focus(
                    focus_location,
                    keep_s=2.5,
                    reason="external ego swap",
                )

            if actor not in cp.spawned_vehicles:
                cp.spawned_vehicles.append(actor)

            # Destroy any existing editor ego vehicle to avoid duplicates
            try:
                existing_ego_id = getattr(cp, "ego_vehicle_id", None)
                to_destroy = []
                for other in list(cp.spawned_vehicles):
                    oid = getattr(other, "id", None)
                    if oid is None:
                        continue
                    try:
                        role_name = other.attributes.get("role_name", "")
                    except Exception:
                        role_name = ""
                    if oid == existing_ego_id or role_name in ("ego_vehicle", "hero"):
                        if other.id != actor.id:
                            to_destroy.append(other)
                for other in to_destroy:
                    try:
                        other.destroy()
                    except Exception:
                        pass
                    try:
                        cp.spawned_vehicles.remove(other)
                    except Exception:
                        pass
            except Exception:
                pass

            try:
                self._external_swap_last_transform = actor.get_transform()
            except Exception:
                self._external_swap_last_transform = origin_transform or actor_transform_pre_swap
            try:
                self._external_swap_last_blueprint = actor.type_id
            except Exception:
                self._external_swap_last_blueprint = None
            try:
                self._external_swap_last_color = actor.attributes.get('color')
            except Exception:
                self._external_swap_last_color = None
            if self._external_swap_last_color is None and previous_ego_id is not None:
                try:
                    self._external_swap_last_color = cp.get_vehicle_color(previous_ego_id)
                except Exception:
                    pass

            try:
                cp.register_ego_vehicle(actor, self._external_swap_last_transform or actor.get_transform(), self._external_swap_last_color)
            except Exception:
                return False

            self._transfer_ego_metadata(previous_ego_id, actor.id, cp)
            # If no previous ego existed (skip_ego_spawn) or waypoints are missing, copy from loaded scenario data
            try:
                waypoints = cp.get_vehicle_waypoints(actor.id)
            except Exception:
                waypoints = None
            if (not waypoints) and self.loaded_scenario_data:
                ego_data = self.loaded_scenario_data.get("ego_vehicle")
                if ego_data:
                    self._apply_ego_data_to_actor(ego_data, actor)

            cp.waypoint_display_vehicle_id = actor.id
            cp.selected_vehicle = actor
            cp.selected_vehicle_is_pedestrian = False
            try:
                cp.refresh_waypoints_carla_debug()
            except Exception:
                pass
            try:
                cp.refresh_selected_vehicle_ui()
            except Exception:
                pass

            self._external_swap_active = True
            self._external_swap_current_id = actor.id
            self._external_ego_prompt_pending_id = None
            self.external_ego_actor = actor
            self.external_ego_actor_id = actor.id
            if getattr(self, "large_map_active", False):
                now = time.time()
                self._large_map_external_ego_connected_at = now
                self._large_map_external_ego_handoff_until = now + 12.0
                self._large_map_external_ego_had_frames = False
                self._large_map_external_stall_warned = False

            # Perform a full scenario reload preserving the external ego; JSON ego spawn will fail/skip while external is present
            if self.current_scenario_path:
                try:
                    # Preserve the external actor via cleanup_all_vehicles and let the normal load path rebuild NPCs/triggers
                    cp.cleanup_all_vehicles(preserve_ids={actor.id})
                    cp.load_waypoint_data_from_file(
                        self.current_scenario_path,
                        preserve_camera=True,
                        skip_ego_spawn=False,
                        apply_to_actor_only=False,
                        external_ego_actor=actor,
                        preserved_actor_id=actor.id,
                    )
                    print(f"[External Ego] Reloaded scenario '{self.current_scenario_path}' preserving external ego.")
                except Exception as exc:
                    print(f"[External Ego] Full reload after swap failed: {exc}")

            # Ensure the external actor is registered as ego for coloring/selection
            try:
                tf = actor.get_transform()
                cp.register_ego_vehicle(actor, tf, self._external_swap_last_color, preserve_waypoints=True)
                cp.waypoint_display_vehicle_id = actor.id
                cp.selected_vehicle = actor
                cp.selected_vehicle_is_pedestrian = False
                try:
                    cp.refresh_waypoints_carla_debug()
                except Exception:
                    pass
                try:
                    cp.refresh_selected_vehicle_ui()
                except Exception:
                    pass
                print(f"[External Ego] Registered actor {actor.id} as ego after swap.")
            except Exception as exc:
                print(f"[External Ego] Failed to register external ego for coloring: {exc}")
            if focus_location is not None:
                self._schedule_camera_focus(
                    focus_location,
                    keep_s=2.5,
                    reason="external ego swap (post-reload)",
                )

            if previous_ego_id and previous_ego_id != actor.id:
                for other in list(cp.spawned_vehicles):
                    actor_id = getattr(other, "id", None)
                    if actor_id == previous_ego_id:
                        try:
                            other.destroy()
                        except Exception:
                            pass
                        try:
                            cp.spawned_vehicles.remove(other)
                        except ValueError:
                            pass
                        break

            # Enable rendering for external ego (normal maps only, not large maps)
            if not getattr(self, 'large_map_active', False):
                try:
                    self._apply_rendering_mode(
                        desired_enabled=True,
                        reason="external ego connected",
                        force=False
                    )
                except Exception as exc:
                    print(f"[External Ego] Warning: failed to enable rendering: {exc}")

            return True
        finally:
            self._clear_external_swap_overlay()

    def _update_external_swap_state(self, actor: Optional[carla.Actor]) -> None:
        """Refresh cached state from the external ego while it is active."""
        if not (self._external_swap_active and actor and actor.is_alive):
            return
        try:
            self._external_swap_last_transform = actor.get_transform()
        except Exception:
            pass
        if self._external_swap_last_blueprint is None:
            try:
                self._external_swap_last_blueprint = actor.type_id
            except Exception:
                pass
        if self._external_swap_last_color is None:
            try:
                self._external_swap_last_color = actor.attributes.get('color')
            except Exception:
                pass

    def _spawn_editor_ego_from_external_state(self, source_id: Optional[int]) -> bool:
        """Recreate a local ego using the last known external ego state."""
        cp = self.camera_processor
        if not cp or not cp.world:
            return False

        def _valid_location(loc: Optional[carla.Location]) -> bool:
            if loc is None:
                return False
            try:
                if not (math.isfinite(loc.x) and math.isfinite(loc.y) and math.isfinite(loc.z)):
                    return False
                return True
            except Exception:
                return False

        def _origin_like(loc: Optional[carla.Location]) -> bool:
            if loc is None:
                return True
            try:
                return (abs(loc.x) + abs(loc.y) + abs(loc.z)) < 0.5
            except Exception:
                return True

        json_spawn = self._get_ego_spawn_from_json()
        json_transform = json_spawn.get("transform") if json_spawn else None
        candidates = [
            self._external_swap_last_transform,
            getattr(cp, "ego_vehicle_transform", None),
            json_transform,
        ]

        transform = None
        for candidate in candidates:
            if not candidate:
                continue
            loc = candidate.location
            if not _valid_location(loc):
                continue
            if _origin_like(loc) and json_transform and candidate is not json_transform:
                continue
            transform = candidate
            break

        if transform is None:
            for candidate in candidates:
                if candidate and _valid_location(candidate.location):
                    transform = candidate
                    break

        if transform is None:
            return False

        blueprint_id = (
            self._external_swap_last_blueprint
            or getattr(cp, "ego_vehicle_blueprint", None)
            or (json_spawn.get("blueprint") if json_spawn else None)
            or "vehicle.lexus.utlexus"
        )
        blueprint_lib = cp.world.get_blueprint_library()
        try:
            vehicle_bp = blueprint_lib.find(blueprint_id)
        except Exception:
            try:
                vehicle_bp = blueprint_lib.find("vehicle.lexus.utlexus")
            except Exception:
                return False

        color_value = (
            self._external_swap_last_color
            or (json_spawn.get("color") if json_spawn else None)
        )

        try:
            if vehicle_bp.has_attribute("role_name"):
                vehicle_bp.set_attribute("role_name", "ego_vehicle")
            if color_value and vehicle_bp.has_attribute("color"):
                vehicle_bp.set_attribute("color", color_value)
        except Exception:
            pass

        try:
            ground_z = cp.get_ground_height_at_location(
                transform.location.x,
                transform.location.y,
                transform.location.z,
            )
            transform.location.z = ground_z + 0.2
        except Exception:
            pass

        actor = cp.world.try_spawn_actor(vehicle_bp, transform)
        if not actor:
            print("Failed to respawn local ego after external disconnect.")
            return False

        try:
            actor.set_simulate_physics(False)
        except Exception:
            pass
        cp.spawned_vehicles.append(actor)

        speed_val = cp.get_vehicle_speed(source_id, 40.0) if source_id is not None else 40.0
        dest_speed = cp.get_vehicle_destination_speed(source_id) if source_id is not None else None
        ignore_flags = cp.get_vehicle_ignore_flags(source_id) if source_id is not None else {}
        max_lat_acc = cp.get_vehicle_max_lat_acc(source_id, 3.0) if source_id is not None else 3.0

        cp.initialize_vehicle_metadata(
            actor.id,
            speed=speed_val if speed_val is not None else 40.0,
            destination_speed=dest_speed,
            idle_time=0.0,
            turn_time=0.0,
            color=color_value,
            ignore_flags=ignore_flags or {},
            max_lat_acc=max_lat_acc if max_lat_acc is not None else 3.0,
        )
        cp.register_ego_vehicle(actor, transform, color_value)
        self._transfer_ego_metadata(source_id, actor.id, cp)
        cp.waypoint_display_vehicle_id = actor.id
        cp.selected_vehicle = actor
        cp.selected_vehicle_is_pedestrian = False
        try:
            cp.refresh_selected_vehicle_ui()
        except Exception:
            pass

        self._external_swap_active = False
        self._external_swap_current_id = None
        self.external_ego_actor = None
        self.external_ego_actor_id = None
        self._external_ego_prompt_pending_id = None
        return True

    def _clear_external_ego_tracking(self) -> None:
        """Clear external ego references and swap state (preserves cached pose/blueprint/color)."""
        self._external_swap_active = False
        self._external_swap_current_id = None
        self.external_ego_actor = None
        self.external_ego_actor_id = None
        self._external_ego_prompt_pending_id = None
        self._external_ego_present_last_check = False

    def _destroy_actor_id_fast(self, actor_id: int) -> bool:
        """Best-effort destroy for an actor id without risking long RPC stalls."""
        if actor_id is None:
            return False
        try:
            actor_id_int = int(actor_id)
        except Exception:
            return False
        if actor_id_int <= 0:
            return False

        cp = getattr(self, "camera_processor", None)
        if cp is not None and hasattr(cp, "_get_fast_world"):
            try:
                world_fast = cp._get_fast_world()
                client_fast = getattr(cp, "_fast_rpc_client", None)
                if world_fast is not None and client_fast is not None:
                    client_fast.apply_batch_sync([carla.command.DestroyActor(actor_id_int)], False)
                    return True
            except Exception:
                pass

        world = None
        try:
            world = self._get_current_world()
        except Exception:
            world = None
        if world:
            try:
                actor = world.get_actor(actor_id_int)
            except Exception:
                actor = None
            if actor:
                try:
                    actor.destroy()
                    return True
                except Exception:
                    return False
        return False

    def _restore_local_ego_from_external_state(self, source_id: Optional[int]) -> bool:
        """Spawn a local ego from cached external state and clear external tracking even on failure."""
        restored = False
        try:
            restored = self._spawn_editor_ego_from_external_state(source_id)
        except Exception:
            restored = False
        if not restored:
            self._clear_external_ego_tracking()
        return restored

    def _get_ego_spawn_from_json(self) -> Optional[dict]:
        """Return {'transform', 'blueprint', 'color'} for ego from current scenario JSON, if available."""
        path = getattr(self, "current_scenario_path", None)
        if not path or not os.path.isfile(path):
            return None
        try:
            with open(path, "r", encoding="utf-8") as fh:
                data = json.load(fh)
        except Exception:
            return None

        entry = data.get("ego_vehicle")
        if not entry:
            for veh in data.get("vehicles", []):
                if str(veh.get("role", "")).lower() == "ego_vehicle":
                    entry = veh
                    break
        if not entry:
            return None

        loc = entry.get("location", {})
        rot = entry.get("rotation", {})
        try:
            transform = carla.Transform(
                carla.Location(
                    x=float(loc.get("x", 0.0)),
                    y=float(loc.get("y", 0.0)),
                    z=float(loc.get("z", 0.0)),
                ),
                carla.Rotation(
                    pitch=float(rot.get("pitch", 0.0)),
                    yaw=float(rot.get("yaw", 0.0)),
                    roll=float(rot.get("roll", 0.0)),
                ),
            )
        except Exception:
            return None

        return {
            "transform": transform,
            "blueprint": entry.get("type"),
            "color": entry.get("color"),
        }

    def _handle_external_ego_disconnect(self) -> None:
        """Handle cleanup and restoration when an external ego disappears after a swap."""
        try:
            print("[External Ego] Detected external ego disconnect; attempting local restore.")
        except Exception:
            pass
        # Disable rendering when external ego disconnects (normal maps only)
        if not getattr(self, 'large_map_active', False):
            try:
                self._apply_rendering_mode(
                    desired_enabled=False,
                    reason="external ego disconnected",
                    force=False
                )
            except Exception as exc:
                print(f"[External Ego] Warning: failed to disable rendering: {exc}")
        if not self._external_swap_active:
            # Even if swap flag was cleared, try to restore from cached state when available.
            if (
                self.external_ego_actor_id is not None
                or self._external_swap_last_transform is not None
                or self._external_swap_last_blueprint is not None
            ):
                restored = self._spawn_editor_ego_from_external_state(self.external_ego_actor_id)
                if restored:
                    print("External ego disconnected; local ego restored with preserved state.")
                else:
                    print("External ego disconnected; no cached state or JSON spawn available, skipping restore.")
            self.external_ego_actor = None
            self.external_ego_actor_id = None
            self._external_ego_prompt_pending_id = None
            return

        previous_id = self._external_swap_current_id
        restored = self._spawn_editor_ego_from_external_state(previous_id)
        if restored:
            print("External ego disconnected; local ego restored with preserved state.")
        else:
            print("External ego disconnected; restore failed (no cached state/JSON).")
        self._external_swap_active = False
        self._external_swap_current_id = None
        self.external_ego_actor = None
        self.external_ego_actor_id = None
        self._external_ego_prompt_pending_id = None
        self._external_ego_present_last_check = False

    def _maybe_prompt_external_ego_swap(self, actor: Optional[carla.Actor]) -> None:
        """Auto-adopt the external ego when conditions allow."""
        if getattr(self, "_suppress_external_ego_adoption", False):
            self._external_ego_prompt_pending_id = None
            return
        if not actor or not actor.is_alive:
            return
        if self._external_swap_active and self._external_swap_current_id == actor.id:
            return
        if not self._external_ego_can_prompt():
            self._external_ego_prompt_pending_id = actor.id
            return

        self._external_ego_prompt_pending_id = None
        try:
            print(f"[External Ego] Auto-adopting external ego actor {actor.id}")
        except Exception:
            pass
        self._perform_external_ego_swap(actor)

    def _monitor_external_ego_status(self):
        """Detect when an external ego actor disappears and revert to async mode."""
        if not self.ready:
            return
        if self.scenario_running:
            return

        previously_present = self._external_ego_present_last_check or (self.external_ego_actor_id is not None)
        actor = self._refresh_external_ego_actor_reference()
        currently_present = actor is not None
        now = time.time()
        perform_scan = (
            not currently_present
            and not self.scenario_running
            and self.manual_tick_required
            and (now - self._last_external_ego_scan_time) >= 1.0
        )

        # Debug: log scan conditions during bootstrap
        if getattr(self, '_large_map_bootstrap_ticking', False) and not getattr(self, '_bootstrap_scan_debug_done', False):
            print(f"[Bootstrap DEBUG] Scan conditions: currently_present={currently_present}, scenario_running={self.scenario_running}, "
                  f"manual_tick_required={self.manual_tick_required}, time_since_scan={(now - self._last_external_ego_scan_time):.1f}s")
            if perform_scan:
                print("[Bootstrap DEBUG] Will perform external ego scan")

        if perform_scan:
            self._bootstrap_scan_debug_done = True  # Only log once
            actor = self._resolve_external_ego_actor(silent=True, allow_scan=True)
            currently_present = actor is not None
            if getattr(self, '_large_map_bootstrap_ticking', False):
                print(f"[Bootstrap DEBUG] Scan result: actor={actor.id if actor else None}, currently_present={currently_present}")

        if actor and self._external_ego_prompt_pending_id == actor.id and self._external_ego_can_prompt():
            self._maybe_prompt_external_ego_swap(actor)

        if actor and self._external_swap_active and actor.id == self._external_swap_current_id:
            self._update_external_swap_state(actor)
        if actor:
            self._maybe_prompt_external_ego_swap(actor)

        self._external_ego_present_last_check = currently_present

        # Disable bootstrap ticking when external ego is detected on large map
        if currently_present and getattr(self, '_large_map_bootstrap_ticking', False):
            if getattr(self, "large_map_active", False):
                now = time.time()
                self._large_map_external_ego_connected_at = float(
                    getattr(self, "_large_map_external_ego_connected_at", 0.0) or 0.0
                ) or now
                self._large_map_external_ego_handoff_until = max(
                    float(getattr(self, "_large_map_external_ego_handoff_until", 0.0) or 0.0),
                    now + 12.0,
                )
            self._set_large_map_bootstrap_ticking(
                False,
                log_message="[Manual Tick] External ego detected - stopping large map bootstrap ticks",
                disable_manual_tick=True,
            )

            # Apply saved ego data to the external ego (teleport to scenario position)
            pending_data = getattr(self, '_pending_external_ego_data', None)
            if pending_data and actor:
                try:
                    loc = pending_data.get("location", {})
                    rot = pending_data.get("rotation", {})
                    new_location = carla.Location(
                        x=float(loc.get("x", 0)),
                        y=float(loc.get("y", 0)),
                        z=float(loc.get("z", 0))
                    )
                    new_rotation = carla.Rotation(
                        pitch=float(rot.get("pitch", 0)),
                        yaw=float(rot.get("yaw", 0)),
                        roll=float(rot.get("roll", 0))
                    )
                    new_transform = carla.Transform(new_location, new_rotation)
                    applied = False
                    if getattr(self, "large_map_active", False):
                        cp = getattr(self, "camera_processor", None)
                        if cp is not None and hasattr(cp, "_get_fast_world"):
                            try:
                                client_fast = getattr(cp, "_fast_rpc_client", None)
                                if client_fast is not None:
                                    client_fast.apply_batch_sync(
                                        [carla.command.ApplyTransform(int(actor.id), new_transform)],
                                        False,
                                    )
                                    applied = True
                            except Exception:
                                applied = False
                    if not applied:
                        actor.set_transform(new_transform)
                    print(f"[Bootstrap] Applied saved ego position to external ego: ({new_location.x:.1f}, {new_location.y:.1f}, {new_location.z:.1f})")
                    self._pending_external_ego_data = None

                    # Restore/move camera after teleporting ego
                    if self._bootstrap_original_camera_transform and self.camera_processor and getattr(self.camera_processor, "camera_sensor", None):
                        # Move camera to follow the external ego at its scenario position
                        ego_transform = new_transform
                        camera_location = new_location + carla.Location(z=50.0)
                        camera_rotation = carla.Rotation(
                            pitch=-15.0,
                            yaw=float(new_rotation.yaw),
                            roll=0.0,
                        )
                        camera_transform = carla.Transform(camera_location, camera_rotation)
                        if getattr(self, "large_map_active", False) and hasattr(self.camera_processor, "_queue_large_map_transform"):
                            try:
                                self.camera_processor._queue_large_map_transform(camera_transform)
                            except Exception:
                                self.camera_processor.camera_sensor.set_transform(camera_transform)
                        else:
                            self.camera_processor.camera_sensor.set_transform(camera_transform)
                        print(f"[Bootstrap] Moved camera to follow external ego at ({new_location.x:.1f}, {new_location.y:.1f})")
                        self._bootstrap_original_camera_transform = None
                except Exception as exc:
                    print(f"[Bootstrap] Failed to apply saved ego data: {exc}")

        if currently_present and getattr(self, "large_map_active", False):
            camera = getattr(self, "camera_processor", None)
            if camera is not None and getattr(camera, "last_frame_time", None):
                try:
                    connected_at = float(getattr(self, "_large_map_external_ego_connected_at", 0.0) or 0.0)
                except Exception:
                    connected_at = 0.0
                try:
                    last_frame = float(camera.last_frame_time or 0.0)
                except Exception:
                    last_frame = 0.0
                if connected_at and last_frame and last_frame >= connected_at:
                    self._large_map_external_ego_had_frames = True

        if previously_present and not currently_present:
            self._handle_external_ego_disconnect()
            # On large maps, force reload the map to clear state (avoids timeouts)
            if getattr(self, "large_map_active", False):
                self._force_reload_current_map_for_external_ego()
                return
            # Non-large map: use existing async switch
            async_switched = self._switch_world_to_async_if_safe(
                reason="external ego removed",
                force=True,
            )
            if (
                not async_switched
                and self.manual_tick_required
                and not self.manual_tick_enabled
            ):
                print("[External Ego] Enabling manual tick to keep sensors alive after external removal.")
                self.manual_tick_enabled = True
                self.manual_tick_accumulator = 0.0
            return

        camera = getattr(self, "camera_processor", None)
        last_required = getattr(self, "_manual_tick_last_required_time", 0.0)
        if (
            self.manual_tick_required
            and not self.manual_tick_enabled
            and camera is not None
            and getattr(camera, "last_frame_time", None)
            and last_required
        ):
            frame_age = now - camera.last_frame_time
            sync_age = now - last_required
            if frame_age >= 4.0 and sync_age >= 1.0:
                switched = self._switch_world_to_async_if_safe(
                    reason="no frames received in synchronous mode",
                    force=True,
                )
                if not switched:
                    is_large_map = getattr(self, 'large_map_active', False)
                    if not is_large_map:
                        print("[Manual Tick] Enabling Drive Clock to recover frames (no external ticks).")
                        self.manual_tick_enabled = True
                        self.manual_tick_accumulator = 0.0
                    else:
                        # Large map: enable bootstrap ticking if no external ego yet
                        if self.external_ego_actor is None and not self._large_map_bootstrap_ticking:
                            self._set_large_map_bootstrap_ticking(
                                True,
                                log_message="[Manual Tick] Large map bootstrap: enabling temporary ticks until external ego connects",
                            )
                        elif self.external_ego_actor is not None:
                            # External ego exists - disable bootstrap ticking, let bridge control.
                            if self._large_map_bootstrap_ticking:
                                self._set_large_map_bootstrap_ticking(
                                    False,
                                    log_message="[Manual Tick] External ego connected on large map - disabling bootstrap ticks",
                                    disable_manual_tick=True,
                                )
                                return

                            # If the external bridge was ticking before (we had frames) but now frames stopped,
                            # treat this as a bridge stall/exit - force map reload to clear state
                            if bool(getattr(self, "_large_map_external_ego_had_frames", False)):
                                if not getattr(self, "_large_map_external_stall_warned", False):
                                    print(
                                        "[Manual Tick] Large map external ego stalled (no frames); "
                                        "reloading map to clear state."
                                    )
                                    self._large_map_external_stall_warned = True
                                    self._force_reload_current_map_for_external_ego()
                                return

                            if not getattr(self, '_large_map_tick_skip_warned', False):
                                print("[Manual Tick] On large map with external ego - bridge controls simulation")
                                self._large_map_tick_skip_warned = True
                            return

    def _unregister_world_tick_handler(self):
        """Remove any active world tick subscription."""
        if self._world_tick_subscription is None:
            return
        try:
            if self.world:
                self.world.remove_on_tick(self._world_tick_subscription)
        except Exception:
            pass
        finally:
            self._world_tick_subscription = None

    def _on_world_tick(self, snapshot):
        """Handle CARLA world tick callbacks (executed from CARLA thread)."""
        now = time.time()
        try:
            self._world_tick_times.append(now)
            cutoff = now - self._world_tick_window
            while self._world_tick_times and self._world_tick_times[0] < cutoff:
                self._world_tick_times.popleft()
            if len(self._world_tick_times) >= 2:
                span = self._world_tick_times[-1] - self._world_tick_times[0]
                if span > 0:
                    self._world_tick_fps = (len(self._world_tick_times) - 1) / span
        except Exception:
            pass

        try:
            episode = getattr(snapshot.timestamp, "episode", None)
            frame = snapshot.frame
        except Exception:
            episode = None
            frame = None

        with self._world_reset_lock:
            if self._world_reset_in_progress:
                self._world_last_episode = episode
                self._world_last_frame = frame
                return

            if self._world_last_episode is None:
                self._world_last_episode = episode
                self._world_last_frame = frame
                return

            reset_detected = False
            if episode is not None and self._world_last_episode is not None and episode != self._world_last_episode:
                reset_detected = True
            elif frame is not None and self._world_last_frame is not None and frame < self._world_last_frame:
                reset_detected = True

            if reset_detected and not self._world_reset_pending:
                self._world_reset_pending = True
                self._world_reset_detected_at = time.time()

            self._world_last_episode = episode
            self._world_last_frame = frame

    def _process_world_reset_events(self):
        """Main-thread handler to process pending world reset workflow."""
        if not self.ready and not self._world_reset_in_progress and not self._world_reset_pending:
            return

        self._check_world_replacement()

        if self._world_reset_pending:
            with self._world_reset_lock:
                pending = self._world_reset_pending
                if pending:
                    self._world_reset_pending = False
            if pending:
                self._begin_world_reset_recovery()

        if self._world_reset_finalize_pending:
            self._finalize_world_reset()

    def _begin_world_reset_recovery(self):
        """Start teardown and async wait for the world to recover after a reset."""
        if self._world_reset_in_progress:
            return

        print("[World Reset] Detected CARLA world reload. Reinitializing editor resources...")
        self._world_reset_in_progress = True
        self.ready = False
        self.loading_stage = "World reset detected. Waiting for CARLA..."
        self._world_tick_times.clear()
        self._world_tick_fps = 0.0

        if self.camera_controller:
            self._camera_restore_state = (
                float(getattr(self.camera_controller, 'center_x', 0.0)),
                float(getattr(self.camera_controller, 'center_y', 0.0)),
                float(getattr(self.camera_controller, 'height', 200.0)),
            )
        else:
            self._camera_restore_state = None

        if self.scenario_running:
            print("[World Reset] Stopping active scenario due to world reset...")
            try:
                self.stop_scenario()
            except Exception as exc:
                print(f"[World Reset] Failed to stop scenario cleanly: {exc}")

        self._unregister_world_tick_handler()
        self._teardown_world_resources_for_reset()

        if self._world_reset_wait_thread and self._world_reset_wait_thread.is_alive():
            return

        self._world_reset_wait_thread = threading.Thread(
            target=self._wait_for_world_recovery,
            name="VSEWorldResetWait",
            daemon=True,
        )
        self._world_reset_wait_thread.start()

    def _teardown_world_resources_for_reset(self):
        """Release camera and overlay resources before reconnecting to a fresh world."""
        if self.camera_processor:
            try:
                OpenDriveOverlayRenderer.disable_overlay(self.camera_processor, silent=True)
            except Exception:
                pass
            try:
                self.camera_processor.cleanup()
            except Exception as exc:
                print(f"[World Reset] Warning while cleaning camera processor: {exc}")
            self.camera_processor = None
            if self.vehicle_menu:
                self.vehicle_menu.set_camera_processor(None)
            if self.pedestrian_menu:
                self.pedestrian_menu.set_camera_processor(None)
            if self.ego_vehicle_menu:
                self.ego_vehicle_menu.set_camera_processor(None)

        if self.info_panel is not None:
            try:
                self.info_panel.hide()
            except Exception:
                pass

        self.external_ego_actor = None
        self.external_ego_actor_id = None
        self._external_swap_active = False
        self._external_swap_current_id = None
        self._external_swap_last_transform = None
        self._external_swap_last_blueprint = None
        self._external_swap_last_color = None
        self._external_ego_prompt_pending_id = None

    def _wait_for_world_recovery(self):
        """Background thread: wait until CARLA world becomes available again."""
        attempts = 0
        recovered_world = None
        candidate = self._world_reset_candidate_world

        while True:
            if candidate is None and not self.client:
                time.sleep(0.2)
                continue
            try:
                world = candidate or self.client.get_world()
                candidate_snapshot = world.get_snapshot()
                if candidate_snapshot:
                    recovered_world = world
                    break
                candidate = None
            except Exception:
                pass

            attempts += 1
            if attempts % 25 == 0:
                print("[World Reset] Waiting for CARLA world to become available...")
            time.sleep(0.2)

        self._world_reset_ready_world = recovered_world
        self._world_reset_finalize_pending = True

    def _finalize_world_reset(self):
        """Finish rebuilding editor state after the world has recovered."""
        if not self._world_reset_ready_world:
            # Should not happen; nothing to finalize.
            self._world_reset_finalize_pending = False
            self._world_reset_in_progress = False
            return

        new_world = self._world_reset_ready_world
        self._world_reset_ready_world = None
        self._world_reset_finalize_pending = False
        self._world_reset_candidate_world = None

        try:
            self.world = new_world
            new_map = None
            try:
                new_map = new_world.get_map()
            except Exception as exc:
                if self.world_map is not None:
                    print(f"[World Reset] Warning: failed to obtain new world map ({exc}). Reusing cached map.")
                else:
                    raise

            if new_map is not None:
                self.world_map = new_map
                self.cached_map = new_map

            map_name = self.world_map.name if self.world_map else "<unknown>"
            print(f"[World Reset] Connected to CARLA world: {map_name}")
        except Exception as exc:
            print(f"[World Reset] Warning: failed to obtain world map: {exc}")
            if self.world_map is None and self.cached_map is None:
                print("[World Reset] No cached map available; lane snapping may be unavailable.")

        # Reapply preferred rendering mode after reconnecting to a fresh world.
        self._apply_rendering_mode(
            desired_enabled=self._rendering_desired_enabled,
            reason="world reset recovery",
            force=True,
            world=new_world,
        )

        restored_camera_state = getattr(self, "_camera_restore_state", None)
        if self.camera_controller:
            self.camera_controller.world = new_world
            if restored_camera_state:
                cx, cy, height = restored_camera_state
                self.camera_controller.center_x = cx
                self.camera_controller.center_y = cy
                self.camera_controller.height = height
        self._camera_restore_state = None

        try:
            spectator = new_world.get_spectator()
            if self.camera_controller:
                spectator.set_transform(self.camera_controller.get_carla_transform())
        except Exception as exc:
            print(f"[World Reset] Unable to reposition spectator: {exc}")

        try:
            self.camera_processor = CameraImageProcessor(
                new_world,
                self.camera_controller,
                self.screen_width,
                self.screen_height,
                self,
                stream_resolution=self.stream_resolution,
                stream_fps=self.stream_fps if self._using_remote_server() else 0,
            )
            if self.vehicle_menu:
                self.vehicle_menu.set_camera_processor(self.camera_processor)
            if self.pedestrian_menu:
                self.pedestrian_menu.set_camera_processor(self.camera_processor)
            if self.ego_vehicle_menu:
                self.ego_vehicle_menu.set_camera_processor(self.camera_processor)
            if not self.camera_stream_enabled:
                self._apply_stream_settings()
            self.camera_processor._server_host = self.connection_profile.host if self.connection_profile else '127.0.0.1'
            self.camera_processor._server_port = self.connection_profile.port if self.connection_profile else self.local_port
            if self.cached_map is not None:
                self.camera_processor.coordinate_detector.world_map = self.cached_map
            print("[World Reset] Camera processor reinitialized.")
            try:
                self.camera_processor.update_camera_position()
            except Exception as exc:
                print(f"[World Reset] Warning: failed to update camera position after reset: {exc}")
        except Exception as exc:
            print(f"[World Reset] Failed to rebuild camera processor: {exc}")
            self.loading_stage = f"Error rebuilding camera: {exc}"
            self._world_reset_in_progress = False
            return

        self.info_panel = InfoPanel(self.camera_processor)

        try:
            if self.vehicle_menu:
                self.vehicle_menu.initialize_vehicles(new_world)
            if self.pedestrian_menu:
                self.pedestrian_menu.initialize_pedestrians(new_world)
            if self.ego_vehicle_menu:
                self.ego_vehicle_menu.initialize_ego_vehicle(new_world)
        except Exception as exc:
            print(f"[World Reset] Warning: failed to refresh actor menus: {exc}")

        try:
            OpenDriveOverlayRenderer.invalidate_cache(self.camera_processor, drop_surfaces=True)
            self.camera_processor.precompute_opendrive_lane_data()
        except Exception as exc:
            print(f"[World Reset] Warning: failed to precompute OpenDRIVE data: {exc}")

        if self.camera_controller and self.world:
            try:
                self.camera_controller.update_min_height_from_terrain(self.world, height_buffer=5.0)
            except Exception as exc:
                print(f"[World Reset] Warning: failed to update camera terrain height: {exc}")

        try:
            refreshed_weather = self.world.get_weather()
        except Exception as exc:
            print(f"[Weather] Unable to refresh weather after world reset: {exc}")
        else:
            self._update_weather_state(refreshed_weather)
            self._capture_baseline_weather(refreshed_weather)
            if self.weather_window and self.weather_window.alive():
                self.weather_window.apply_weather(refreshed_weather)

        self._register_world_tick_handler()
        self.loading_stage = "Ready!"
        self.ready = True
        self._world_reset_in_progress = False
        self._world_reset_wait_thread = None
        try:
            snapshot = new_world.get_snapshot()
            with self._world_reset_lock:
                self._world_last_episode = getattr(snapshot.timestamp, "episode", None)
                self._world_last_frame = snapshot.frame
        except Exception:
            with self._world_reset_lock:
                self._world_last_episode = None
                self._world_last_frame = None
        print("[World Reset] Editor recovery complete.")

    def _confirm_switch_to_local(self):
        if not self.connection_profile or not self.connection_profile.is_remote:
            print("Already connected to local CARLA server.")
            return False

        self._close_all_dropdowns(keep_info_panel=True)
        self.map_menu_visible = False
        dialog_rect = self._center_dialog_rect(420, 220)
        dialog = UIConfirmationDialog(
            rect=dialog_rect,
            action_long_desc=(
                "Switch back to the local CARLA server?<br><br>"
                "This will terminate the remote session."
            ),
            manager=self.ui_manager,
            window_title="Switch to Local CARLA",
            action_short_name="Switch",
            blocking=True,
        )

        def handler(event: pygame.event.Event):
            if event.type == UI_CONFIRMATION_DIALOG_CONFIRMED and event.ui_element == dialog:
                return True, True
            if event.type == UI_BUTTON_PRESSED and event.ui_element == dialog.confirm_button:
                return True, True
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, False
            return False, None

        confirmed = self._run_modal_window(dialog, handler)
        if confirmed:
            self.manual_tick_enabled = False
            self.manual_tick_accumulator = 0.0
            self.manual_tick_recommendation = False
            return self.switch_to_local_server()
        return False

    def _clone_profile(self, profile):
        return ConnectionProfile(
            name=profile.name,
            host=profile.host,
            port=profile.port,
            manage_server=profile.manage_server,
            display_name=profile.display_name,
            description=profile.description,
            map_hint=profile.map_hint
        )

    def _safe_get_world_map(self, *, refresh=True):
        """Return cached CARLA map, optionally skipping refresh when unsafe."""
        if self.cached_map is not None:
            return self.cached_map

        if self.world_map is not None:
            self.cached_map = self.world_map
            return self.cached_map

        if not refresh or self._map_refresh_disabled:
            return None

        if not self.world:
            return None

        try:
            self.cached_map = self.world.get_map()
            self.world_map = self.cached_map
            return self.cached_map
        except Exception as exc:
            print(f"[Map] Unable to refresh world map: {exc}")
            return None

    def request_remote_map_change(self, map_name):
        if not self.connection_profile or not self.connection_profile.is_remote:
            print("Remote map change requested while not connected to a remote server.")
            return False
        if not map_name:
            return False

        target_short = map_name.split('/')[-1]
        current_short = self._get_map_display_name()
        if current_short == target_short:
            print(f"Remote map '{target_short}' already active.")
            return True

        print(f"[Remote Map] Requesting '{map_name}' on remote server...")
        profile_copy = self._clone_profile(self.connection_profile)
        self.manual_tick_enabled = False
        self.manual_tick_accumulator = 0.0
        self.manual_tick_recommendation = False
        return self._restart_with_profile(profile_copy, label=self.active_remote_label, target_map=map_name)


    def execute_command(self, command):
        """Execute a command and add it to the undo stack"""
        # Execute the command
        success = command.execute()
        if success is not False:  # Allow None or True
            self._mark_scene_dirty()
            # Add to undo stack
            self.undo_stack.append(command)
            # Clear redo stack since we have a new action
            if self.redo_stack:
                print(f"Clearing {len(self.redo_stack)} redo commands due to new action")
                self.redo_stack.clear()
            # Limit undo stack size
            if len(self.undo_stack) > self.max_undo_history:
                removed_command = self.undo_stack.pop(0)
                print(f"Removed oldest command from history: {removed_command.get_description()}")
            print(f"Executed: {command.get_description()} (Undo stack: {len(self.undo_stack)}, Redo stack: {len(self.redo_stack)})")
            self._refresh_active_info_panel()
        return success
    
    def undo_last_command(self):
        """Undo the last command (Ctrl+Z)"""
        if self.undo_stack:
            command = self.undo_stack.pop()
            command.undo()
            self.redo_stack.append(command)
            self._history_position = max(0, self._history_position - 1)
            # Limit redo stack size
            if len(self.redo_stack) > self.max_undo_history:
                self.redo_stack.pop(0)
            print(f"Undid: {command.get_description()} (Undo stack: {len(self.undo_stack)}, Redo stack: {len(self.redo_stack)})")
            self._refresh_active_info_panel()
            return True
        else:
            print("Nothing to undo")
            return False
    
    def redo_last_command(self):
        """Redo the last undone command (Ctrl+Y)"""
        if self.redo_stack:
            command = self.redo_stack.pop()
            # Use redo() method if available, otherwise fall back to execute()
            if hasattr(command, 'redo'):
                success = command.redo()
            else:
                success = command.execute()
            if success is not False:
                self.undo_stack.append(command)
                self._history_position += 1
                print(f"Redid: {command.get_description()} (Undo stack: {len(self.undo_stack)}, Redo stack: {len(self.redo_stack)})")
                self._refresh_active_info_panel()
                return True
            else:
                # If redo failed, put command back in redo stack
                self.redo_stack.append(command)
                print(f"Failed to redo: {command.get_description()}")
                return False
        else:
            print("Nothing to redo")
            return False
        
    def get_undo_status(self):
        """Get status of undo/redo stacks for UI display"""
        undo_count = len(self.undo_stack)
        redo_count = len(self.redo_stack)
        return f"Undo: {undo_count}/{self.max_undo_history}, Redo: {redo_count}"

    def _refresh_active_info_panel(self):
        """Refresh the info panel after history mutations to reflect live state."""
        panel = getattr(self, "info_panel", None)
        if panel and panel.visible and not panel.editing:
            panel._refresh_fields()

    # Scenario runner methods (Play button functionality)
    def _expected_ego_roles(self):
        """Return a set of role names that should be treated as ego vehicles."""
        roles = {"ego_vehicle", "hero"}
        try:
            if self.current_scenario_path and os.path.isfile(self.current_scenario_path):
                with open(self.current_scenario_path, "r", encoding="utf-8") as handle:
                    data = json.load(handle)
                ego_record = data.get("ego_vehicle")
                # Some scenarios may store a list of ego vehicles
                if isinstance(ego_record, dict):
                    role = ego_record.get("role")
                    if role:
                        roles.add(str(role))
                elif isinstance(ego_record, list):
                    for entry in ego_record:
                        if isinstance(entry, dict):
                            role = entry.get("role")
                            if role:
                                roles.add(str(role))
        except Exception as exc:
            print(f"Warning: Failed to resolve ego roles from scenario data: {exc}")
        return roles

    def _get_current_world(self):
        """Return the most up-to-date CARLA world reference available to the editor."""
        if self.client:
            try:
                return self.client.get_world()
            except Exception as exc:
                print(f"Warning: Failed to retrieve world from client: {exc}")
        if self.camera_processor and hasattr(self.camera_processor, "world"):
            return self.camera_processor.world
        return None

    def _refresh_external_ego_actor_reference(self):
        """Ensure cached external ego actor reference is alive and update it if needed."""
        if self.external_ego_actor and self.external_ego_actor.is_alive:
            return self.external_ego_actor

        if self.external_ego_actor_id is None:
            self.external_ego_actor = None
            return None

        world = self._get_current_world()
        if not world:
            self.external_ego_actor = None
            return None

        try:
            actor = world.get_actor(self.external_ego_actor_id)
        except Exception:
            actor = None

        if actor and actor.is_alive:
            try:
                role_name = actor.attributes.get('role_name', None)
            except Exception:
                role_name = None

            expected_roles = self._expected_ego_roles()
            if role_name in expected_roles:
                self.external_ego_actor = actor
                self._external_ego_present_last_check = True
                return actor

            description = role_name if role_name is not None else "<unknown>"
            print(
                f"[Ego Detection] Cached external ego actor {actor.id} now has role '{description}'; "
                "releasing reference."
            )

        self.external_ego_actor = None
        self.external_ego_actor_id = None
        self._external_ego_present_last_check = False
        return None

    def _detect_external_ego_vehicle(self, *, silent: bool = False):
        """Return externally spawned ego vehicle if one is already in the scene."""
        # Avoid misclassifying ScenarioRunner/MiniRunner ego actors as "external".
        #
        # During playback, MiniRunner spawns an internal ego with role_name "ego_vehicle",
        # which matches our external-ego roles and can incorrectly trigger overlays and
        # "preserve external ego" cleanup paths when restoring the editor preview.
        if self.scenario_running or getattr(self, "_restore_in_progress", False):
            return self._refresh_external_ego_actor_reference()

        self._last_external_ego_scan_time = time.time()
        world = self._get_current_world()
        if world is None:
            self._external_ego_present_last_check = False
            return None

        expected_roles = self._expected_ego_roles()
        detected_roles = set()
        spawned_preview_ids = set()
        camera_proc = getattr(self, "camera_processor", None)
        if camera_proc:
            spawned_preview_ids = {
                actor.id for actor in getattr(camera_proc, "spawned_vehicles", []) if actor and actor.is_alive
            }

        try:
            vehicles = world.get_actors().filter('vehicle.*')
        except Exception as exc:
            print(f"Warning: Failed to query vehicles when searching for external ego: {exc}")
            self._external_ego_present_last_check = False
            return None

        previous_id = self.external_ego_actor_id
        suppress_actions = bool(getattr(self, "_suppress_external_ego_adoption", False))

        for actor in vehicles:
            try:
                role_name = actor.attributes.get('role_name')
                if role_name:
                    detected_roles.add(role_name)
                if role_name in expected_roles:
                    if actor.id in spawned_preview_ids:
                        # Allow the cached external or swapped ego to be recognized even if tracked as a preview.
                        if actor.id != previous_id and actor.id != self._external_swap_current_id:
                            continue
                    if actor.is_alive:
                        try:
                            loc = actor.get_location()
                            if (not silent) or (previous_id != actor.id):
                                print(
                                    f"Detected candidate external ego vehicle {actor.id} "
                                    f"({actor.type_id}) with role '{role_name}' at "
                                    f"({loc.x:.1f}, {loc.y:.1f}, {loc.z:.1f})"
                                )
                        except Exception:
                            if (not silent) or (previous_id != actor.id):
                                print(
                                    f"Detected candidate external ego vehicle {actor.id} "
                                    f"({actor.type_id}) with role '{role_name}'"
                                )

                        # Handle automatic scenario reload for new external ego connection
                        if (
                            not suppress_actions
                            and self.external_ego_actor is None
                            and not self._external_ego_scenario_reloaded
                        ):

                            self._external_ego_scenario_reloaded = True  # Set immediately to prevent re-entry

                            if (not self.scenario_running
                                and self.current_scenario_path
                                and self.camera_processor):

                                try:
                                    # Surface an early overlay so users know we're adopting an external ego.
                                    try:
                                        self._show_external_swap_overlay("Adopting external ego...")
                                        self._render_external_swap_overlay_immediate()
                                    except Exception:
                                        pass
                                    print(
                                        f"[External Ego] Auto-reloading scenario '{self.current_scenario_path}' "
                                        f"for new external ego connection (actor {actor.id})"
                                    )
                                    self.camera_processor.load_waypoint_data_from_file(
                                        self.current_scenario_path,
                                        preserve_camera=True,
                                        skip_ego_spawn=True,
                                    )
                                    try:
                                        scenario_data = getattr(self.camera_processor, "loaded_scenario_data", None)
                                        if not scenario_data and os.path.isfile(self.current_scenario_path):
                                            with open(self.current_scenario_path, "r", encoding="utf-8") as fh:
                                                scenario_data = json.load(fh)
                                        if scenario_data:
                                            self._apply_weather_from_json_data(scenario_data)
                                    except Exception as exc:
                                        print(f"[External Ego] Failed to re-apply weather: {exc}")
                                except Exception as exc:
                                    print(
                                        f"[External Ego] Failed to reload scenario '{self.current_scenario_path}': {exc}"
                                    )

                        self.external_ego_actor = actor
                        self.external_ego_actor_id = actor.id
                        self._external_ego_present_last_check = True
                        if suppress_actions:
                            self._external_ego_prompt_pending_id = None
                            return actor
                        try:
                            self._show_external_swap_overlay("Adopting external ego...")
                            self._render_external_swap_overlay_immediate()
                        except Exception:
                            pass
                        self._maybe_prompt_external_ego_swap(actor)
                        return actor
                    else:
                        print(
                            f"Found actor {actor.id} with role '{role_name}' but actor.is_alive == False; "
                            "skipping as external ego."
                        )
            except Exception:
                continue

        if expected_roles:
            if not silent:
                print(
                    "No external ego vehicle found. "
                    f"Expected roles: {sorted(expected_roles)}, detected scene roles: {sorted(detected_roles)}"
                )
        if previous_id is not None and previous_id in spawned_preview_ids:
            # Keep the previous reference alive when it is one of our tracked actors.
            try:
                actor = world.get_actor(previous_id)
                if actor and actor.is_alive:
                    self.external_ego_actor = actor
                    self.external_ego_actor_id = previous_id
                    self._external_ego_present_last_check = True
                    return actor
            except Exception:
                pass
        self.external_ego_actor = None
        self.external_ego_actor_id = None
        self._external_ego_present_last_check = False
        self._external_ego_prompt_pending_id = None
        self._external_ego_scenario_reloaded = False  # Reset for next connection
        return None

    def _resolve_external_ego_actor(
        self,
        *,
        silent: bool,
        force_scan: bool = False,
        allow_scan: bool = False,
    ) -> Optional[carla.Actor]:
        """Return the external ego actor by refreshing cached state and optionally scanning."""
        if force_scan:
            self._detect_external_ego_vehicle(silent=silent)
            return self._refresh_external_ego_actor_reference()
        actor = self._refresh_external_ego_actor_reference()
        if actor is None and allow_scan:
            actor = self._detect_external_ego_vehicle(silent=silent)
        return actor

    def _focus_camera_on_ego_vehicle(self) -> bool:
        """Snap the editor camera to the active ego vehicle if one exists."""
        cp = self.camera_processor
        if not cp:
            return False
        self._camera_debug("[CameraDebug] _focus_camera_on_ego_vehicle invoked")
        self._debug_camera_pose("focus-ego-before")

        def _valid_location(loc: Optional[carla.Location]) -> bool:
            if loc is None:
                return False
            try:
                if not (math.isfinite(loc.x) and math.isfinite(loc.y) and math.isfinite(loc.z)):
                    return False
                if abs(loc.x) + abs(loc.y) + abs(loc.z) < 0.5:
                    return False
            except Exception:
                return False
            return True

        location: Optional[carla.Location] = None

        # 1) Editor-managed ego actor (highest priority)
        try:
            editor_ego = cp.get_editor_ego_actor()
        except Exception:
            editor_ego = None
        if editor_ego:
            try:
                loc = editor_ego.get_location()
                if _valid_location(loc):
                    location = loc
            except Exception:
                pass

        # 2) Cached editor ego transform
        if location is None:
            transform = getattr(cp, "ego_vehicle_transform", None)
            if transform:
                loc = transform.location
                loc = carla.Location(loc.x, loc.y, loc.z)
                if _valid_location(loc):
                    location = loc

        # 3) Ego pose from loaded scenario JSON
        if location is None:
            scenario_data = getattr(cp, "loaded_scenario_data", None)
            if isinstance(scenario_data, dict):
                ego_meta = scenario_data.get("ego_vehicle") or {}
                loc_meta = ego_meta.get("location") or {}
                try:
                    loc = carla.Location(
                        float(loc_meta.get("x", 0.0)),
                        float(loc_meta.get("y", 0.0)),
                        float(loc_meta.get("z", 0.0)),
                    )
                    if _valid_location(loc):
                        location = loc
                except Exception:
                    pass

        # 4) External/any ego-role actor (last resort, only if valid)
        if location is None:
            try:
                ego_actor = cp.get_ego_vehicle_actor()
            except Exception:
                ego_actor = None
            if ego_actor and ego_actor.is_alive:
                try:
                    loc = ego_actor.get_location()
                    if _valid_location(loc):
                        location = loc
                except Exception:
                    pass

        if location:
            cp.focus_camera_on_location(location)
            try:
                self._camera_debug(
                    f"[CameraDebug] Focused on ego at ({location.x:.2f}, {location.y:.2f}, {location.z:.2f})"
                )
                self._debug_camera_pose("focus-ego-after")
            except Exception:
                self._camera_debug("[CameraDebug] Focused on ego at <unknown location>")
            return True
        self._camera_debug("[CameraDebug] No ego location available to focus")
        return False

    def _close_result_window(self):
        """Kill any open result window and clear pending state."""
        if self.result_window:
            try:
                self.result_window.kill()
            except Exception:
                pass
        self.result_window = None
        self._pending_result_dialog = None

    def _enqueue_result_dialog(self, reason: str):
        """Prepare result text to be shown once the scenario stops."""
        text = ""
        result_path: Optional[str] = None
        try:
            if self.current_scenario_path:
                result_path = str(Path(self.current_scenario_path).with_suffix(".txt"))
                try:
                    with open(result_path, "r", encoding="utf-8") as fh:
                        text = fh.read()
                except Exception as exc:
                    print(f"[Results] Unable to read result file: {exc}")
        except Exception as exc:
            print(f"[Results] Failed to resolve result file path: {exc}")

        if not text:
            text = f"Scenario finished ({reason})"

        self._pending_result_dialog = {
            "text": text,
            "path": result_path,
            "reason": reason,
        }

    def _copy_result_text(self, text: str):
        if not text:
            return
        copied = False
        try:
            with warnings.catch_warnings():
                warnings.filterwarnings(
                    "ignore",
                    message=".*scrap.*deprecated.*",
                    category=DeprecationWarning,
                )
                if not pygame.scrap.get_init():
                    pygame.scrap.init()
                pygame.scrap.put_text(text)
            copied = True
        except Exception as exc:
            print(f"[Results] Clipboard copy via pygame failed: {exc}")

        if not copied:
            try:
                import tkinter  # type: ignore

                root = tkinter.Tk()
                root.withdraw()
                root.clipboard_clear()
                root.clipboard_append(text)
                root.update()
                root.destroy()
                copied = True
            except Exception as exc:
                print(f"[Results] Clipboard copy via tkinter failed: {exc}")

        if not copied:
            try:
                import pyperclip  # type: ignore

                pyperclip.copy(text)
                copied = True
            except Exception as exc:
                print(f"[Results] Clipboard copy fallback failed: {exc}")

        if copied:
            print("[Results] Copied scenario results to clipboard.")

    def _save_result_text(self, text: str, default_path: Optional[str]):
        if not text:
            print("[Results] Nothing to save.")
            return
        if not self.ui_manager:
            print("[Results] UI not ready; cannot open save dialog.")
            return

        initial_path = default_path
        if not initial_path:
            if self.current_scenario_path:
                initial_path = str(Path(self.current_scenario_path).with_suffix(".txt"))
            else:
                initial_path = os.getcwd()
        if os.path.isdir(initial_path):
            initial_path = os.path.join(initial_path, "results.txt")

        dialog_rect = self._center_dialog_rect(640, 480)
        dialog = EnhancedFileDialog(
            rect=dialog_rect,
            manager=self.ui_manager,
            window_title="Save Results",
            allowed_suffixes={".txt", ".TXT"},
            initial_file_path=initial_path,
            allow_existing_files_only=False,
            always_on_top=True,
        )
        dialog.set_blocking(True)
        confirm_button = getattr(dialog, "ok_button", getattr(dialog, "confirm_button", None))
        if confirm_button:
            confirm_button.set_text("Save")
        file_entry = getattr(dialog, "file_path_text_line", None)
        if file_entry and initial_path:
            file_entry.set_text(initial_path)
            filename = os.path.basename(initial_path)
            name_part = filename[:-4] if filename.lower().endswith(".txt") else filename
            start_index = len(initial_path) - len(filename)
            end_index = start_index + len(name_part)
            file_entry.select_range = [start_index, end_index]
            file_entry.cursor_has_moved_recently = True
            file_entry.edit_position = end_index
            try:
                file_entry.focus()
            except AttributeError:
                pass

        def handler(event: pygame.event.Event):
            if event.type == UI_FILE_DIALOG_PATH_PICKED and event.ui_element == dialog:
                picked = getattr(event, "text", None)
                if picked and not os.path.isdir(picked):
                    return True, picked
                return False, None
            if event.type == pygame.USEREVENT:
                picked_path = getattr(event, "text", None)
                ui_element = getattr(event, "ui_element", None)
                if picked_path and ui_element == dialog and not os.path.isdir(picked_path):
                    return True, picked_path
            if event.type == UI_SELECTION_LIST_DOUBLE_CLICKED_SELECTION and event.ui_element == getattr(dialog, "file_selection_list", None):
                if Path(dialog.current_directory_path).name == event.text and Path(dialog.current_directory_path).is_dir():
                    return False, None
                path = dialog.current_file_path
                if path and not os.path.isdir(path):
                    return True, str(path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and hasattr(dialog, "new_folder_button")
                and event.ui_element == dialog.new_folder_button
            ):
                folder_name = self._prompt_text_input("Create Folder", "Folder name:", "New Folder")
                if folder_name:
                    base_dir = Path(dialog.current_directory_path)
                    new_path = base_dir / folder_name
                    try:
                        new_path.mkdir()
                    except FileExistsError:
                        print(f"[File Dialog] Folder '{folder_name}' already exists.")
                    except Exception as exc:
                        print(f"[File Dialog] Unable to create folder '{folder_name}': {exc}")
                    else:
                        dialog._change_directory_path(new_path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and confirm_button is not None
                and event.ui_element == confirm_button
            ):
                path = dialog.current_file_path
                if path and not os.path.isdir(path):
                    return True, str(path)
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, None
            return False, None

        file_path = self._run_modal_window(dialog, handler)
        if not file_path:
            return

        file_path = os.path.abspath(file_path)
        if not file_path.lower().endswith(".txt"):
            file_path += ".txt"

        try:
            with open(file_path, "w", encoding="utf-8") as fh:
                fh.write(text)
            print(f"[Results] Saved results to {file_path}")
        except Exception as exc:
            print(f"[Results] Failed to save results: {exc}")

    def _maybe_open_result_window(self):
        """Show the result window if a scenario just finished."""
        if self.result_window and not self.result_window.alive():
            self.result_window = None

        scenario_active = bool(self.scenario_running or (self.scenario_process and self.scenario_process.poll() is None))
        if scenario_active or not self.ready:
            return
        if not self._pending_result_dialog or not self.ui_manager:
            return

        payload = self._pending_result_dialog
        self._pending_result_dialog = None

        text = str(payload.get("text", "") or "")
        default_path = payload.get("path")

        rect_width = max(640, int(self.screen_width * 0.6))
        rect_height = max(420, int(self.screen_height * 0.6))
        dialog_rect = self._center_dialog_rect(rect_width, rect_height)

        self.result_window = ResultWindow(
            rect=dialog_rect,
            manager=self.ui_manager,
            text=text,
            on_copy=lambda: self._copy_result_text(text),
            on_save=lambda: self._save_result_text(text, default_path if isinstance(default_path, str) else None),
            on_close=self._close_result_window,
        )

    def _capture_playback_preserved_state(
        self,
    ) -> Tuple[Optional[Dict[str, object]], Optional[int]]:
        """Capture selection/waypoint state before playback and stash it on the editor."""
        preserved_display_id = None
        preserved_waypoints = None
        preserved_signature = None
        preserved_blueprint = None
        preserved_location = None
        preserved_is_pedestrian = False
        panel_visible = False
        preserved_traffic_light_ids: Optional[Tuple[int, ...]] = None
        traffic_light_panel_visible = False
        ego_override_id = None

        cp = self.camera_processor
        actor_ref = None
        if cp:
            candidate_id = None
            if cp.selected_vehicle and cp.selected_vehicle.is_alive:
                candidate_id = cp.selected_vehicle.id
                actor_ref = cp.selected_vehicle
            elif cp.waypoint_display_vehicle_id:
                candidate_id = cp.waypoint_display_vehicle_id

            if candidate_id is not None:
                preserved_display_id = candidate_id

                waypoints = cp.get_vehicle_waypoints(candidate_id)
                if waypoints:
                    preserved_waypoints = clone_waypoint_sequence(waypoints)
                    preserved_signature = self._compute_waypoint_signature(preserved_waypoints)

                if actor_ref is None:
                    actor_ref = next(
                        (
                            actor
                            for actor in cp.spawned_vehicles
                            if actor and actor.is_alive and actor.id == candidate_id
                        ),
                        None,
                    )

                if actor_ref:
                    preserved_blueprint = actor_ref.type_id
                    preserved_is_pedestrian = actor_ref.type_id.startswith('walker.')
                    try:
                        transform = actor_ref.get_transform()
                        preserved_location = {
                            'x': transform.location.x,
                            'y': transform.location.y,
                            'z': transform.location.z,
                            'yaw': transform.rotation.yaw,
                        }
                    except Exception:
                        preserved_location = None

            panel = getattr(self, "info_panel", None)
            if (
                panel
                and panel.visible
                and panel.object_type in ('vehicle', 'pedestrian')
                and actor_ref
                and getattr(panel, "selected_object", None) is actor_ref
            ):
                panel_visible = True

            selected_group = cp.selected_traffic_light_group
            if selected_group:
                preserved_traffic_light_ids = tuple(sorted(selected_group.ids))
                tl_panel = getattr(self, "info_panel", None)
                if (
                    tl_panel
                    and tl_panel.visible
                    and tl_panel.object_type == 'traffic_light'
                    and getattr(tl_panel, "selected_object", None) is selected_group
                ):
                    traffic_light_panel_visible = True

            if candidate_id is not None and cp.is_ego_vehicle(candidate_id):
                ego_override_id = candidate_id

        active_trigger_snapshot: Optional[Dict[str, object]] = None

        self._scenario_preserved_waypoint_vehicle_id = preserved_display_id
        self._scenario_preserved_waypoints = preserved_waypoints
        self._scenario_preserved_waypoint_signature = preserved_signature
        self._scenario_preserved_actor_blueprint = preserved_blueprint
        self._scenario_preserved_actor_location = preserved_location
        self._scenario_preserved_actor_is_pedestrian = preserved_is_pedestrian
        self._scenario_preserved_info_panel_visible = panel_visible
        self._scenario_preserved_traffic_light_ids = preserved_traffic_light_ids
        self._scenario_preserved_traffic_light_info_visible = traffic_light_panel_visible
        if preserved_traffic_light_ids and cp:
            group = cp.selected_traffic_light_group
            if group and group.has_trigger() and tuple(sorted(group.ids)) == preserved_traffic_light_ids:
                center = group.trigger_center or {}
                radius = group.trigger_radius
                if center and radius is not None:
                    active_trigger_snapshot = {
                        'ids_live': list(preserved_traffic_light_ids),
                        'ids_reference': sorted(group.reference_ids or group.ids),
                        'center': {
                            'x': float(center.get('x', 0.0)),
                            'y': float(center.get('y', 0.0)),
                            'z': float(center.get('z', 0.0)),
                        },
                        'radius': float(radius),
                    }

        # Preserve overlay visibility state
        preserved_traffic_lights_visible = False
        preserved_lane_overlay_enabled = False
        if cp:
            preserved_traffic_lights_visible = getattr(cp, 'traffic_lights_visible', False)
            preserved_lane_overlay_enabled = getattr(cp, 'lane_overlay_enabled', False)

        self._scenario_preserved_traffic_lights_visible = preserved_traffic_lights_visible
        self._scenario_preserved_lane_overlay_enabled = preserved_lane_overlay_enabled
        print(f"[OVERLAY PRESERVE] Traffic={preserved_traffic_lights_visible}, OpenDRIVE={preserved_lane_overlay_enabled}")

        return active_trigger_snapshot, ego_override_id

    def _detect_scenario_ego_flags(self) -> Tuple[bool, bool]:
        """Return (scenario_has_ego, ego_has_route) based on current scenario data."""
        scenario_has_ego = False
        ego_has_route = False
        try:
            scenario_data = getattr(self.camera_processor, "loaded_scenario_data", None)
            if not scenario_data and self.current_scenario_path and os.path.isfile(self.current_scenario_path):
                with open(self.current_scenario_path, "r", encoding="utf-8") as fh:
                    scenario_data = json.load(fh)
            if scenario_data:
                ego_entries = []
                ego_entry = scenario_data.get("ego_vehicle")
                if isinstance(ego_entry, dict):
                    ego_entries = [ego_entry]
                elif isinstance(ego_entry, list):
                    ego_entries = [entry for entry in ego_entry if isinstance(entry, dict)]
                if not ego_entries:
                    for entry in scenario_data.get("vehicles", []):
                        if str(entry.get("role", "")).lower() == "ego_vehicle":
                            ego_entries = [entry]
                            break
                if ego_entries:
                    scenario_has_ego = True
                    for entry in ego_entries:
                        waypoints = entry.get("waypoints", [])
                        if isinstance(waypoints, list) and waypoints:
                            ego_has_route = True
                            break
        except Exception as exc:
            print(f"[Scenario] Unable to determine ego presence: {exc}")
            ego_has_route = False
        return scenario_has_ego, ego_has_route

    def _prepare_external_ego_for_playback(self, scenario_has_ego: bool) -> Tuple[bool, bool]:
        """Detect and configure external ego handling for playback."""
        external_ego_identified = False
        external_actor = None
        external_ego_present = False
        if scenario_has_ego:
            external_actor = self._resolve_external_ego_actor(silent=False, force_scan=True)
            external_ego_present = bool(external_actor)
            if external_actor:
                external_ego_identified = True
                try:
                    role_name = external_actor.attributes.get('role_name', '<unknown>')
                except Exception:
                    role_name = '<unknown>'
                try:
                    self._external_swap_pre_run_transform = external_actor.get_transform()
                except Exception:
                    self._external_swap_pre_run_transform = None
                print(
                    f"Detected external ego vehicle {external_actor.id} "
                    f"with role '{role_name}'; scenario will attach to it."
                )
                try:
                    external_actor.set_simulate_physics(True)
                except Exception:
                    pass
            else:
                self._switch_world_to_async_if_safe(reason="scenario launch without external ego")
        else:
            # Ignore any lingering external ego when the scenario has no ego entry.
            self.external_ego_actor = None
            self.external_ego_actor_id = None
            self._switch_world_to_async_if_safe(reason="scenario launch without ego vehicle")
        return external_ego_present, external_ego_identified

    def _restore_preserved_waypoints_for_playback(self, ego_override_id: Optional[int]) -> None:
        if (
            self.camera_processor
            and self._scenario_preserved_waypoint_vehicle_id is not None
            and self._scenario_preserved_waypoints
        ):
            cp = self.camera_processor
            if ego_override_id is not None:
                cp._waypoint_ego_override_id = ego_override_id
            cp.waypoint_list[self._scenario_preserved_waypoint_vehicle_id] = clone_waypoint_sequence(
                self._scenario_preserved_waypoints
            )
            cp.waypoint_display_vehicle_id = self._scenario_preserved_waypoint_vehicle_id
            cp.selected_vehicle = None
            cp.selected_vehicle_is_pedestrian = False
            cp.vehicle_menu_position = None
            cp.selected_waypoint_vehicle_id = None
            cp.selected_waypoint_index = None

            info_panel = getattr(self, "info_panel", None)
            if info_panel:
                markers = getattr(info_panel, "scenario_starting_points", {}) or {}
                marker_key = self._scenario_preserved_waypoint_vehicle_id
                if marker_key not in markers and self._scenario_preserved_actor_location:
                    loc = self._scenario_preserved_actor_location
                    markers = dict(markers)
                    markers[marker_key] = {
                        "x": loc.get("x", 0.0),
                        "y": loc.get("y", 0.0),
                        "z": loc.get("z", 0.0),
                        "vehicle_id": marker_key,
                    }
                    info_panel.scenario_starting_points = markers

            cp.refresh_waypoints_carla_debug()

    def _apply_playback_ui_state(
        self,
        *,
        active_trigger_snapshot: Optional[Dict[str, object]],
        scenario_has_ego: bool,
        external_ego_present: bool,
        ego_has_route: bool,
    ) -> None:
        """Update UI/selection state at scenario start."""
        # Update state to indicate scenario is running
        self.scenario_running = True
        # Clear contextual menus while Scenario Runner takes control
        if self.camera_processor:
            selected_display_id = self._scenario_preserved_waypoint_vehicle_id

            self.camera_processor.clear_vehicle_selection(
                keep_waypoints=selected_display_id is not None,
                hide_info_panel=True,
                clear_traffic_light=False,
            )
            self.camera_processor.selected_trigger_index = None
            self.camera_processor.trigger_action_menu_position = None
            if active_trigger_snapshot:
                self._scenario_active_traffic_light_trigger = active_trigger_snapshot
                self.camera_processor._scenario_active_traffic_light_trigger = active_trigger_snapshot
            if selected_display_id is not None:
                self.camera_processor.waypoint_display_vehicle_id = selected_display_id
                self.camera_processor.refresh_waypoints_carla_debug()
                if hasattr(self.camera_processor, "force_refresh"):
                    self.camera_processor.force_refresh = True
            else:
                self.camera_processor.waypoint_display_vehicle_id = None
        if hasattr(self, 'info_panel') and self.info_panel:
            self.info_panel.hide()
        # Always enable manual control for local ego (camera follows regardless of route)
        should_enable_manual_control = scenario_has_ego and not external_ego_present
        if self.camera_processor and should_enable_manual_control:
            self.camera_processor.request_manual_control()

        # Hide overlays during playback for a clean viewing experience
        if self.camera_processor:
            # Hide traffic light overlay
            if self.camera_processor.traffic_lights_visible:
                self.camera_processor.traffic_lights_visible = False
                self.camera_processor.clear_traffic_light_selection()
                if (self.camera_processor.selected_personal_trigger
                        and self.camera_processor.selected_personal_trigger.get('kind') == 'traffic_light'):
                    self.camera_processor.clear_personal_trigger_selection()
                self.camera_processor._last_visible_traffic_light_trigger_key = None

            # Hide OpenDRIVE overlay
            if self.camera_processor.lane_overlay_enabled:
                OpenDriveOverlayRenderer.disable_overlay(self.camera_processor, silent=True)

    def run_scenario(self):
        """Run the currently loaded scenario"""
        if not self.current_scenario_path or not os.path.isfile(self.current_scenario_path):
            print("Scenario has not been saved yet. Please choose a file to save before playback.")
            self.save_scenario_with_dialog()
            if not self.current_scenario_path or not os.path.isfile(self.current_scenario_path):
                print("Scenario run cancelled: scenario must be saved before playback.")
                return

        if self.scenario_running:
            self.stop_scenario()
            return

        debug_enabled = bool(getattr(self, "debug_mode", False))
        if debug_enabled:
            try:
                faulthandler.enable(all_threads=True)
            except Exception:
                pass

        def _play_diag(message: str) -> None:
            if debug_enabled:
                print(f"[PlayDiag] {message}")

        _play_diag("run_scenario: enter")

        try:
            locale.setlocale(locale.LC_NUMERIC, "C")
        except Exception as exc:
            _play_diag(f"Locale warning: failed to force LC_NUMERIC=C before playback: {exc}")

        # Set flag to prevent bootstrap mode during scenario launch
        self._scenario_run_in_progress = True

        try:
            self._restore_invoked_for_run = False
            self._close_result_window()
            if self._has_unsaved_changes():
                if not self._confirm_play_discard_changes():
                    print("Scenario run cancelled: unsaved changes were not discarded.")
                    return

                if not self.camera_processor:
                    print("Scenario run cancelled: camera processor not initialized.")
                    return

                if not os.path.isfile(self.current_scenario_path):
                    print("Scenario run cancelled: scenario file missing. Save before playback.")
                    return

                try:
                    self._discard_unsaved_changes_for_play()
                    print(f"[Scenario] Discarded unsaved changes; running '{self.current_scenario_path}' from disk.")
                except Exception as exc:
                    print(f"Scenario run cancelled: failed to discard unsaved changes ({exc})")
                    return

            self.scenario_stop_requested = False
            if self.camera_processor:
                self.camera_processor.disable_manual_control()
                self._debug_camera_pose("pre-run focus")
                if self._auto_camera_allowed():
                    self._focus_camera_on_ego_vehicle()
            self._reset_scenario_waypoint_preserve()
            self._scenario_pending_actor_reselect = False

            active_trigger_snapshot, ego_override_id = self._capture_playback_preserved_state()

            scenario_has_ego, ego_has_route = self._detect_scenario_ego_flags()

            external_ego_present, external_ego_identified = self._prepare_external_ego_for_playback(scenario_has_ego)

            # Record start markers before relocating vehicles so UI can display placeholders
            self._record_scenario_start_markers()

            # Save and move ALL vehicles in the scene to avoid conflicts
            self._save_all_scene_vehicles()
            self._restore_preserved_waypoints_for_playback(ego_override_id)

            if scenario_has_ego:
                if (
                    external_ego_present
                    and not external_ego_identified
                ):
                    try:
                        role_name = self.external_ego_actor.attributes.get('role_name', '<unknown>')
                    except Exception:
                        role_name = '<unknown>'
                    print(
                        f"Detected external ego vehicle {self.external_ego_actor.id} "
                        f"with role '{role_name}'; scenario will attach to it."
                    )
                    external_ego_identified = True

            # Validate scenario JSON
            if not os.path.isfile(self.current_scenario_path):
                print(f"Error: Scenario JSON '{self.current_scenario_path}' not found. Save your scenario before running.")
                self._restore_all_scene_vehicles_once()
                return
            else:
                print(f"[Scenario] Using existing scenario data from {self.current_scenario_path}")

            # If a runner is already active, treat Play as stop
            if getattr(self, "_mini_runner", None) and self._mini_runner.is_running:
                print("[MiniRunner] Stop requested by user.")
                self.scenario_stop_requested = True
                self._mini_runner.request_stop()
                return

            env_timeout = os.environ.get("VSE_SCENARIO_RUNNER_TIMEOUT")
            try:
                timeout_seconds = float(env_timeout) if env_timeout else 18000.0
            except (TypeError, ValueError):
                timeout_seconds = 18000.0
            timeout_seconds = max(timeout_seconds, 30.0)

            tick_mode = "ros" if (scenario_has_ego and external_ego_present) else "own"
            wait_for_ego = tick_mode == "ros"
            agent_path = None
            if tick_mode == "ros":
                candidate = getattr(self, "agent_path", None)
                if candidate and not os.path.isfile(candidate):
                    self._clear_last_agent_cache(remove_file=True)
                    candidate = None
                if not candidate:
                    candidate = self._prompt_agent_file_path()
                    if not candidate:
                        print("[Agent] Scenario run cancelled: external ego playback requires an agent file.")
                        self._restore_all_scene_vehicles_once()
                        return
                    self._remember_last_agent(candidate)
                agent_path = candidate
            fixed_delta = 0.05
            try:
                settings = self.world.get_settings() if self.world else None
                if settings and settings.fixed_delta_seconds:
                    fixed_delta = float(settings.fixed_delta_seconds)
            except Exception:
                fixed_delta = 0.05

            # Preserve current world weather so we can restore it after playback.
            try:
                self._scenario_restore_weather = self.world.get_weather() if self.world else None
            except Exception:
                self._scenario_restore_weather = None

            print(f"Running scenario via MiniRunner (mode={tick_mode}, timeout={timeout_seconds}s)")
            _play_diag("run_scenario: printed runner start banner")

            self._apply_playback_ui_state(
                active_trigger_snapshot=active_trigger_snapshot,
                scenario_has_ego=scenario_has_ego,
                external_ego_present=external_ego_present,
                ego_has_route=ego_has_route,
            )

            def _log_fn(message: str):
                print(f"[MiniRunner] {message}")

            def _on_finish(reason: str):
                self._debug_camera_pose("pre-restore-finally")
                self._restore_all_scene_vehicles_once()
                if self.camera_processor:
                    self.camera_processor.disable_manual_control()
                self._restore_start_weather_from_presets()
                self.scenario_running = False
                self.scenario_stop_requested = False
                self._mini_runner = None
                self._debug_camera_pose("post-run restore")
                if self.camera_processor:
                    try:
                        self._debug_camera_pose("post-run restore after disable")
                    except Exception:
                        pass
                print(f"[MiniRunner] Scenario finished ({reason})")
                try:
                    self._enqueue_result_dialog(reason or "")
                except Exception as exc:
                    print(f"[Results] Failed to prepare result dialog: {exc}")

            try:
                _play_diag("run_scenario: importing MiniRunner")
                prev_install_handlers = os.environ.get("VSE_PLAY_INSTALL_HANDLERS")
                os.environ["VSE_PLAY_INSTALL_HANDLERS"] = "0"
                from vse_play import MiniRunner
                _play_diag("run_scenario: MiniRunner import OK")
            except Exception as import_err:
                print(f"Error importing MiniRunner: {import_err}")
                self._restore_all_scene_vehicles_once()
                self.scenario_running = False
                return
            finally:
                if 'prev_install_handlers' in locals():
                    if prev_install_handlers is None:
                        os.environ.pop("VSE_PLAY_INSTALL_HANDLERS", None)
                    else:
                        os.environ["VSE_PLAY_INSTALL_HANDLERS"] = prev_install_handlers

            external_ego_id = None
            try:
                if scenario_has_ego and self.external_ego_actor and self.external_ego_actor.is_alive:
                    external_ego_id = self.external_ego_actor.id
            except Exception:
                external_ego_id = None

            # Disable bootstrap mode if it was active from preview
            if getattr(self, '_large_map_bootstrap_ticking', False):
                self._set_large_map_bootstrap_ticking(
                    False,
                    log_message="[Scenario Launch] Disabling bootstrap mode for scenario playback",
                    disable_manual_tick=True,
                    clear_pending_external_ego=True,
                )

            self._mini_runner = MiniRunner(
                client=self.client,
                world=self.world,
                json_path=self.current_scenario_path,
                tick_mode=tick_mode,
                fixed_delta=fixed_delta,
                wait_for_ego=wait_for_ego,
                ego_role_name="ego_vehicle",
                timeout_s=timeout_seconds,
                external_ego_actor_id=external_ego_id,
                log_fn=_log_fn,
                debug=getattr(self, "debug_mode", False),
                on_finish=_on_finish,
                agent_path=agent_path,
            )
            _play_diag("run_scenario: MiniRunner init OK")
            _play_diag("run_scenario: MiniRunner start()")
            self._mini_runner.start()
            _play_diag("run_scenario: MiniRunner start() returned")

            runner_thread = getattr(self._mini_runner, "_thread", None)
            if not runner_thread or not runner_thread.is_alive():
                print("[MiniRunner] Start failed; restoring scene.")
                self._restore_all_scene_vehicles_once()
                if self.camera_processor:
                    self.camera_processor.disable_manual_control()
                self._restore_start_weather_from_presets()
                self.scenario_running = False
                self.scenario_stop_requested = False
                self._mini_runner = None
                return

        except Exception as e:
            print(f"Error starting scenario: {e}")
            self._restore_all_scene_vehicles_once()
            if self.camera_processor:
                self.camera_processor.disable_manual_control()
            self.scenario_running = False
        finally:
            # Always clear the flag when exiting run_scenario (success, error, or early return)
            self._scenario_run_in_progress = False

    def _discard_unsaved_changes_for_play(self):
        """Drop in-memory edits before playback without reloading the preview."""
        cp = self.camera_processor
        external_id = getattr(self, "external_ego_actor_id", None)
        preserve_ids = {external_id} if external_id is not None else set()

        if cp:
            try:
                cp.cleanup_all_vehicles(preserve_ids=preserve_ids, preserve_ego=True)
            except Exception:
                pass

            if hasattr(cp, "spawned_vehicles"):
                cp.spawned_vehicles.clear()
            if hasattr(cp, "waypoint_list"):
                cp.waypoint_list.clear()
            if hasattr(cp, "triggers"):
                cp.triggers.clear()
            for attr in (
                "traffic_light_trigger_centers",
                "traffic_light_trigger_radii",
                "traffic_light_sequences",
                "_traffic_light_group_snapshots",
            ):
                if hasattr(cp, attr):
                    getattr(cp, attr).clear()
            if hasattr(cp, "_scenario_active_traffic_light_trigger"):
                cp._scenario_active_traffic_light_trigger = None
            if hasattr(cp, "_last_visible_traffic_light_trigger_key"):
                cp._last_visible_traffic_light_trigger_key = None
            if hasattr(cp, "scaling_traffic_light_trigger"):
                cp.scaling_traffic_light_trigger = False
            if hasattr(cp, "_traffic_light_scaling_group"):
                cp._traffic_light_scaling_group = None
            if hasattr(cp, "traffic_light_menu_position"):
                cp.traffic_light_menu_position = None
            if hasattr(cp, "traffic_light_groups"):
                try:
                    for group in cp.traffic_light_groups:
                        group.trigger_center = None
                        group.trigger_radius = None
                except Exception:
                    pass
            if hasattr(cp, "clear_traffic_light_selection"):
                try:
                    cp.clear_traffic_light_selection()
                except Exception:
                    pass

            # Reset selection and ego metadata
            for attr in (
                "selected_vehicle",
                "vehicle_menu_position",
                "selected_waypoint_vehicle_id",
                "selected_waypoint_index",
                "waypoint_display_vehicle_id",
                "selected_trigger_index",
            ):
                if hasattr(cp, attr):
                    setattr(cp, attr, None)
            if hasattr(cp, "selected_vehicle_is_pedestrian"):
                cp.selected_vehicle_is_pedestrian = False
            if hasattr(cp, "moving_waypoint"):
                cp.moving_waypoint = False
            if hasattr(cp, "ego_vehicle_id"):
                cp.ego_vehicle_id = None
            if hasattr(cp, "ego_vehicle_transform"):
                cp.ego_vehicle_transform = None
            if hasattr(cp, "ego_vehicle_blueprint"):
                cp.ego_vehicle_blueprint = None
            if hasattr(cp, "ego_vehicle_color"):
                cp.ego_vehicle_color = None

            if hasattr(cp, "loaded_scenario_data"):
                cp.loaded_scenario_data = None

            if hasattr(cp, "disable_manual_control"):
                try:
                    cp.disable_manual_control()
                except Exception:
                    pass

        # Reset editor/UI state
        self._reset_scenario_waypoint_preserve()
        self._clear_scenario_start_markers()
        if hasattr(self, "info_panel") and self.info_panel:
            try:
                self.info_panel.hide()
            except Exception:
                pass

        self.undo_stack.clear()
        self.redo_stack.clear()
        self.command_history.clear()

        self.saved_scene_vehicles = []
        self.scene_preview_destroyed = True

        disk_sig = self._compute_disk_scene_signature()
        self._saved_scene_signature = disk_sig
        self._saved_disk_signature = disk_sig
        self._scene_dirty_hint = False
        self._history_position = 0
        self._saved_history_position = 0

    def stop_scenario(self):
        """Stop the running scenario and restore original state"""
        try:
            print("Stopping scenario...")
            self.scenario_stop_requested = True

            mini_runner_active = False
            # Stop in-process MiniRunner if active
            mini_runner = getattr(self, "_mini_runner", None)
            if mini_runner and getattr(mini_runner, "is_running", False):
                print("[MiniRunner] Stop requested by user.")
                try:
                    mini_runner.request_stop()
                except Exception:
                    pass

                thread = getattr(mini_runner, "_thread", None)
                if thread and thread.is_alive():
                    try:
                        thread.join(timeout=5.0)
                    except Exception:
                        pass
                mini_runner_active = getattr(mini_runner, "is_running", False)
                if not mini_runner_active:
                    self._mini_runner = None
                else:
                    print("[MiniRunner] Runner is still stopping in background.")
                    # Avoid forcing cleanup from the UI thread while the runner thread is
                    # still active; CARLA API calls (apply_settings, map queries) are not
                    # thread-safe and can segfault during Play/Stop races.
                    mini_runner_active = True
            else:
                mini_runner_active = False

            # Terminate the scenario process if it exists
            if self.scenario_process and self.scenario_process.poll() is None:
                self.scenario_process.terminate()
                print("Scenario process terminated")

                # Wait a bit for graceful termination, then force kill if needed
                try:
                    self.scenario_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.scenario_process.kill()
                    print("Scenario process force killed")

            # Restore all scene vehicles (MiniRunner will handle restore via on_finish)
            if not mini_runner_active:
                self._restore_all_scene_vehicles_once()
                if self.camera_processor:
                    self.camera_processor.disable_manual_control()
                self._restore_start_weather_from_presets()

            # Clear scenario state
            self.scenario_process = None
            self.scenario_running = bool(mini_runner_active and getattr(mini_runner, "is_running", False))
            if self.scenario_running:
                print("Scenario stop requested (MiniRunner still shutting down).")
            else:
                print("Scenario stopped")

        except Exception as e:
            print(f"Error stopping scenario: {e}")
            # Still try to restore
            self._restore_all_scene_vehicles_once()
            if self.camera_processor:
                self.camera_processor.disable_manual_control()
            runner = getattr(self, "_mini_runner", None)
            self.scenario_running = bool(runner and getattr(runner, "is_running", False))
            self.scenario_process = None

    def _format_scenario_runner_output(self, text: Optional[str]) -> str:
        """Filter ScenarioRunner logs to soften non-critical destroy warnings."""
        if not text:
            return ""

        filtered_lines = []
        for line in text.splitlines():
            if "failed to destroy actor" in line.lower():
                parts = line.split()
                actor_id = next((token for token in parts if token.isdigit()), "?")
                filtered_lines.append(
                    f"[ScenarioRunner] Actor {actor_id} already removed; skipping redundant destroy."
                )
            else:
                filtered_lines.append(line)

        return "\n".join(filtered_lines)

    def _record_scenario_start_markers(self):
        """Capture marker positions for spawned scenario actors before relocation."""
        info_panel = getattr(self, "info_panel", None)
        if not info_panel:
            return

        markers = {}
        for actor in getattr(self, "spawned_vehicles", []):
            if not actor or not actor.is_alive:
                continue
            try:
                loc = actor.get_location()
            except RuntimeError:
                continue
            markers[actor.id] = {
                "x": loc.x,
                "y": loc.y,
                "z": loc.z,
                "vehicle_id": actor.id,
            }

        info_panel.scenario_starting_points = markers
        if markers:
            first_marker = next(iter(markers.values()))
            info_panel.scenario_starting_point = dict(first_marker)
        else:
            info_panel.scenario_starting_point = None

    def _clear_scenario_start_markers(self):
        """Remove any stored scenario start markers from the UI."""
        info_panel = getattr(self, "info_panel", None)
        if not info_panel:
            return
        info_panel.scenario_starting_points = {}
        info_panel.scenario_starting_point = None
    
    def _reset_scenario_traffic_light_preserve(self):
        """Clear any cached traffic light selection data preserved during ScenarioRunner playback."""
        self._scenario_preserved_traffic_light_ids = None
        self._scenario_preserved_traffic_light_info_visible = False
        self._scenario_active_traffic_light_trigger = None
        if self.camera_processor:
            self.camera_processor._scenario_active_traffic_light_trigger = None

    def _reset_scenario_waypoint_preserve(self, *, include_traffic: bool = True):
        """Clear any cached waypoint data preserved during ScenarioRunner playback."""
        self._scenario_preserved_waypoint_vehicle_id = None
        self._scenario_preserved_waypoints = None
        self._scenario_preserved_actor_blueprint = None
        self._scenario_preserved_actor_location = None
        self._scenario_preserved_actor_is_pedestrian = False
        self._scenario_preserved_info_panel_visible = False
        self._scenario_preserved_waypoint_signature = None
        self._scenario_preserved_traffic_lights_visible = False
        self._scenario_preserved_lane_overlay_enabled = False
        if include_traffic:
            self._reset_scenario_traffic_light_preserve()
        cp = getattr(self, "camera_processor", None)
        if cp and hasattr(cp, "_waypoint_ego_override_id"):
            cp._waypoint_ego_override_id = None

    def _restore_preserved_traffic_light_selection(self) -> bool:
        """Reapply traffic light selection after ScenarioRunner playback."""
        cp = self.camera_processor
        if not cp:
            return False

        ids = self._scenario_preserved_traffic_light_ids
        if not ids:
            self._reset_scenario_traffic_light_preserve()
            return False

        ids_set = set(ids)
        group = cp.selected_traffic_light_group

        if not group or group.ids != ids_set:
            group = next((g for g in cp.traffic_light_groups if g.ids == ids_set), None)
            if group is None:
                try:
                    cp._refresh_traffic_lights()
                except Exception:
                    pass
                group = next((g for g in cp.traffic_light_groups if g.ids == ids_set), None)
                if group is None:
                    return False
            cp.select_traffic_light_group(group)

        cp._update_traffic_light_menu_anchor(group)

        if self._scenario_preserved_traffic_light_info_visible:
            panel = getattr(self, "info_panel", None)
            if panel:
                panel.show(group, 'traffic_light', self.screen_width, self.screen_height)

        # Move the camera to the traffic light focus point, mirroring vehicle selection behavior.
        focus_location: Optional[carla.Location] = None

        def _valid(loc: Optional[carla.Location]) -> bool:
            if loc is None:
                return False
            try:
                if not (math.isfinite(loc.x) and math.isfinite(loc.y) and math.isfinite(loc.z)):
                    return False
                if abs(loc.x) + abs(loc.y) + abs(loc.z) < 0.5:
                    return False
            except Exception:
                return False
            return True

        # Prefer trigger center, then cached centroid, then recomputed trigger center.
        center = getattr(group, "trigger_center", None) or {}
        try:
            loc = carla.Location(
                float(center.get("x", 0.0)),
                float(center.get("y", 0.0)),
                float(center.get("z", 0.0)),
            )
            if _valid(loc):
                focus_location = loc
        except Exception:
            focus_location = None

        if focus_location is None:
            centroid = getattr(group, "center_location", None)
            if centroid and len(centroid) == 3:
                try:
                    loc = carla.Location(float(centroid[0]), float(centroid[1]), float(centroid[2]))
                    if _valid(loc):
                        focus_location = loc
                except Exception:
                    focus_location = None

        if focus_location is None:
            try:
                recomputed = cp._compute_traffic_light_group_trigger_center(group)
                if _valid(recomputed):
                    focus_location = recomputed
            except Exception:
                pass

        if focus_location and self._auto_camera_allowed():
            try:
                cp.focus_camera_on_location(focus_location)
            except Exception:
                pass

        self._reset_scenario_traffic_light_preserve()
        return True

    def _compute_waypoint_signature(self, waypoints: Optional[List[dict]]) -> Optional[Tuple]:
        """Create a coarse signature for a waypoint list for matching after reload."""
        if not waypoints:
            return None
        length = len(waypoints)
        first = waypoints[0]
        last = waypoints[-1]
        def _rounded(point, key):
            return round(float(point.get(key, 0.0)), 1)
        return (
            length,
            _rounded(first, 'x'), _rounded(first, 'y'), _rounded(first, 'z'),
            _rounded(last, 'x'), _rounded(last, 'y'), _rounded(last, 'z'),
        )

    def _restore_preserved_overlay_visibility(self) -> None:
        """Restore traffic light and OpenDRIVE overlay visibility after playback."""
        cp = self.camera_processor
        if not cp:
            print("[OVERLAY RESTORE] No camera processor")
            return

        # Restore traffic lights visibility
        traffic_was_visible = self._scenario_preserved_traffic_lights_visible
        print(f"[OVERLAY RESTORE] Traffic: was_visible={traffic_was_visible}, current={cp.traffic_lights_visible}")
        if traffic_was_visible and not cp.traffic_lights_visible:
            cp.traffic_lights_visible = True
            print("Traffic light overlay restored")
        elif traffic_was_visible and cp.traffic_lights_visible:
            print("[OVERLAY RESTORE] Traffic light overlay already visible")

        # Restore OpenDRIVE overlay visibility
        lane_was_enabled = self._scenario_preserved_lane_overlay_enabled
        print(f"[OVERLAY RESTORE] OpenDRIVE: was_enabled={lane_was_enabled}, current={cp.lane_overlay_enabled}")
        if lane_was_enabled and not cp.lane_overlay_enabled:
            cp.lane_overlay_enabled = True
            print("OpenDRIVE overlay restored")
            if not getattr(cp, 'opendrive_lane_data', None):
                OpenDriveOverlayRenderer.precompute_lane_data(cp)
            OpenDriveOverlayRenderer.invalidate_cache(cp, drop_surfaces=True)
        elif lane_was_enabled and cp.lane_overlay_enabled:
            print("[OVERLAY RESTORE] OpenDRIVE overlay already enabled")

    def _reselect_preserved_actor(self) -> bool:
        """Attempt to restore the actor selection after ScenarioRunner finishes."""
        cp = self.camera_processor
        if not cp:
            return False

        old_id = self._scenario_preserved_waypoint_vehicle_id
        preserved_waypoints = self._scenario_preserved_waypoints or []
        target_signature = self._scenario_preserved_waypoint_signature
        matched_actor = None
        matched_vehicle_id = None
        candidates = [
            actor for actor in cp.spawned_vehicles
            if actor and actor.is_alive
        ]

        def _valid_focus_location(loc: Optional[carla.Location], reference: Optional[Dict[str, float]] = None) -> bool:
            if loc is None:
                return False
            try:
                if not (math.isfinite(loc.x) and math.isfinite(loc.y) and math.isfinite(loc.z)):
                    return False
            except Exception:
                return False
            # Reject origin-ish locations that come from proto actors before AWmini ticks
            if abs(loc.x) + abs(loc.y) + abs(loc.z) < 0.5:
                return False
            if reference:
                try:
                    rx = float(reference.get("x", 0.0))
                    ry = float(reference.get("y", 0.0))
                    rz = float(reference.get("z", 0.0))
                    dx = loc.x - rx
                    dy = loc.y - ry
                    dz = loc.z - rz
                    if math.sqrt(dx * dx + dy * dy + dz * dz) < 0.25:
                        # Treat locations indistinguishable from the preserved point as still valid.
                        return True
                except Exception:
                    pass
            return True

        matched_from_signature = False
        if target_signature:
            for vehicle_id, waypoints in cp.waypoint_list.items():
                signature = self._compute_waypoint_signature(waypoints)
                if signature != target_signature:
                    continue

                candidate_actor = next(
                    (
                        actor
                        for actor in candidates
                        if actor.id == vehicle_id
                    ),
                    None,
                )

                matched_vehicle_id = vehicle_id
                if candidate_actor:
                    matched_actor = candidate_actor
                    matched_from_signature = True
                    break

        def waypoints_match(sequence_a, sequence_b, tol=1.0):
            if len(sequence_a) != len(sequence_b):
                return False
            for wp_a, wp_b in zip(sequence_a, sequence_b):
                if (
                    abs(float(wp_a.get('x', 0.0)) - float(wp_b.get('x', 0.0))) > tol
                    or abs(float(wp_a.get('y', 0.0)) - float(wp_b.get('y', 0.0))) > tol
                    or abs(float(wp_a.get('z', 0.0)) - float(wp_b.get('z', 0.0))) > tol
                ):
                    return False
            return True

        if preserved_waypoints and not matched_from_signature:
            for vehicle_id, waypoints in cp.waypoint_list.items():
                if not waypoints:
                    continue

                if not waypoints_match(preserved_waypoints, waypoints):
                    continue

                candidate_actor = next(
                    (
                        actor
                        for actor in cp.spawned_vehicles
                        if actor and actor.is_alive and actor.id == vehicle_id
                    ),
                    None,
                )

                if candidate_actor:
                    matched_vehicle_id = vehicle_id
                    matched_actor = candidate_actor
                    break

                if matched_vehicle_id is None and vehicle_id != old_id:
                    matched_vehicle_id = vehicle_id

        target_bp = self._scenario_preserved_actor_blueprint
        target_loc = self._scenario_preserved_actor_location

        if not matched_actor and target_bp:
            best_actor = None
            best_distance = float("inf")
            for actor in candidates:
                if actor.type_id != target_bp:
                    continue
                distance = float("inf")
                if target_loc:
                    try:
                        loc = actor.get_location()
                        dx = loc.x - target_loc.get('x', 0.0)
                        dy = loc.y - target_loc.get('y', 0.0)
                        dz = loc.z - target_loc.get('z', 0.0)
                        distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                    except Exception:
                        distance = float("inf")
                else:
                    distance = 0.0

                if distance < best_distance:
                    best_distance = distance
                    best_actor = actor

            if best_actor:
                matched_actor = best_actor
                matched_vehicle_id = best_actor.id

        if matched_actor:
            if cp.restore_actor_selection(matched_actor):
                focus_location: Optional[carla.Location] = None
                live_location_valid = False
                self._camera_debug(f"[CameraDebug] Restoring selection for actor {matched_actor.id} (old_id={old_id})")
                try:
                    loc = matched_actor.get_location()
                    if _valid_focus_location(loc, self._scenario_preserved_actor_location):
                        focus_location = loc
                        live_location_valid = True
                    else:
                        self._camera_debug(
                            f"[CameraDebug] Actor {matched_actor.id} location invalid/placeholder "
                            f"({getattr(loc, 'x', '?')}, {getattr(loc, 'y', '?')}, {getattr(loc, 'z', '?')}); "
                            "will use preserved position until a valid tick arrives."
                        )
                except Exception:
                    focus_location = None
                if focus_location is None and self._scenario_preserved_actor_location:
                    loc = self._scenario_preserved_actor_location
                    try:
                        focus_location = carla.Location(
                            float(loc.get("x", 0.0)),
                            float(loc.get("y", 0.0)),
                            float(loc.get("z", 0.0)),
                        )
                    except Exception:
                        focus_location = None
                if focus_location is None and self.camera_processor:
                    try:
                        original = self.camera_processor.get_actor_original_json_position(
                            matched_actor.type_id,
                            "vehicle" if not self._scenario_preserved_actor_is_pedestrian else "pedestrian",
                        )
                        if original:
                            focus_location = original.location
                    except Exception:
                        focus_location = None

                if focus_location:
                    if self._auto_camera_allowed():
                        cp.focus_camera_on_location(focus_location)  # Snap camera to the restored selection
                        try:
                            self._camera_debug(
                                "[CameraDebug] Focused on restored actor "
                                f"{matched_actor.id} at ({focus_location.x:.2f}, {focus_location.y:.2f}, {focus_location.z:.2f})"
                            )
                        except Exception:
                            self._camera_debug("[CameraDebug] Focused on restored actor (coords unavailable)")
                    cp.refresh_selected_vehicle_ui()
                    if old_id and old_id != matched_actor.id:
                        cp.waypoint_list.pop(old_id, None)
                    panel = getattr(self, "info_panel", None)
                    if (
                        panel
                        and self._scenario_preserved_info_panel_visible
                    ):
                        obj_type = (
                            'pedestrian'
                            if self._scenario_preserved_actor_is_pedestrian
                            else 'vehicle'
                        )
                        panel.show(matched_actor, obj_type, self.screen_width, self.screen_height)
                    if live_location_valid:
                        # Selection fully restored with a valid actor location; clear preserved state.
                        self._reset_scenario_waypoint_preserve(include_traffic=False)
                        return True
                    # Keep preserved state so we can retry once AWmini provides a real transform.
                    self._scenario_pending_actor_reselect = True
                    return False
                # If we get here, keep preserved state so we can retry when the actor/location becomes available.
                self._camera_debug(
                    "[CameraDebug] Restored actor selection but no focus location yet; "
                    "will keep retrying."
                )
                self._scenario_pending_actor_reselect_attempts = 0
                return False

        if matched_vehicle_id:
            cp.waypoint_display_vehicle_id = matched_vehicle_id
            if old_id and old_id != matched_vehicle_id:
                cp.waypoint_list.pop(old_id, None)
            try:
                cp.refresh_waypoints_carla_debug()
            except Exception:
                pass

        return False

    def _process_pending_actor_reselect(self):
        """Retry actor reselection across frames when immediate restoration fails."""
        if not self._scenario_pending_actor_reselect:
            return
        if not self.camera_processor:
            return

        self._reselect_preserved_actor()
        self._restore_preserved_traffic_light_selection()

        actor_pending = self._scenario_preserved_waypoint_vehicle_id is not None
        traffic_pending = self._scenario_preserved_traffic_light_ids is not None

        if not actor_pending and not traffic_pending:
            self._reset_scenario_waypoint_preserve()
            self._scenario_pending_actor_reselect = False
            self._scenario_pending_actor_reselect_attempts = 0
            return

        self._scenario_pending_actor_reselect_attempts += 1
        if (
            self._scenario_pending_actor_reselect_attempts
            >= self._scenario_pending_actor_reselect_max_attempts
        ):
            print("[Scenario] Gave up restoring previous selection after ScenarioRunner playback.")
            self._reset_scenario_waypoint_preserve()
            self._scenario_pending_actor_reselect = False

    def _save_all_scene_vehicles(self):
        """Save and move all vehicles and pedestrians in the scene to avoid conflicts"""
        try:
            self.saved_scene_vehicles = []

            if not self.camera_processor or not hasattr(self.camera_processor, 'world'):
                print("ERROR: Cannot access world through camera_processor")
                return

            world = self.camera_processor.world

            # Get all vehicles and pedestrians currently in the scene
            all_vehicles = world.get_actors().filter('vehicle.*')
            all_walkers = world.get_actors().filter('walker.*')
            all_actors = list(all_vehicles) + list(all_walkers)
            print(f"\n=== SCENE ACTOR MANAGEMENT ===")
            print(f"Found {len(all_vehicles)} vehicles and {len(all_walkers)} pedestrians in scene to save (total: {len(all_actors)})")

            expected_roles = self._expected_ego_roles()
            ego_actor = self._refresh_external_ego_actor_reference()
            ego_actor_id = ego_actor.id if ego_actor else None

            if ego_actor_id is not None and self.camera_processor:
                print("External ego present; removing preview actors before scenario launch.")
                self.camera_processor.cleanup_all_vehicles(
                    preserve_ids={ego_actor_id},
                    preserve_ego=True,
                )
                self.saved_scene_vehicles = []
                self.scene_preview_destroyed = True
                print("Preview actors removed. ScenarioRunner will spawn fresh actors.")
                print("Successfully saved and moved 0 actors (vehicles and pedestrians) away from scenario area")
                print(f"=== END SCENE ACTOR MANAGEMENT ===\n")
                return

            # No external ego actor: drop preview actors and rebuild from file after the run.
            if self.camera_processor:
                self.camera_processor.cleanup_all_vehicles()
                if hasattr(self.camera_processor, "spawned_vehicles"):
                    self.camera_processor.spawned_vehicles.clear()
            self.saved_scene_vehicles = []
            self.scene_preview_destroyed = True
            print("Preview actors removed. ScenarioRunner will spawn fresh actors.")
            print("Successfully saved and moved 0 actors (vehicles and pedestrians) away from scenario area")
            print(f"=== END SCENE ACTOR MANAGEMENT ===\n")

        except Exception as e:
            print(f"ERROR in _save_all_scene_vehicles: {e}")
            traceback.print_exc()
            self.saved_scene_vehicles = []

    def _restore_scene_preview_if_destroyed(self, focus_fn: Callable[[], None]) -> bool:
        if not self.scene_preview_destroyed:
            return False
        print("Rebuilding scenario preview from saved file...")
        self.scene_preview_destroyed = False
        self.saved_scene_vehicles = []
        if (
            self.current_scenario_path
            and os.path.isfile(self.current_scenario_path)
            and self.camera_processor
        ):
            preserve_camera = self._scenario_preserved_waypoint_vehicle_id is not None
            preserve_reason = "actor preserved" if preserve_camera else ""
            if not preserve_camera:
                try:
                    if self.camera_processor.manual_control_enabled:
                        preserve_camera = True
                        preserve_reason = "manual control enabled"
                    elif self.camera_processor.manual_control_pending:
                        preserve_camera = True
                        preserve_reason = "manual control pending"
                    elif getattr(self.camera_processor, "ego_vehicle_transform", None) is not None:
                        preserve_camera = True
                        preserve_reason = "ego transform cached"
                except Exception as exc:
                    self._camera_debug(f"[CameraDebug] Failed to evaluate preserve_camera heuristics: {exc}")
            self._debug_camera_pose("restore-preload")
            self._camera_debug(
                f"[CameraDebug] Reload preview preserve_camera={preserve_camera} reason={preserve_reason or 'none'}"
            )
            self.camera_processor.load_waypoint_data_from_file(
                self.current_scenario_path,
                preserve_camera=preserve_camera,
            )
            try:
                scenario_data = getattr(self.camera_processor, "loaded_scenario_data", None)
                if not scenario_data and os.path.isfile(self.current_scenario_path):
                    with open(self.current_scenario_path, "r", encoding="utf-8") as fh:
                        scenario_data = json.load(fh)
                if scenario_data:
                    self._apply_weather_from_json_data(scenario_data)
            except Exception as exc:
                print(f"[Weather] Failed to restore weather from scenario: {exc}")
            selection_restored = self._reselect_preserved_actor()
            traffic_preserve = bool(self._scenario_preserved_traffic_light_ids)
            traffic_restored = (
                traffic_preserve and self._restore_preserved_traffic_light_selection()
            )
        else:
            print("No scenario file available to reload preview.")
            selection_restored = False
            traffic_restored = False
        if self.camera_processor:
            self.camera_processor.disable_manual_control()
            # Restore overlay visibility state
            self._restore_preserved_overlay_visibility()
        # Remove any preserved start markers so the placeholder square disappears after playback.
        self._clear_scenario_start_markers()
        actor_pending = self._scenario_preserved_waypoint_vehicle_id is not None
        traffic_pending = self._scenario_preserved_traffic_light_ids is not None

        if (selection_restored or traffic_restored) and not actor_pending:
            self._reset_scenario_waypoint_preserve(include_traffic=False)

        actor_pending = self._scenario_preserved_waypoint_vehicle_id is not None
        traffic_pending = self._scenario_preserved_traffic_light_ids is not None

        if (
            not selection_restored
            and not traffic_restored
            and not actor_pending
            and not traffic_pending
        ):
            self._debug_camera_pose("restore-pre-ego")
            focus_fn()
        else:
            self._debug_camera_pose("restore-skip-ego")

        if actor_pending or traffic_pending:
            self._scenario_pending_actor_reselect = True
            self._scenario_pending_actor_reselect_attempts = 0
        else:
            self._scenario_pending_actor_reselect = False
            self._scenario_pending_actor_reselect_attempts = 0
            self._reset_scenario_waypoint_preserve()
        return True

    def _restore_without_saved_actors(self, focus_fn: Callable[[], None]) -> bool:
        if self.saved_scene_vehicles:
            return False
        print("No saved actors to restore")
        if self.camera_processor:
            selection_restored = self._reselect_preserved_actor()
            traffic_preserve = bool(self._scenario_preserved_traffic_light_ids)
            traffic_restored = (
                traffic_preserve and self._restore_preserved_traffic_light_selection()
            )
            self.camera_processor.disable_manual_control()
            # Restore overlay visibility state
            self._restore_preserved_overlay_visibility()
        else:
            selection_restored = False
            traffic_restored = False

        actor_pending = self._scenario_preserved_waypoint_vehicle_id is not None
        traffic_pending = self._scenario_preserved_traffic_light_ids is not None

        if (selection_restored or traffic_restored) and not actor_pending:
            self._reset_scenario_waypoint_preserve(include_traffic=False)

        actor_pending = self._scenario_preserved_waypoint_vehicle_id is not None
        traffic_pending = self._scenario_preserved_traffic_light_ids is not None

        if (
            not selection_restored
            and not traffic_restored
            and not actor_pending
            and not traffic_pending
        ):
            self._debug_camera_pose("restore-pre-ego-nosave2")
            focus_fn()

        print(f"Attempting to restore {len(self.saved_scene_vehicles)} actors (vehicles and pedestrians)")
        restored_count = 0
        for actor_data in self.saved_scene_vehicles:
            try:
                actor = actor_data['actor']
                if actor and actor.is_alive:
                    original_transform = actor_data['transform']
                    actor_type = "Vehicle" if actor.type_id.startswith('vehicle.') else "Pedestrian"
                    print(f"Restoring {actor_type.lower()} {actor.id} to ({original_transform.location.x:.1f}, {original_transform.location.y:.1f}, {original_transform.location.z:.1f})")

                    # Restore position
                    actor.set_transform(original_transform)
                    physics_enabled = actor_data.get('physics_enabled', True)
                    try:
                        actor.set_simulate_physics(physics_enabled)
                    except Exception:
                        pass
                    if actor.type_id.startswith('vehicle.'):
                        velocity = actor_data.get('velocity')
                        angular_velocity = actor_data.get('angular_velocity')
                        if velocity is not None:
                            try:
                                actor.set_velocity(velocity)
                            except Exception:
                                pass
                        if angular_velocity is not None:
                            try:
                                actor.set_angular_velocity(angular_velocity)
                            except Exception:
                                pass
                    restored_count += 1
                else:
                    print(f"Warning: Saved actor no longer exists or is not alive")

            except Exception as e:
                print(f"Error restoring individual actor: {e}")

        print(f"Successfully restored {restored_count} actors (vehicles and pedestrians) to original positions")
        print(f"=== END RESTORING SCENE ACTORS ===\n")
        self.saved_scene_vehicles = []
        self._clear_scenario_start_markers()
        external_restored = False
        if self.camera_processor:
            self._debug_camera_pose("restore-post-actors")
            # If an external ego is active/alive, restore it to the pre-run transform instead of clearing it.
            external_actor = self._refresh_external_ego_actor_reference()
            if external_actor and external_actor.is_alive:
                target_tf = (
                    self._external_swap_pre_run_transform
                    or getattr(self.camera_processor, "ego_vehicle_transform", None)
                    or getattr(external_actor, "get_transform", lambda: None)()
                )
                if target_tf:
                    try:
                        external_actor.set_transform(target_tf)
                        external_actor.set_target_velocity(carla.Vector3D())
                        external_actor.set_target_angular_velocity(carla.Vector3D())
                        external_actor.set_simulate_physics(True)
                        self.camera_processor.register_ego_vehicle(
                            external_actor, target_tf, getattr(self, "_external_swap_last_color", None)
                        )
                        self.camera_processor.selected_vehicle = external_actor
                        self.camera_processor.selected_vehicle_is_pedestrian = False
                        external_restored = True
                        self._external_swap_active = True
                        self._external_swap_current_id = external_actor.id
                        self.external_ego_actor = external_actor
                        self.external_ego_actor_id = external_actor.id
                        # Also enable rendering when restoring external ego (normal maps only)
                        if not getattr(self, 'large_map_active', False):
                            try:
                                self._apply_rendering_mode(
                                    desired_enabled=True,
                                    reason="external ego restored",
                                    force=False
                                )
                            except Exception as rendering_exc:
                                print(f"[Scenario] Warning: failed to enable rendering for external ego: {rendering_exc}")
                    except Exception:
                        external_restored = False
            selection_restored = self._reselect_preserved_actor()
            traffic_preserve = bool(self._scenario_preserved_traffic_light_ids)
            traffic_restored = (
                traffic_preserve and self._restore_preserved_traffic_light_selection()
            )
            self.camera_processor.disable_manual_control()
            # Restore overlay visibility state
            self._restore_preserved_overlay_visibility()
        else:
            selection_restored = False
            traffic_restored = False
        if not external_restored:
            self.external_ego_actor = None
            self.external_ego_actor_id = None
            self._external_swap_active = False
            self._external_swap_current_id = None
            self._external_swap_last_transform = None
            self._external_swap_last_blueprint = None
            self._external_swap_last_color = None
        self._external_swap_pre_run_transform = None

        actor_pending = self._scenario_preserved_waypoint_vehicle_id is not None
        traffic_pending = self._scenario_preserved_traffic_light_ids is not None

        if (selection_restored or traffic_restored) and not actor_pending:
            self._reset_scenario_waypoint_preserve(include_traffic=False)

        # Recompute pending states after potential reset operations
        actor_pending = self._scenario_preserved_waypoint_vehicle_id is not None
        traffic_pending = self._scenario_preserved_traffic_light_ids is not None

        if (
            not selection_restored
            and not traffic_restored
            and not actor_pending
            and not traffic_pending
        ):
            self._debug_camera_pose("restore-pre-ego-nosave")
            focus_fn()

        if actor_pending or traffic_pending:
            self._scenario_pending_actor_reselect = True
            self._scenario_pending_actor_reselect_attempts = 0
        else:
            self._scenario_pending_actor_reselect = False
            self._scenario_pending_actor_reselect_attempts = 0
            self._reset_scenario_waypoint_preserve()
        return True

    def _restore_all_scene_vehicles_once(self):
        """Run restore only once per scenario run to avoid duplicate reloads."""
        with self._restore_once_lock:
            if getattr(self, "_restore_invoked_for_run", False):
                self._debug_camera_pose("restore-skip")
                print("[Restore] Already completed for this run; skipping.")
                return
            self._restore_invoked_for_run = True
        self._restore_all_scene_vehicles()

    def _restore_all_scene_vehicles(self):
        """Restore all saved vehicles and pedestrians to their original positions"""
        if getattr(self, "_restore_in_progress", False):
            self._debug_camera_pose("restore-nested-skip")
            print("[Restore] Already in progress; skipping nested call.")
            return
        self._debug_camera_pose("restore-start")
        self._restore_in_progress = True
        focus_attempted = False

        # Pre-position the camera near the last known ego to avoid visible jumps from the manual-control follow offset.
        try:
            if self._auto_camera_allowed() and self.camera_controller and self.camera_processor:
                ego_tf = getattr(self.camera_processor, "ego_vehicle_transform", None)
                if ego_tf:
                    self.camera_controller.center_x = ego_tf.location.x
                    self.camera_controller.center_y = ego_tf.location.y
                    self._debug_camera_pose("restore-prealign-ego")
        except Exception:
            pass

        def _focus_ego_once():
            nonlocal focus_attempted
            if focus_attempted:
                return
            if not self._auto_camera_allowed():
                return
            focus_attempted = True
            try:
                self._focus_camera_on_ego_vehicle()
            except Exception:
                pass

        try:
            print(f"\n=== RESTORING SCENE ACTORS ===")
            if self._restore_scene_preview_if_destroyed(_focus_ego_once):
                return

            if self._restore_without_saved_actors(_focus_ego_once):
                return

        except Exception as e:
            print(f"ERROR in _restore_all_scene_vehicles: {e}")
            traceback.print_exc()
            self.saved_scene_vehicles = []
            self._clear_scenario_start_markers()
            if self.camera_processor:
                self.camera_processor.disable_manual_control()
            self.external_ego_actor = None
            self.external_ego_actor_id = None
            self._external_swap_active = False
            self._external_swap_current_id = None
            self._external_swap_last_transform = None
            self._external_swap_last_blueprint = None
            self._external_swap_last_color = None
            self._reset_scenario_waypoint_preserve()
        finally:
            self._restore_in_progress = False
            self._debug_camera_pose("restore-end")
    def _get_map_display_name(self):
        """Return a short map identifier for UI display."""
        if not self.world_map or not self.world_map.name:
            return "Unknown"
        return self.world_map.name.split('/')[-1]

    def _resolve_default_map_directory(self):
        """Determine the default directory used by the map selection dialog."""
        carla_root = os.environ.get('CARLA_ROOT')
        if carla_root:
            candidates = [
                os.path.join(carla_root, 'CarlaUE4', 'Content', 'Carla', 'Maps'),
                os.path.join(carla_root, 'CarlaUE4', 'Content', 'Carla', 'Map'),
            ]
            for candidate in candidates:
                if os.path.isdir(candidate):
                    return candidate
        return os.getcwd()

    def show_open_map_dialog(self):
        """Show the map selection menu to allow the user to select a new CARLA map."""
        if self.scenario_running:
            print("Cannot change map while a scenario is running. Stop the scenario first.")
            return

        if self.map_menu:
            was_open = self.map_menu_visible
            self._close_all_dropdowns()
            self.map_menu_visible = not was_open
            if self.map_menu_visible:
                self.map_menu.initialize()
                self.map_menu.scroll_offset = 0
        else:
            print("Map menu not initialized yet.")

    def show_open_scenario_dialog(self):
        """Show the scenario selection menu to allow the user to save or load scenarios."""
        if self.scenario_running:
            print("Cannot open scenario menu while a scenario is running. Stop the scenario first.")
            return

        # Toggle the scenario menu visibility
        if self.scenario_menu:
            was_open = self.scenario_menu_visible
            self._close_all_dropdowns()
            self.scenario_menu_visible = not was_open
        else:
            print("Scenario menu not initialized yet.")

    def _scene_has_content(self) -> bool:
        """Return True if the editor currently holds any scenario data."""
        cp = self.camera_processor
        if not cp:
            return False

        if any(cp.waypoint_list.values()):
            return True

        if getattr(cp, "triggers", None):
            return True

        spawned = getattr(cp, "spawned_vehicles", None)
        if spawned and any(actor for actor in spawned if actor):
            return True

        if getattr(cp, "loaded_scenario_data", None):
            return True

        traffic_triggers = getattr(cp, "traffic_light_groups", None)
        if traffic_triggers:
            if any(
                getattr(group, "trigger_center", None) or getattr(group, "trigger_radius", None)
                for group in traffic_triggers
            ):
                return True

        return False

    def _scene_signature_from_payload(self, payload: Optional[dict], *, context: str = "") -> Optional[str]:
        """Return a deterministic signature for a scenario payload."""
        if not payload or not isinstance(payload, dict):
            return None
        try:
            data = dict(payload)
            data.pop("timestamp", None)
            return json.dumps(data, sort_keys=True, ensure_ascii=True)
        except Exception as exc:
            label = f" [{context}]" if context else ""
            print(f"[Scene] Unable to compute signature{label}: {exc}")
            return None

    def _compute_scene_signature(self) -> Optional[str]:
        """Return a deterministic signature of the current scene for dirty-checking."""
        cp = self.camera_processor
        if not cp:
            return None

        try:
            map_obj = self._safe_get_world_map(refresh=False)
            if map_obj:
                full_map_name = map_obj.name
                map_name = full_map_name.split('/')[-1] if '/' in full_map_name else full_map_name
            else:
                map_name = "unknown"

            snapshot, _ego = cp._collect_scenario_snapshot(map_name)
            return self._scene_signature_from_payload(snapshot, context="current")
        except Exception as exc:
            print(f"[Scene] Unable to compute scene signature: {exc}")
            return None

    def _compute_disk_scene_signature(self) -> Optional[str]:
        """Return the signature of the on-disk scenario JSON, if available."""
        path = self.current_scenario_path
        if not path or not os.path.isfile(path):
            return None
        try:
            with open(path, "r", encoding="utf-8") as handle:
                payload = json.load(handle)
            if not isinstance(payload, dict):
                return None
            return self._scene_signature_from_payload(payload, context="disk")
        except Exception as exc:
            print(f"[Scene] Unable to read scenario from disk for signature: {exc}")
            return None

    def _mark_scene_saved(
        self,
        live_signature: Optional[str] = None,
        disk_signature: Optional[str] = None,
    ):
        """Record that the current scene matches saved state (live and disk snapshots)."""
        self._saved_scene_signature = live_signature if live_signature is not None else self._compute_scene_signature()
        self._saved_disk_signature = disk_signature if disk_signature is not None else self._compute_disk_scene_signature()
        self._scene_dirty_hint = False
        self._saved_history_position = self._history_position

    def _mark_scene_dirty(self):
        """Flag that the scene has pending edits."""
        self._scene_dirty_hint = True
        # Only bump the history position if we're not already dirty from a prior edit.
        # Selection/highlight operations should not call this.
        self._history_position += 1

    def _has_unsaved_changes(self) -> bool:
        """Best-effort detection of scenario edits that haven't been written to disk."""
        if not self._scene_has_content():
            return False

        # If no file path is set, any content counts as unsaved.
        if not self.current_scenario_path or not os.path.isfile(self.current_scenario_path):
            return True

        # Dirty only when the edit pointer diverges from the last saved pointer.
        return self._history_position != self._saved_history_position

    def _confirm_new_scenario(self) -> bool:
        """Prompt the user before discarding the current scenario."""
        if not self.ui_manager:
            return True

        dialog_rect = self._center_dialog_rect(420, 220)
        dialog = UIConfirmationDialog(
            rect=dialog_rect,
            action_long_desc=(
                "Starting a new scenario will clear all placed actors, waypoints, and triggers.<br><br>"
                "All unsaved changes will be lost."
            ),
            manager=self.ui_manager,
            window_title="New Scenario",
            action_short_name="Reset",
            blocking=True,
        )

        def handler(event: pygame.event.Event):
            if event.type == UI_CONFIRMATION_DIALOG_CONFIRMED and event.ui_element == dialog:
                return True, True
            if event.type == UI_BUTTON_PRESSED and event.ui_element == dialog.confirm_button:
                return True, True
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, False
            return False, None

        result = self._run_modal_window(dialog, handler)
        return bool(result)

    def _confirm_load_scenario_discard(self) -> bool:
        """Prompt before loading a scenario that will discard unsaved changes."""
        if not self.ui_manager:
            return True

        self._close_all_dropdowns(keep_info_panel=True)
        dialog_rect = self._center_dialog_rect(420, 220)
        dialog = UIConfirmationDialog(
            rect=dialog_rect,
            action_long_desc=(
                "Loading a scenario will replace the current scene.<br><br>"
                "All unsaved changes will be lost."
            ),
            manager=self.ui_manager,
            window_title="Load Scenario",
            action_short_name="Load",
            blocking=True,
        )

        def handler(event: pygame.event.Event):
            if event.type == UI_CONFIRMATION_DIALOG_CONFIRMED and event.ui_element == dialog:
                return True, True
            if event.type == UI_BUTTON_PRESSED and event.ui_element == dialog.confirm_button:
                return True, True
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, False
            return False, None

        result = self._run_modal_window(dialog, handler)
        return bool(result)

    def _confirm_play_discard_changes(self) -> bool:
        """Prompt the user before discarding unsaved edits to play the saved scenario."""
        if not self.ui_manager:
            return True

        self._close_all_dropdowns(keep_info_panel=True)
        dialog_rect = self._center_dialog_rect(380, 200)
        dialog = UIConfirmationDialog(
            rect=dialog_rect,
            action_long_desc=(
                "Are you sure you want to play the scenario?<br><br>"
                "All unsaved changes will be lost."
            ),
            manager=self.ui_manager,
            window_title="Play Confirmation",
            action_short_name="Yes",
            blocking=True,
        )

        def handler(event: pygame.event.Event):
            if event.type == UI_CONFIRMATION_DIALOG_CONFIRMED and event.ui_element == dialog:
                return True, True
            if event.type == UI_BUTTON_PRESSED and event.ui_element == dialog.confirm_button:
                return True, True
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, False
            return False, None

        result = self._run_modal_window(dialog, handler)
        return bool(result)

    def _reset_camera_view_to_origin(self):
        """Move the editor camera back to the default world origin."""
        if not self._auto_camera_allowed():
            return
        if not (self.camera_processor and self.camera_controller):
            return

        default_height = getattr(self.camera_controller, "height", 200.0)
        try:
            self.camera_controller.height = default_height
            self.camera_processor.focus_camera_on_location(carla.Location(x=0.0, y=0.0, z=default_height))
        except Exception as exc:
            print(f"[Scenario] Warning: failed to reset camera position: {exc}")

    def reset_current_scenario(self) -> bool:
        """Clear the active scene and return to a blank scenario canvas."""
        if self.scenario_running:
            print("Cannot start a new scenario while Scenario Runner is running. Stop it first.")
            return False

        if not self.camera_processor:
            print("Camera processor not initialized yet.")
            return False

        if self._has_unsaved_changes():
            if not self._confirm_new_scenario():
                print("New scenario cancelled by user.")
                return False

        print("Resetting scenario to a blank state...")

        previous_suppress = bool(getattr(self, "_suppress_external_ego_adoption", False))
        self._suppress_external_ego_adoption = True
        preserved_external: Optional[carla.Actor] = None

        try:
            self.camera_processor._reset_scenario_state()
            self.camera_processor.disable_manual_control()
            if hasattr(self.camera_processor, "loaded_scenario_data"):
                self.camera_processor.loaded_scenario_data = None
            preserved_external = self._refresh_external_ego_actor_reference()
        except Exception as exc:
            print(f"[Scenario] Warning: failed to clear existing scene: {exc}")
        finally:
            self._suppress_external_ego_adoption = previous_suppress

        self.saved_scene_vehicles = []
        if preserved_external and getattr(preserved_external, "is_alive", False):
            self.external_ego_actor = preserved_external
            self.external_ego_actor_id = preserved_external.id
        else:
            self.external_ego_actor = None
            self.external_ego_actor_id = None
        self._external_swap_active = False
        self._external_swap_current_id = None
        self._external_swap_last_transform = None
        self._external_swap_last_blueprint = None
        self._external_swap_last_color = None
        self._external_ego_prompt_pending_id = None
        self.pending_scenario_load = None
        self.current_scenario_name = None
        self.current_scenario_path = None
        self.command_history.clear()
        self.undo_stack.clear()
        self.redo_stack.clear()
        self._reset_scenario_waypoint_preserve()
        self._clear_scenario_start_markers()
        self._scenario_pending_actor_reselect = False
        self._scenario_pending_actor_reselect_attempts = 0

        if self.info_panel:
            self.info_panel.hide()

        self.scenario_menu_visible = False

        self._reset_camera_view_to_origin()
        self._reset_weather_to_baseline()

        self._saved_scene_signature = None
        self._saved_disk_signature = None
        self._scene_dirty_hint = False
        self._history_position = 0
        self._saved_history_position = 0

        print("Scenario reset complete.")
        return True

    def _scenario_has_playable_content(self) -> bool:
        """Return True if the scene has any playable route or a manual-control ego."""
        cp = self.camera_processor
        if not cp:
            return False

        waypoint_map = getattr(cp, "waypoint_list", {}) or {}
        spawned = getattr(cp, "spawned_vehicles", None) or []

        for actor in spawned:
            if not actor or not actor.is_alive:
                continue
            waypoints = waypoint_map.get(actor.id)
            if waypoints:
                return True

        # Allow manual-control runs when an ego exists without a route.
        try:
            if cp.is_ego_vehicle_active() or cp.get_editor_ego_actor():
                return True
        except Exception:
            pass

        # Fallback to scenario JSON for ego presence (e.g., external ego workflows).
        scenario_data = getattr(cp, "loaded_scenario_data", None)
        if not scenario_data and self.current_scenario_path and os.path.isfile(self.current_scenario_path):
            try:
                with open(self.current_scenario_path, "r", encoding="utf-8") as fh:
                    scenario_data = json.load(fh)
            except Exception:
                scenario_data = None
        if scenario_data:
            if scenario_data.get("ego_vehicle"):
                return True
            for entry in scenario_data.get("vehicles", []):
                if str(entry.get("role", "")).lower() == "ego_vehicle":
                    return True

        return False

    def _should_show_manual_only_hint(self) -> bool:
        """Return True if playback will be manual-only due to a missing ego route."""
        if self.scenario_running or (self.scenario_process and self.scenario_process.poll() is None):
            return False
        cp = self.camera_processor
        if not cp:
            return False

        ego_id = getattr(cp, "ego_vehicle_id", None)
        if ego_id is not None:
            try:
                waypoints = cp.get_vehicle_waypoints(ego_id)
            except Exception:
                waypoints = None
            if not waypoints:
                return True

        scenario_data = getattr(cp, "loaded_scenario_data", None)
        if not isinstance(scenario_data, dict):
            return False
        ego_entry = scenario_data.get("ego_vehicle")
        if isinstance(ego_entry, dict):
            waypoints = ego_entry.get("waypoints", [])
            return not (isinstance(waypoints, list) and waypoints)
        if isinstance(ego_entry, list):
            for entry in ego_entry:
                if isinstance(entry, dict):
                    waypoints = entry.get("waypoints", [])
                    if not (isinstance(waypoints, list) and waypoints):
                        return True
        return False

    def _get_last_remote_cache_path(self) -> Path:
        """Return the cache path for storing the last remote host/port."""
        return self._get_vse_cache_dir() / 'last_remote.json'

    def _get_vse_cache_dir(self) -> Path:
        """Return the base cache directory for VSE."""
        cache_base = os.environ.get('XDG_CACHE_HOME')
        if not cache_base:
            cache_base = os.path.join(Path.home(), '.cache')
        return Path(cache_base) / 'vse'

    def _load_last_remote_cache(self) -> None:
        """Load cached remote host/port if available."""
        self.last_remote_host: Optional[str] = None
        self.last_remote_port: Optional[str] = None
        cache_path = self._get_last_remote_cache_path()
        if not cache_path.is_file():
            return
        try:
            data = json.loads(cache_path.read_text())
            if isinstance(data, dict):
                host = data.get('host')
                port = data.get('port')
                if host:
                    self.last_remote_host = str(host)
                if port is not None and str(port).strip():
                    self.last_remote_port = str(port)
        except Exception as exc:
            print(f"[Remote Cache] Failed to load last remote entry: {exc}")
            try:
                cache_path.unlink()
            except Exception:
                pass

    def _remember_last_remote(self, host: str, port: Union[str, int, None]) -> None:
        """Persist the most recent remote host/port selection."""
        cache_path = self._get_last_remote_cache_path()
        try:
            cache_path.parent.mkdir(parents=True, exist_ok=True)
            payload = {
                'host': host or '',
                'port': str(port) if port is not None else '',
            }
            cache_path.write_text(json.dumps(payload))
            self.last_remote_host = payload['host']
            self.last_remote_port = payload['port']
        except Exception as exc:
            print(f"[Remote Cache] Failed to write last remote entry: {exc}")

    def _get_last_agent_cache_path(self) -> Path:
        """Return the cache path for storing the last selected playback agent."""
        return self._get_vse_cache_dir() / 'last_agent.json'

    def _load_last_agent_cache(self) -> None:
        """Load cached playback agent path if available."""
        self.agent_path: Optional[str] = None
        cache_path = self._get_last_agent_cache_path()
        if not cache_path.is_file():
            return
        try:
            data = json.loads(cache_path.read_text())
            path = data.get('path') if isinstance(data, dict) else None
        except Exception:
            path = None
        if path and os.path.isfile(path):
            self.agent_path = os.path.abspath(path)
            return
        self._clear_last_agent_cache(remove_file=True)

    def _remember_last_agent(self, agent_path: str) -> None:
        """Persist the most recently used playback agent path."""
        if not agent_path or not os.path.isfile(agent_path):
            self._clear_last_agent_cache(remove_file=True)
            return
        norm_path = os.path.abspath(agent_path)
        cache_path = self._get_last_agent_cache_path()
        self.agent_path = norm_path
        try:
            cache_path.parent.mkdir(parents=True, exist_ok=True)
            cache_path.write_text(json.dumps({
                'path': norm_path,
                'directory': os.path.dirname(norm_path),
                'updated': time.time()
            }))
        except Exception:
            pass

    def _clear_last_agent_cache(self, *, remove_file: bool = False) -> None:
        """Clear cached playback agent path but preserve directory."""
        self.agent_path = None
        if remove_file:
            cache_path = self._get_last_agent_cache_path()
            try:
                # Read existing data to preserve directory
                existing_dir = None
                if cache_path.is_file():
                    data = json.loads(cache_path.read_text())
                    existing_dir = data.get('directory') or (
                        os.path.dirname(data.get('path', '')) if data.get('path') else None
                    )
                if existing_dir and os.path.isdir(existing_dir):
                    # Keep only directory info
                    cache_path.write_text(json.dumps({'directory': existing_dir}))
                else:
                    cache_path.unlink(missing_ok=True)
            except Exception:
                pass

    def _get_last_agent_directory(self) -> Optional[str]:
        """Return the last used agent directory from cache, if available."""
        cache_path = self._get_last_agent_cache_path()
        if not cache_path.is_file():
            return None
        try:
            data = json.loads(cache_path.read_text())
            directory = data.get('directory')
            if not directory and data.get('path'):
                directory = os.path.dirname(data['path'])
            if directory and os.path.isdir(directory):
                return directory
        except Exception:
            pass
        return None

    def _get_last_scenario_cache_path(self) -> Path:
        """Return the cache path for storing the recent scenario reference."""
        return self._get_vse_cache_dir() / 'last_scenario.json'

    def _load_last_scenario_cache(self) -> None:
        """Load cached recent scenario reference from disk if available."""
        cache_path = self._get_last_scenario_cache_path()
        if not cache_path.is_file():
            return
        try:
            data = json.loads(cache_path.read_text())
            entries_raw = []
            if isinstance(data, dict) and 'recent' in data:
                entries_raw = data.get('recent', [])
            elif isinstance(data, dict) and 'path' in data:
                entries_raw = [data]
            elif isinstance(data, list):
                entries_raw = data

            recent: List[Dict[str, str]] = []
            seen_paths: Set[str] = set()
            for raw in entries_raw:
                path = raw.get('path') if isinstance(raw, dict) else None
                name = raw.get('name') if isinstance(raw, dict) else None
                map_name = raw.get('map_name') if isinstance(raw, dict) else None
                if not path:
                    continue
                norm_path = os.path.abspath(path)
                if norm_path in seen_paths:
                    continue
                seen_paths.add(norm_path)
                exists = os.path.isfile(norm_path)
                if not name:
                    name = os.path.basename(norm_path)
                recent.append({
                    'path': norm_path,
                    'name': name,
                    'map_name': map_name or 'Unknown',
                    'exists': exists,
                })
                if len(recent) >= 3:
                    break

            self.recent_scenarios = recent
            first = recent[0] if recent else None
            self.last_scenario_path = first['path'] if first else None
            self.last_scenario_name = first['name'] if first else None
            self.last_scenario_map = first.get('map_name') if first else None
        except Exception as exc:
            print(f"[Recent Scenario] Failed to load cache: {exc}")
            self._clear_last_scenario_cache(remove_file=True)

    def _remember_last_scenario(self, file_path: str, scenario_name: Optional[str], scenario_map: Optional[str]) -> None:
        """Update in-memory and on-disk cache of the most recent scenarios (max 3)."""
        if not file_path or not os.path.isfile(file_path):
            return
        name = scenario_name or os.path.basename(file_path)
        norm_path = os.path.abspath(file_path)
        map_name = scenario_map or 'Unknown'
        cache_path = self._get_last_scenario_cache_path()
        try:
            cache_path.parent.mkdir(parents=True, exist_ok=True)
            existing = [entry for entry in self.recent_scenarios if entry.get('path') != norm_path]
            recent = [{
                'path': norm_path,
                'name': name,
                'map_name': map_name,
                'exists': True,
                'updated': time.time(),
            }] + existing
            recent = recent[:3]
            cache_payload = {'recent': recent}
            cache_path.write_text(json.dumps(cache_payload))
            self.recent_scenarios = recent
            first = recent[0]
            self.last_scenario_path = first['path']
            self.last_scenario_name = first['name']
            self.last_scenario_map = first.get('map_name')
        except Exception as exc:
            print(f"[Recent Scenario] Failed to write cache: {exc}")

    def _clear_last_scenario_cache(self, *, remove_file: bool = False) -> None:
        """Clear recent scenario references."""
        self.recent_scenarios = []
        self.last_scenario_path = None
        self.last_scenario_name = None
        self.last_scenario_map = None
        if remove_file:
            cache_path = self._get_last_scenario_cache_path()
            try:
                cache_path.unlink()
            except FileNotFoundError:
                pass
            except Exception:
                pass

    def _load_scenario_from_path(self, file_path: str, *, prompt_unsaved: bool = True) -> bool:
        """Load a scenario from a concrete file path with map handling."""
        if not self.camera_processor:
            print("Camera processor not initialized yet.")
            return False
        if not file_path:
            return False

        if prompt_unsaved and self._has_unsaved_changes():
            if not self._confirm_load_scenario_discard():
                print("Load cancelled: unsaved changes were kept.")
                return False

        file_path = os.path.abspath(file_path)
        if not os.path.isfile(file_path):
            print(f"Scenario file not found: {file_path}")
            self._clear_last_scenario_cache(remove_file=True)
            return False

        print(f"Loading scenario from: {file_path}")

        scenario_map = 'Unknown'
        scenario_data = None
        try:
            with open(file_path, 'r') as f:
                scenario_data = json.load(f)
            scenario_map = scenario_data.get('map_name', 'Unknown') if isinstance(scenario_data, dict) else 'Unknown'
            current_map = self._get_map_display_name()

            if scenario_map != 'Unknown' and scenario_map != current_map:
                print(f"Scenario requires map '{scenario_map}' but current map is '{current_map}'")
                print(f"Switching to map '{scenario_map}'...")
                self.pending_scenario_load = file_path
                self.load_map(scenario_map)
                return True
        except Exception as exc:
            print(f"Warning: Could not check map compatibility: {exc}")

        try:
            self.camera_processor.load_waypoint_data_from_file(file_path)
        except Exception as exc:
            print(f"Failed to load scenario file: {exc}")
            return False

        scenario_name = os.path.splitext(os.path.basename(file_path))[0]
        if isinstance(scenario_data, dict):
            self._apply_weather_from_json_data(scenario_data)

        self.current_scenario_path = file_path
        self.current_scenario_name = scenario_name
        print(f"Scenario '{self.current_scenario_name}' loaded successfully")
        live_sig = self._compute_scene_signature()
        disk_sig = self._compute_disk_scene_signature()
        self._mark_scene_saved(live_sig, disk_sig)
        self._history_position = 0
        self._saved_history_position = 0
        self._remember_last_scenario(file_path, scenario_name, scenario_map)
        return True

    def _open_last_scenario_from_cache(self) -> bool:
        """Open the most recently used scenario if available."""
        for entry in self.recent_scenarios:
            path = entry.get('path')
            if path and os.path.isfile(path):
                return self._load_scenario_from_path(path)
        print("No recent scenario available.")
        return False

    def _prompt_scenario_file_path(self, *, initial_path: Optional[str] = None) -> Optional[str]:
        """Prompt the user for a scenario JSON file path using the in-window file dialog."""
        script_dir = os.path.dirname(os.path.abspath(__file__))
        default_path = initial_path or self.current_scenario_path or self.last_scenario_path or script_dir

        dialog_rect = self._center_dialog_rect(640, 480)
        dialog = EnhancedFileDialog(
            rect=dialog_rect,
            manager=self.ui_manager,
            window_title="Open Scenario",
            allowed_suffixes={'.json', '.JSON'},
            initial_file_path=default_path,
            allow_existing_files_only=True,
            always_on_top=True,
        )
        dialog.set_blocking(True)
        confirm_button = getattr(dialog, "ok_button", getattr(dialog, "confirm_button", None))
        if confirm_button:
            confirm_button.set_text("Open")

        def handler(event: pygame.event.Event):
            if event.type == UI_FILE_DIALOG_PATH_PICKED and event.ui_element == dialog:
                if event.text and os.path.isfile(event.text):
                    return True, event.text
                return False, None
            # Legacy pre-0.8 support: treat user_type events the same way without touching the deprecated attribute directly.
            if event.type == pygame.USEREVENT:
                picked_path = getattr(event, "text", None)
                ui_element = getattr(event, "ui_element", None)
                if picked_path and ui_element == dialog and os.path.isfile(picked_path):
                    return True, picked_path
            if event.type == UI_SELECTION_LIST_DOUBLE_CLICKED_SELECTION and event.ui_element == getattr(dialog, "file_selection_list", None):
                # If the directory changed (double-clicked folder), ignore.
                if Path(dialog.current_directory_path).name == event.text and Path(dialog.current_directory_path).is_dir():
                    return False, None
                path = dialog.current_file_path
                if path and os.path.isfile(path):
                    return True, str(path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and hasattr(dialog, "new_folder_button")
                and event.ui_element == dialog.new_folder_button
            ):
                folder_name = self._prompt_text_input("Create Folder", "Folder name:", "New Folder")
                if folder_name:
                    base_dir = Path(dialog.current_directory_path)
                    new_path = base_dir / folder_name
                    try:
                        new_path.mkdir()
                    except FileExistsError:
                        print(f"[File Dialog] Folder '{folder_name}' already exists.")
                    except Exception as exc:
                        print(f"[File Dialog] Unable to create folder '{folder_name}': {exc}")
                    else:
                        dialog._change_directory_path(new_path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and confirm_button is not None
                and event.ui_element == confirm_button
            ):
                path = dialog.current_file_path
                if path and os.path.isfile(path):
                    return True, str(path)
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, None
            return False, None

        file_path = self._run_modal_window(dialog, handler)
        if not file_path:
            return None
        return str(file_path)

    def _prompt_agent_file_path(self, *, initial_path: Optional[str] = None) -> Optional[str]:
        """Prompt the user for a ScenarioRunner-compatible agent Python file."""
        if not self.ui_manager:
            print("[Agent] UI not ready; cannot open agent picker.")
            return None

        self._close_all_dropdowns(keep_info_panel=True)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        default_path = initial_path or getattr(self, "agent_path", None) or self._get_last_agent_directory() or script_dir

        dialog_rect = self._center_dialog_rect(640, 480)
        dialog = EnhancedFileDialog(
            rect=dialog_rect,
            manager=self.ui_manager,
            window_title="Select Agent",
            allowed_suffixes={'.py', '.PY'},
            initial_file_path=default_path,
            allow_existing_files_only=True,
            always_on_top=True,
        )
        dialog.set_blocking(True)
        confirm_button = getattr(dialog, "ok_button", getattr(dialog, "confirm_button", None))
        if confirm_button:
            confirm_button.set_text("Select")

        def handler(event: pygame.event.Event):
            if event.type == UI_FILE_DIALOG_PATH_PICKED and event.ui_element == dialog:
                if event.text and os.path.isfile(event.text):
                    return True, event.text
                return False, None
            if event.type == pygame.USEREVENT:
                picked_path = getattr(event, "text", None)
                ui_element = getattr(event, "ui_element", None)
                if picked_path and ui_element == dialog and os.path.isfile(picked_path):
                    return True, picked_path
            if event.type == UI_SELECTION_LIST_DOUBLE_CLICKED_SELECTION and event.ui_element == getattr(dialog, "file_selection_list", None):
                if Path(dialog.current_directory_path).name == event.text and Path(dialog.current_directory_path).is_dir():
                    return False, None
                path = dialog.current_file_path
                if path and os.path.isfile(path):
                    return True, str(path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and hasattr(dialog, "new_folder_button")
                and event.ui_element == dialog.new_folder_button
            ):
                folder_name = self._prompt_text_input("Create Folder", "Folder name:", "New Folder")
                if folder_name:
                    base_dir = Path(dialog.current_directory_path)
                    new_path = base_dir / folder_name
                    try:
                        new_path.mkdir()
                    except Exception:
                        pass
                    else:
                        dialog._change_directory_path(new_path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and confirm_button is not None
                and event.ui_element == confirm_button
            ):
                path = dialog.current_file_path
                if path and os.path.isfile(path):
                    return True, str(path)
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, None
            return False, None

        file_path = self._run_modal_window(dialog, handler)
        if not file_path:
            return None
        file_path = str(file_path)
        if not os.path.isfile(file_path):
            return None
        if not file_path.lower().endswith(".py"):
            return None
        return os.path.abspath(file_path)

    def _prompt_startup_map_choice(self, options: List[Dict[str, str]]) -> Optional[Dict[str, str]]:
        """Prompt the user to choose a local CARLA map for startup."""
        if not options:
            return None

        dialog_rect = self._center_dialog_rect(520, 560)
        dialog = UIWindow(
            rect=dialog_rect,
            manager=self.ui_manager,
            window_display_title="Open Map",
            resizable=False,
            always_on_top=True,
        )
        dialog.set_blocking(True)

        container_width, container_height = dialog.get_container().get_size()
        list_rect = pygame.Rect(
            10,
            10,
            max(120, container_width - 20),
            max(80, container_height - 70),
        )

        label_to_option = {opt["label"]: opt for opt in options if isinstance(opt, dict) and opt.get("label")}
        selection_list = UISelectionList(
            relative_rect=list_rect,
            item_list=[opt["label"] for opt in options if opt.get("label")],
            manager=self.ui_manager,
            container=dialog,
            allow_double_clicks=True,
            object_id="#startup_map_selection_list",
        )

        button_width = 120
        button_height = 32
        button_y = container_height - button_height - 10

        cancel_button = UIButton(
            relative_rect=pygame.Rect(
                container_width - button_width - 10,
                button_y,
                button_width,
                button_height,
            ),
            text="Cancel",
            manager=self.ui_manager,
            container=dialog,
            object_id="#startup_map_cancel_button",
            anchors={
                "left": "right",
                "right": "right",
                "top": "bottom",
                "bottom": "bottom",
            },
        )

        ok_button = UIButton(
            relative_rect=pygame.Rect(
                container_width - (2 * button_width) - 20,
                button_y,
                button_width,
                button_height,
            ),
            text="Start",
            manager=self.ui_manager,
            container=dialog,
            object_id="#startup_map_start_button",
            anchors={
                "left": "right",
                "right": "right",
                "top": "bottom",
                "bottom": "bottom",
                "right_target": cancel_button,
            },
        )
        ok_button.disable()

        selected_label: Optional[str] = None

        def handler(event: pygame.event.Event):
            nonlocal selected_label

            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                return True, None

            if event.type == UI_SELECTION_LIST_NEW_SELECTION and event.ui_element == selection_list:
                selected_label = event.text
                ok_button.enable()
                return False, None

            if event.type == UI_SELECTION_LIST_DOUBLE_CLICKED_SELECTION and event.ui_element == selection_list:
                selected_label = event.text
                return True, label_to_option.get(selected_label) if selected_label else None

            if event.type == UI_BUTTON_PRESSED:
                if event.ui_element == ok_button:
                    return True, label_to_option.get(selected_label) if selected_label else None
                if event.ui_element == cancel_button:
                    return True, None

            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, None

            return False, None

        picked = self._run_modal_window(dialog, handler)
        if isinstance(picked, dict):
            return cast(Dict[str, str], picked)
        return None
    
    def load_scenario_with_dialog(self):
        """Load a scenario using an in-window file dialog."""
        if not self.camera_processor:
            print("Camera processor not initialized yet.")
            return

        file_path = self._prompt_scenario_file_path()
        if not file_path:
            return

        self._load_scenario_from_path(file_path)

    def save_scenario_with_dialog(self):
        """Save a scenario using an in-window file dialog."""
        if not self.camera_processor:
            print("Camera processor not initialized yet.")
            return

        # Get the script directory as default folder
        script_dir = os.path.dirname(os.path.abspath(__file__))
        initial_path = self.current_scenario_path or script_dir

        dialog_rect = self._center_dialog_rect(640, 480)
        dialog = EnhancedFileDialog(
            rect=dialog_rect,
            manager=self.ui_manager,
            window_title="Save Scenario",
            allowed_suffixes={'.json', '.JSON'},
            initial_file_path=initial_path,
            allow_existing_files_only=False,
            always_on_top=True,
        )
        dialog.set_blocking(True)
        confirm_button = getattr(dialog, "ok_button", getattr(dialog, "confirm_button", None))
        if confirm_button:
            confirm_button.set_text("Save")
        file_entry = getattr(dialog, "file_path_text_line", None)
        if file_entry and not self.current_scenario_path:
            default_dir = initial_path if os.path.isdir(initial_path) else os.path.dirname(initial_path)
            if not default_dir:
                default_dir = os.getcwd()
            base_name = self.current_scenario_name or "scenario"
            candidate_path = os.path.join(default_dir, f"{base_name}.json")
            dialog.current_directory_path = default_dir
            dialog.current_file_path = Path(candidate_path)
            file_entry.set_text(candidate_path)
            filename = os.path.basename(candidate_path)
            name_part = filename[:-5] if filename.lower().endswith(".json") else filename
            start_index = len(candidate_path) - len(filename)
            end_index = start_index + len(name_part)
            file_entry.select_range = [start_index, end_index]
            file_entry.cursor_has_moved_recently = True
            file_entry.edit_position = end_index
            try:
                file_entry.focus()
            except AttributeError:
                pass

        def handler(event: pygame.event.Event):
            if event.type == UI_FILE_DIALOG_PATH_PICKED and event.ui_element == dialog:
                if event.text and not os.path.isdir(event.text):
                    return True, event.text
                return False, None
            if event.type == pygame.USEREVENT:
                picked_path = getattr(event, "text", None)
                ui_element = getattr(event, "ui_element", None)
                if picked_path and ui_element == dialog and not os.path.isdir(picked_path):
                    return True, picked_path
            if event.type == UI_SELECTION_LIST_DOUBLE_CLICKED_SELECTION and event.ui_element == getattr(dialog, "file_selection_list", None):
                if Path(dialog.current_directory_path).name == event.text and Path(dialog.current_directory_path).is_dir():
                    return False, None
                path = dialog.current_file_path
                if path and not os.path.isdir(path):
                    return True, str(path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and hasattr(dialog, "new_folder_button")
                and event.ui_element == dialog.new_folder_button
            ):
                folder_name = self._prompt_text_input("Create Folder", "Folder name:", "New Folder")
                if folder_name:
                    base_dir = Path(dialog.current_directory_path)
                    new_path = base_dir / folder_name
                    try:
                        new_path.mkdir()
                    except FileExistsError:
                        print(f"[File Dialog] Folder '{folder_name}' already exists.")
                    except Exception as exc:
                        print(f"[File Dialog] Unable to create folder '{folder_name}': {exc}")
                    else:
                        dialog._change_directory_path(new_path)
                return False, None
            if (
                event.type == UI_BUTTON_PRESSED
                and confirm_button is not None
                and event.ui_element == confirm_button
            ):
                path = dialog.current_file_path
                if path and not os.path.isdir(path):
                    return True, str(path)
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, None
            return False, None

        file_path = self._run_modal_window(dialog, handler)
        if not file_path:
            return

        file_path = os.path.abspath(file_path)

        # Ensure .json extension
        if not file_path.endswith('.json'):
            file_path += '.json'

        # Extract scenario name and target directory
        scenario_name = os.path.splitext(os.path.basename(file_path))[0]
        target_dir = os.path.dirname(file_path)

        print(f"Saving scenario '{scenario_name}' to: {target_dir}")
        ego_data = self.camera_processor.get_ego_vehicle_data() if self.camera_processor else None

        map_obj = self._safe_get_world_map(refresh=not self._map_refresh_disabled)
        if map_obj:
            full_map_name = map_obj.name
            map_name = full_map_name.split('/')[-1] if '/' in full_map_name else full_map_name
        else:
            full_map_name = "unknown"
            map_name = "unknown"

        # 3. Save scenario JSON to target directory
        self.camera_processor.save_waypoint_data_to_file(file_path)

        # Update current scenario tracking
        self.current_scenario_path = file_path
        self.current_scenario_name = scenario_name
        print(f"Scenario '{scenario_name}' saved successfully")
        live_sig = self._compute_scene_signature()
        disk_sig = self._compute_disk_scene_signature()
        self._mark_scene_saved(live_sig, disk_sig)
        self._saved_history_position = self._history_position
        self._remember_last_scenario(file_path, scenario_name, map_name)

    def _prepare_for_map_change(self):
        """Stop conflicting systems before initiating a map change."""
        if self.scenario_running:
            print("Stopping active scenario before map change...")
            self.stop_scenario()

        if self.camera_processor and self.camera_processor.manual_control_enabled:
            print("Disabling manual control before map change...")
            self.camera_processor.disable_manual_control()

        if self.pending_scenario_load and not os.path.isfile(self.pending_scenario_load):
            print(f"[WARN] Pending scenario '{self.pending_scenario_load}' no longer exists; clearing handoff.")
            self.pending_scenario_load = None

    def _wait_for_world_tick(
        self,
        world,
        *,
        timeout: float = 30.0,
        min_ticks: int = 1,
        label: str = "world",
    ) -> bool:
        """Best-effort wait for CARLA to start ticking (reduces startup race conditions)."""
        if not world or not hasattr(world, "wait_for_tick"):
            return False

        try:
            timeout_s = float(timeout)
        except Exception:
            timeout_s = 0.0
        timeout_s = max(0.0, timeout_s)

        try:
            min_ticks_int = int(min_ticks)
        except Exception:
            min_ticks_int = 1
        min_ticks_int = max(1, min_ticks_int)

        deadline = time.time() + timeout_s
        ticks_seen = 0
        last_exc: Optional[Exception] = None

        while ticks_seen < min_ticks_int and time.time() < deadline:
            try:
                world.wait_for_tick(1.0)
                ticks_seen += 1
            except Exception as exc:
                last_exc = exc
                time.sleep(0.2)

        if ticks_seen >= min_ticks_int:
            return True

        if last_exc is not None:
            print(f"[Startup] Timed out waiting for world tick ({label}): {last_exc}")
        else:
            print(f"[Startup] Timed out waiting for world tick ({label}).")
        return False

    def _wait_for_remote_server(self, host, port, timeout=60):
        """Poll a remote CARLA endpoint until it responds or timeout expires."""
        start_time = time.time()
        last_error = None
        try:
            client = carla.Client(host, port)
            client.set_timeout(5.0)
        except Exception as exc:
            print(f"[Remote Wait] Failed to create client for {host}:{port}: {exc}")
            return False

        attempt = 0

        while time.time() - start_time < timeout:
            try:
                attempt += 1
                print(f"[Remote Wait] Attempt {attempt} connecting to {host}:{port}...")
                version = client.get_server_version()
                print(f"[Remote Wait] Remote CARLA server ready! Version: {version}")
                return True
            except Exception as exc:
                last_error = exc
                time.sleep(2.0)

        print(f"[Remote Wait] Timeout waiting for remote CARLA server at {host}:{port}")
        if last_error:
            print(f"[Remote Wait] Last error: {last_error}")
        return False

    def _probe_remote_connection(self, host, port, *, max_attempts=3, timeout=3.0):
        """Quickly verify a remote CARLA endpoint before committing to a profile switch."""
        print(f"[Remote Probe] Probing {host}:{port} before switching...")
        try:
            client = carla.Client(host, port)
            client.set_timeout(timeout)
        except Exception as exc:
            print(f"[Remote Probe] Failed to create client for {host}:{port}: {exc}")
            return False

        last_error = None
        for attempt in range(1, max_attempts + 1):
            try:
                print(f"[Remote Probe] Attempt {attempt}/{max_attempts}...")
                version = client.get_server_version()
                print(f"[Remote Probe] Success. Remote CARLA version: {version}")
                return True
            except Exception as exc:
                last_error = exc
                print(f"[Remote Probe] Attempt {attempt} failed: {exc}")
                time.sleep(1.0)

        print(f"[Remote Probe] Unable to reach {host}:{port} after {max_attempts} attempts.")
        if last_error:
            print(f"[Remote Probe] Last error: {last_error}")
        return False

    def _create_local_profile(self):
        """Build a fresh local connection profile."""
        return ConnectionProfile(
            name="local",
            host='127.0.0.1',
            port=self.local_port,
            manage_server=True,
            display_name="Local CARLA",
            description="Simulator started and managed by VSE",
            map_hint=None
        )

    def _create_remote_profile(self, host, port, label=None):
        """Build a connection profile for a remote server."""
        display_label = label or f"{host}:{port}"
        return ConnectionProfile(
            name=f"remote-{host}-{port}",
            host=host,
            port=port,
            manage_server=False,
            display_name=f"Remote {display_label}",
            description=f"Remote CARLA server at {host}:{port}",
            map_hint=self.remote_map_hint
        )

    def _switch_connection_profile(self, new_profile, *, stop_previous_on_success=False):
        """Switch to a new CARLA connection profile, preserving the previous session on failure."""
        previous_profile = self.connection_profile
        if (previous_profile.host == new_profile.host and
                previous_profile.port == new_profile.port and
                previous_profile.manage_server == new_profile.manage_server):
            print(f"Already connected to {new_profile.display_name}.")
            return True

        if self.scenario_running:
            print("Cannot switch CARLA connection while a scenario is running. Stop the scenario first.")
            return False

        print(f"[Connection] Switching connection: {previous_profile.display_name} → {new_profile.display_name}")
        self._prepare_for_map_change()

        # Attempt to connect using the new profile
        self.connection_profile = new_profile
        self.ready = False
        self.startup_error = None

        try:
            print("[Connection] Cleaning up current CARLA session before reconnect...")
            self._cleanup_for_map_restart()
        except Exception as exc:
            print(f"Warning during cleanup before reconnect: {exc}")

        print("[Connection] Cleanup complete, starting startup sequence for new profile...")
        success = self.startup_sequence()
        if success:
            if stop_previous_on_success and previous_profile.manage_server:
                try:
                    print("Stopping local CARLA server now that remote connection is active...")
                    self.server_manager.stop_server(force=True)
                except Exception as exc:
                    print(f"Warning: Failed to stop local CARLA server: {exc}")
            self._previous_connection_profile = previous_profile
            if not new_profile.is_remote:
                self.active_remote_label = None
                self.active_remote_port = None
            print(f"[Connection] Startup sequence for {new_profile.display_name} completed successfully.")
            return True

        print(f"[Connection] Failed to connect to {new_profile.display_name}. Restoring previous connection...")
        # Restore previous profile
        self.connection_profile = previous_profile
        try:
            print("[Connection] Cleaning up failed attempt before restoring previous session...")
            self._cleanup_for_map_restart()
        except Exception:
            pass
        print(f"[Connection] Restarting previous profile ({previous_profile.display_name})...")
        restore_success = self.startup_sequence()
        if not restore_success:
            print("Error: Unable to restore previous CARLA connection. Please restart the editor.")
        return False

    def _restore_start_weather_from_presets(self):
        """Restore pre-play weather (fallback: first weather keyframe)."""
        if not self.world:
            return

        restore_weather = getattr(self, "_scenario_restore_weather", None)
        if restore_weather is not None:
            try:
                self.world.set_weather(restore_weather)
                return
            except Exception as exc:
                print(f"[Weather] Failed to restore pre-play weather: {exc}")
            finally:
                try:
                    self._scenario_restore_weather = None
                except Exception:
                    pass

        self._ensure_weather_keyframes()
        frame = self._weather_keyframes[0] if self._weather_keyframes else None
        if not isinstance(frame, dict):
            return
        weather = self._weather_params_from_dict(frame)
        try:
            self.world.set_weather(weather)
        except Exception as exc:
            print(f"[Weather] Failed to restore start weather: {exc}")

    def _restart_with_profile(self, profile, *, label=None, target_map=None):
        """Restart the editor into a different connection profile (e.g., remote)."""
        if self.restart_in_progress:
            print("Profile switch already in progress. Please wait.")
            return False

        self._prepare_for_map_change()

        self.pending_profile_switch = profile
        self.pending_profile_switch_label = label
        self.pending_map_switch = target_map
        self.restart_in_progress = True
        self.ready = False
        self.startup_error = None
        self.loading_stage = f"Switching to '{profile.display_name}'..."

        self.restart_thread = threading.Thread(
            target=self._perform_profile_restart,
            args=(profile, label, target_map),
            daemon=True
        )
        self.restart_thread.start()
        return True

    def _perform_profile_restart(self, profile, label, target_map):
        """Launch a new VSE process configured for the requested profile."""
        try:
            self.loading_stage = f"Preparing to connect to {profile.display_name}..."
            self._cleanup_for_map_restart()

            profile_payload = {
                'name': profile.name,
                'host': profile.host,
                'port': profile.port,
                'manage_server': profile.manage_server,
                'display_name': profile.display_name,
                'description': profile.description,
                'map_hint': profile.map_hint,
            }
            if label:
                profile_payload['label'] = label
            if target_map:
                profile_payload['pending_map'] = target_map

            env = os.environ.copy()
            env['VSE_WINDOWED_WIDTH'] = str(int(self.windowed_width))
            env['VSE_WINDOWED_HEIGHT'] = str(int(self.windowed_height))
            env['VSE_SCREEN_WIDTH'] = str(int(self.screen_width))
            env['VSE_SCREEN_HEIGHT'] = str(int(self.screen_height))
            env['VSE_WINDOW_MAXIMIZED'] = '1' if self.maximized else '0'
            env['VSE_PROFILE_JSON'] = json.dumps(profile_payload)

            env.pop('VSE_PENDING_MAP', None)
            if target_map:
                env['VSE_PENDING_MAP'] = target_map

            if self.pending_scenario_load:
                env['VSE_PENDING_SCENARIO'] = self.pending_scenario_load

            cmd = [sys.executable] + sys.argv
            handoff_read_fd, handoff_write_fd = os.pipe()
            env['VSE_HANDOFF_FD'] = str(handoff_write_fd)
            self.handoff_read_fd = handoff_read_fd
            pass_fds = (handoff_write_fd,)

            try:
                self.relaunch_process = subprocess.Popen(cmd, env=env, pass_fds=pass_fds)
            finally:
                try:
                    os.close(handoff_write_fd)
                except OSError:
                    pass

            self._enter_restart_wait_state()

        except Exception as exc:
            self._handle_profile_restart_failure(profile.display_name, exc)
        finally:
            self.restart_in_progress = False
            self.restart_thread = None

    def _handle_profile_restart_failure(self, profile_name, error):
        """Handle errors while attempting to restart into a different profile."""
        print(f"Failed to switch to profile '{profile_name}': {error}")
        traceback.print_exc()
        self.startup_error = str(error)
        self.loading_stage = f"Error: {error}"
        self.ready = False
        self.pending_exit = False
        self.keep_server_running_on_exit = False
        self.relaunch_process = None
        self.wait_for_child = False
        if self.handoff_read_fd is not None:
            try:
                os.close(self.handoff_read_fd)
            except OSError:
                pass
            self.handoff_read_fd = None
        self.pending_profile_switch = None
        self.pending_profile_switch_label = None
        self.pending_map_switch = None
        self._reset_restart_flags()

    def switch_to_local_server(self):
        """Return to the locally managed CARLA server."""
        print("[Connection] Switching back to local CARLA server...")
        local_profile = self._create_local_profile()
        started = self._restart_with_profile(local_profile, label="Local CARLA")
        if not started:
            print("[Connection] Unable to initiate restart into local server.")
        return started

    def _enter_restart_wait_state(self):
        """Put the current process into a waiting state while the new instance starts."""
        self.loading_stage = "Completing map change..."
        self.restart_start_time = time.time()
        self.pending_exit = True
        self.keep_server_running_on_exit = True
        self.server_manager.set_auto_stop_enabled(False)
        self.wait_for_child = True

    def _reset_restart_flags(self):
        """Clear restart-related flags and ensure server auto-stop is restored."""
        self.restart_in_progress = False
        self.restart_thread = None
        self.restart_start_time = None
        self.server_manager.set_auto_stop_enabled(True)

    def _manual_world_tick(self, dt):
        """Advance the CARLA simulation when operating in synchronous remote mode."""
        if not (self.manual_tick_required and self.manual_tick_enabled):
            return

        # During scenario playback, tick ownership belongs to ScenarioRunner/MiniRunner
        # (or an external bridge). Avoid double-ticking from the UI loop.
        if getattr(self, "scenario_running", False):
            return

        if not self.world:
            return

        interval = max(self.manual_tick_interval, 0.001)
        is_large_map = bool(getattr(self, "large_map_active", False))
        is_bootstrap = bool(is_large_map and getattr(self, "_large_map_bootstrap_ticking", False))
        if is_bootstrap:
            # During large-map bootstrap we poll slowly (the external bridge is expected to tick).
            interval = max(interval, 0.25)
        self.manual_tick_accumulator += dt

        ticks_executed = 0
        max_ticks_per_frame = 1 if is_large_map else 5

        if is_large_map:
            now = time.time()
            next_attempt = float(getattr(self, "_large_map_manual_tick_next_attempt", 0.0) or 0.0)
            if now < next_attempt:
                self.manual_tick_accumulator = 0.0
                return

            # If an external ego is present and frames are flowing, let the bridge control ticks.
            cp = getattr(self, "camera_processor", None)
            if (
                getattr(self, "external_ego_actor", None) is not None
                and not getattr(self, "_large_map_bootstrap_ticking", False)
                and cp is not None
                and getattr(cp, "last_frame_time", None)
            ):
                frame_age = now - float(cp.last_frame_time or 0.0)
                if 0.0 <= frame_age < 0.25:
                    # Keep manual ticks running unless an external tick source is clearly active.
                    try:
                        camera_fps = float(getattr(cp, "_camera_fps_display", 0.0) or 0.0)
                    except Exception:
                        camera_fps = 0.0
                    try:
                        world_fps = float(getattr(self, "_world_tick_fps", 0.0) or 0.0)
                    except Exception:
                        world_fps = 0.0
                    if max(camera_fps, world_fps) >= 8.0:
                        self.manual_tick_accumulator = 0.0
                        return

        while self.manual_tick_accumulator >= interval and ticks_executed < max_ticks_per_frame:
            try:
                is_bootstrap = getattr(self, '_large_map_bootstrap_ticking', False)
                # During large-map bootstrap, avoid driving ticks ourselves; wait for the external
                # tick source (e.g., bridge) so we don't fight for tick ownership.
                if is_large_map and is_bootstrap and hasattr(self.world, "wait_for_tick"):
                    self.world.wait_for_tick(0.5)
                elif hasattr(self.world, "tick"):
                    tick_world = self.world
                    fast_client = None
                    if is_large_map:
                        cp = getattr(self, "camera_processor", None)
                        if cp is not None and hasattr(cp, "_get_fast_world"):
                            try:
                                fast_world = cp._get_fast_world()
                            except Exception:
                                fast_world = None
                            if fast_world is not None:
                                tick_world = fast_world
                                fast_client = getattr(cp, "_fast_rpc_client", None)

                    if is_large_map and fast_client is not None:
                        try:
                            prev_timeout = float(getattr(cp, "_large_map_rpc_timeout_s", 2.0))
                        except Exception:
                            prev_timeout = 2.0
                        try:
                            fast_client.set_timeout(min(prev_timeout, 0.25))
                        except Exception:
                            pass
                        try:
                            tick_world.tick()
                        finally:
                            try:
                                fast_client.set_timeout(prev_timeout)
                            except Exception:
                                pass
                    else:
                        tick_world.tick()
                elif hasattr(self.world, "wait_for_tick"):
                    # Avoid long UI stalls: poll briefly instead of blocking for seconds.
                    self.world.wait_for_tick(0.05 if is_large_map else 1.0)
                else:
                    raise RuntimeError("Current CARLA world does not expose tick/wait_for_tick")
            except Exception as exc:
                # During bootstrap on large maps, suppress repeated warnings
                if is_bootstrap:
                    if not getattr(self, '_bootstrap_tick_warned', False):
                        print(f"[Tick] Bootstrap waiting for external tick source...")
                        self._bootstrap_tick_warned = True
                else:
                    if not is_large_map:
                        print(f"[Tick] Warning: world tick failed ({exc})")
                    else:
                        failures = int(getattr(self, "_large_map_manual_tick_failures", 0) or 0) + 1
                        self._large_map_manual_tick_failures = failures
                        backoff = 0.25 * (2.0 ** min(4, failures))
                        self._large_map_manual_tick_next_attempt = time.time() + min(2.0, backoff)
                self.manual_tick_accumulator = 0.0
                break
            else:
                if is_large_map:
                    self._large_map_manual_tick_failures = 0
                    self._large_map_manual_tick_next_attempt = 0.0
                self.manual_tick_accumulator -= interval
                ticks_executed += 1

        if ticks_executed == max_ticks_per_frame and self.manual_tick_accumulator >= interval:
            self.manual_tick_accumulator = 0.0

    def _load_remote_map(self, map_name):
        """Request the remote CARLA server to load a specific map."""
        if not self.client:
            print('[Remote Map] No client available for remote map load.')
            return False

        try:
            print(f"[Remote Map] Loading '{map_name}' on remote server...")
            self.loading_stage = f"Loading remote map '{map_name}'..."
            self.client.load_world(map_name, map_layers=carla.MapLayer.NONE)

            self.loading_stage = "Waiting for remote map..."
            self.world = self.client.get_world()
            is_sync = False
            try:
                settings_probe = self.world.get_settings()
                is_sync = bool(getattr(settings_probe, "synchronous_mode", False))
            except Exception:
                settings_probe = None

            ticked = False
            if hasattr(self.world, "wait_for_tick"):
                tick_timeout = 60.0 if not is_sync else 2.0
                ticked = self._wait_for_world_tick(
                    self.world,
                    timeout=tick_timeout,
                    min_ticks=2,
                    label="remote-map-load",
                )

            if not ticked:
                if not is_sync and hasattr(self.world, "wait_for_tick"):
                    raise RuntimeError("Remote world did not start ticking after map load; map may not be ready.")
                if is_sync:
                    time.sleep(2.0)

            self.world_map = self.world.get_map()
            self.cached_map = self.world_map

            print(f"[Remote Map] Remote map ready: {self.world_map.name}")
            return True
        except Exception as exc:
            print(f"[Remote Map] Failed to load '{map_name}': {exc}")
            self.startup_error = str(exc)
            self.loading_stage = f"Error: {exc}"
            return False

    def _handle_map_restart_failure(self, map_name, error):
        """Handle errors during the map restart process."""
        print(f"Failed to change map '{map_name}': {error}")
        traceback.print_exc()
        self.startup_error = str(error)
        self.loading_stage = f"Error: {error}"
        self.ready = False
        self.pending_exit = False
        self.keep_server_running_on_exit = False
        self.relaunch_process = None
        self.wait_for_child = False
        if self.handoff_read_fd is not None:
            try:
                os.close(self.handoff_read_fd)
            except OSError:
                pass
            self.handoff_read_fd = None
        self._reset_restart_flags()

    def load_map(self, map_name):
        """Load a different CARLA map while keeping the current window visible."""
        # Large maps are streamed from a root level; avoid loading individual tiles directly.
        requested_name = (map_name or "").strip()
        if requested_name:
            last_segment = requested_name.split('/')[-1]
            if "_Tile_" in last_segment:
                base = last_segment.split("_Tile_")[0].strip()
                if base:
                    if "/" in requested_name:
                        parts = requested_name.split("/")
                        parts[-1] = base
                        requested_name = "/".join(parts)
                    else:
                        requested_name = base
                    map_name = requested_name

        if self.connection_profile and self.connection_profile.is_remote:
            return self.request_remote_map_change(map_name)

        if not self.client:
            print("CARLA client not initialized yet; cannot change map.")
            return False

        if self.restart_in_progress:
            print("Map change already in progress. Please wait for it to finish.")
            return False

        # Check if OpenDRIVE overlay is enabled - disable automatically before changing maps
        if self.camera_processor:
            OpenDriveOverlayRenderer.disable_overlay(self.camera_processor, silent=True)

        current_map = self._get_map_display_name()
        # Extract short name from map_name for comparison (e.g., "/Game/Carla/Maps/tartu_large/tartu_large" -> "tartu_large")
        requested_map_short = map_name.split('/')[-1]
        if current_map == requested_map_short:
            print(f"Map '{requested_map_short}' is already loaded.")
            return True

        self._prepare_for_map_change()

        print(f"Changing map: {current_map} → {map_name}")

        self.restart_in_progress = True
        self.ready = False
        self.startup_error = None
        self.loading_stage = f"Changing map to '{map_name}'..."

        self.restart_thread = threading.Thread(
            target=self._perform_map_restart,
            args=(map_name,),
            daemon=True
        )
        self.restart_thread.start()
        return True

    def _cleanup_for_map_restart(self):
        """Release editor resources prior to launching the new process."""
        print("[Cleanup] Releasing editor resources before reconnect/restart...")

        if self.camera_processor:
            print("[Cleanup] Disabling overlays and destroying camera processor...")
            OpenDriveOverlayRenderer.disable_overlay(self.camera_processor, silent=True)
            if hasattr(self.camera_processor, 'opendrive_lane_data'):
                self.camera_processor.opendrive_lane_data = None
            if hasattr(self.camera_processor, 'opendrive_segment_grid'):
                self.camera_processor.opendrive_segment_grid = None
            if hasattr(self.camera_processor, 'opendrive_segment_bboxes'):
                self.camera_processor.opendrive_segment_bboxes = None
            self.camera_processor.cleanup_all_vehicles()
            self.camera_processor.cleanup()
            self.camera_processor = None
            if self.vehicle_menu:
                self.vehicle_menu.set_camera_processor(None)
            if self.pedestrian_menu:
                self.pedestrian_menu.set_camera_processor(None)
            if self.ego_vehicle_menu:
                self.ego_vehicle_menu.set_camera_processor(None)

        if self.info_panel:
            self.info_panel.hide()
            self.info_panel = None

        print("[Cleanup] Clearing world/client references and command stacks...")
        self.camera_controller = None
        self._no_camera_saved_pose = None
        self.command_history.clear()
        self.undo_stack.clear()
        self.redo_stack.clear()
        self._scene_dirty_hint = False
        self._saved_scene_signature = None
        self._saved_disk_signature = None
        self._history_position = 0
        self._saved_history_position = 0
        self.keys_pressed.clear()
        self.key_hold_times.clear()
        self.selected_vehicle_type = None
        self.selected_pedestrian_type = None
        self.selected_ego_vehicle_type = None

        self.world_map = None
        self.world = None
        self.client = None
        self.manual_tick_required = False
        self.manual_tick_accumulator = 0.0
        self.manual_tick_enabled = False
        self.manual_tick_recommendation = False
        self.manual_tick_button_rect = None
        self.pending_map_switch = None
        self.pending_remote_map = None

        gc.collect()
        time.sleep(1.0)
        print("[Cleanup] Resource cleanup complete.")

    def _notify_handoff_ready(self):
        """Notify the previous VSE instance that takeover is complete."""
        if self.handoff_write_fd is not None:
            try:
                os.write(self.handoff_write_fd, b'1')
            except OSError:
                pass
            try:
                os.close(self.handoff_write_fd)
            except OSError:
                pass
            self.handoff_write_fd = None

    def _perform_map_restart(self, map_name):
        """Background sequence that prepares the server and launches a fresh editor."""
        try:
            self.loading_stage = "Loading map..."
            self._cleanup_for_map_restart()

            self.loading_stage = f"Loading {map_name}..."
            temp_client = carla.Client('127.0.0.1', self.server_manager.port)
            temp_client.set_timeout(30.0)
            temp_client.load_world(map_name, map_layers=carla.MapLayer.NONE)

            self.loading_stage = "Finalizing map load..."
            world = None
            try:
                world = temp_client.get_world()
            except Exception:
                world = None

            is_sync = False
            if world is not None:
                try:
                    settings_probe = world.get_settings()
                    is_sync = bool(getattr(settings_probe, "synchronous_mode", False))
                except Exception:
                    settings_probe = None

            ticked = False
            if world is not None and hasattr(world, "wait_for_tick"):
                tick_timeout = 60.0 if not is_sync else 2.0
                ticked = self._wait_for_world_tick(
                    world,
                    timeout=tick_timeout,
                    min_ticks=3,
                    label="map-restart",
                )

            if not ticked:
                if not is_sync and world is not None and hasattr(world, "wait_for_tick"):
                    raise RuntimeError("CARLA world did not start ticking after load_world; map may not be ready.")
                time.sleep(2.0)

            self.loading_stage = "Reloading editor..."
            cmd = [sys.executable] + sys.argv
            env = os.environ.copy()
            known_pid = self.server_manager.get_known_server_pid()
            if known_pid:
                env['VSE_SERVER_PID'] = str(known_pid)
            elif 'VSE_SERVER_PID' in env:
                del env['VSE_SERVER_PID']

            env['VSE_WINDOWED_WIDTH'] = str(int(self.windowed_width))
            env['VSE_WINDOWED_HEIGHT'] = str(int(self.windowed_height))
            env['VSE_SCREEN_WIDTH'] = str(int(self.screen_width))
            env['VSE_SCREEN_HEIGHT'] = str(int(self.screen_height))
            env['VSE_WINDOW_MAXIMIZED'] = '1' if self.maximized else '0'

            if self.pending_scenario_load:
                env['VSE_PENDING_SCENARIO'] = self.pending_scenario_load
                print(f"Passing pending scenario through environment: {self.pending_scenario_load}")

            handoff_read_fd, handoff_write_fd = os.pipe()
            env['VSE_HANDOFF_FD'] = str(handoff_write_fd)
            self.handoff_read_fd = handoff_read_fd
            pass_fds = (handoff_write_fd,)
            try:
                self.relaunch_process = subprocess.Popen(cmd, env=env, pass_fds=pass_fds)
            except Exception as launch_error:
                raise RuntimeError(f"Failed to reload editor: {launch_error}")
            finally:
                try:
                    os.close(handoff_write_fd)
                except OSError:
                    pass

            self._enter_restart_wait_state()

        except Exception as e:
            self._handle_map_restart_failure(map_name, e)
        finally:
            self.restart_in_progress = False
            self.restart_thread = None

    def _force_reload_current_map_for_external_ego(self):
        """Force reload current map without cleanup - used when external ego removed on large map."""
        if self.restart_in_progress:
            return False

        # Save scenario for reload
        if self.current_scenario_path:
            self.pending_scenario_load = self.current_scenario_path

        # Get current map name
        current_map = None
        if self.world_map:
            current_map = self.world_map.name
        if not current_map and self.cached_map:
            current_map = self.cached_map.name

        if not current_map:
            print("[External Ego] Cannot determine current map for reload")
            return False

        print(f"[External Ego] Force reloading map '{current_map}' to clear state...")

        self.restart_in_progress = True
        self.ready = False
        self.loading_stage = "Reloading map after external ego removal..."

        # Run in thread
        self.restart_thread = threading.Thread(
            target=self._perform_fast_map_reload,
            args=(current_map,),
            daemon=True
        )
        self.restart_thread.start()
        return True

    def _perform_fast_map_reload(self, map_name):
        """Kill CARLA server and spawn fresh VSE - used when CARLA is frozen."""
        try:
            # Unregister CARLA tick callbacks BEFORE killing server (prevents crash in old process)
            self._unregister_world_tick_handler()
            if self.camera_processor:
                self.camera_processor._manual_control_unregister_tick_callback()

            # Just clear references, don't try to destroy (CARLA is frozen)
            if self.camera_processor:
                self.camera_processor.spawned_vehicles = []
                self.camera_processor.ego_vehicle = None
                self.camera_processor = None

            self.external_ego_actor = None
            self.external_ego_actor_id = None
            self.world = None
            self.client = None

            # Kill ALL CARLA processes - there may be zombie processes
            self.loading_stage = "Killing ALL CARLA processes..."
            print("[External Ego] Killing ALL CARLA processes...")
            self.server_manager.kill_existing_carla_processes()

            # Spawn new editor process - it will start fresh CARLA
            self.loading_stage = "Spawning new editor..."
            cmd = [sys.executable] + sys.argv
            env = os.environ.copy()

            # Don't pass server PID - we killed it, new VSE should start fresh
            env.pop('VSE_SERVER_PID', None)

            env['VSE_WINDOWED_WIDTH'] = str(int(self.windowed_width))
            env['VSE_WINDOWED_HEIGHT'] = str(int(self.windowed_height))
            env['VSE_SCREEN_WIDTH'] = str(int(self.screen_width))
            env['VSE_SCREEN_HEIGHT'] = str(int(self.screen_height))
            env['VSE_WINDOW_MAXIMIZED'] = '1' if self.maximized else '0'

            if self.pending_scenario_load:
                env['VSE_PENDING_SCENARIO'] = self.pending_scenario_load
                print(f"[External Ego] Passing pending scenario: {self.pending_scenario_load}")

            # Pass map package so new VSE can do INI patching before starting CARLA
            if map_name:
                startup_map = map_name if map_name.startswith('/Game/') else f'/Game/{map_name}'
                env['VSE_STARTUP_MAP_PACKAGE'] = startup_map
                print(f"[External Ego] Passing startup map: {startup_map}")

            handoff_read_fd, handoff_write_fd = os.pipe()
            env['VSE_HANDOFF_FD'] = str(handoff_write_fd)
            self.handoff_read_fd = handoff_read_fd
            pass_fds = (handoff_write_fd,)
            try:
                self.relaunch_process = subprocess.Popen(cmd, env=env, pass_fds=pass_fds)
            except Exception as launch_error:
                raise RuntimeError(f"Failed to reload editor: {launch_error}")
            finally:
                try:
                    os.close(handoff_write_fd)
                except OSError:
                    pass

            # Hard exit immediately - don't wait for child
            # The normal wait state causes CARLA C++ threads to crash when the connection dies
            # os._exit() skips all Python cleanup and C++ destructors that would timeout
            print("[External Ego] New editor spawned - exiting old process immediately")
            os._exit(0)

        except Exception as e:
            print(f"[External Ego] Fast map reload failed: {e}")
            traceback.print_exc()
            self.startup_error = str(e)
            self.loading_stage = f"Error: {e}"
        finally:
            self.restart_in_progress = False
            self.restart_thread = None

    def _extract_scenario_map_name(self, file_path: str) -> Optional[str]:
        """Return the scenario's required map name (short form) or None."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as exc:
            raise RuntimeError(f"Failed to read scenario JSON: {exc}") from exc

        if not isinstance(data, dict):
            return None

        raw = data.get('map_name')
        if raw is None:
            return None
        map_name = str(raw).strip()
        if not map_name or map_name.lower() == 'unknown':
            return None
        return map_name

    def _resolve_carla_maps_root(self) -> Path:
        """Return the CARLA content maps root directory."""
        carla_root = os.environ.get('CARLA_ROOT')
        if not carla_root:
            raise RuntimeError("CARLA_ROOT is not set.")
        maps_root = Path(carla_root) / 'CarlaUE4' / 'Content' / 'Carla' / 'Maps'
        if not maps_root.is_dir():
            raise RuntimeError(f"CARLA maps directory not found: {maps_root}")
        return maps_root

    def _resolve_map_package_path(self, map_name: str) -> Optional[str]:
        """
        Resolve a scenario map name to a CARLA package map path (e.g. /Game/Carla/Maps/Town03).
        Returns None if no matching .umap exists under CARLA_ROOT/CarlaUE4/Content/Carla/Maps.
        """
        map_name = (map_name or '').strip()
        if not map_name or map_name.lower() == 'unknown':
            return None
        # Large maps are composed of streamed tiles named <MapName>_Tile_X_Y. Always resolve
        # to the root <MapName> level so CARLA can stream tiles automatically.
        last_segment = map_name.split('/')[-1]
        if "_Tile_" in last_segment:
            map_name = last_segment.split("_Tile_")[0].strip()
            if not map_name:
                return None
        if map_name.startswith('/Game/'):
            return map_name

        maps_root = self._resolve_carla_maps_root()
        direct = maps_root / f"{map_name}.umap"
        if direct.is_file():
            rel = direct.relative_to(maps_root).with_suffix('')
            return f"/Game/Carla/Maps/{rel.as_posix()}"

        nested = maps_root / map_name / f"{map_name}.umap"
        if nested.is_file():
            rel = nested.relative_to(maps_root).with_suffix('')
            return f"/Game/Carla/Maps/{rel.as_posix()}"

        matches = sorted(maps_root.rglob(f"{map_name}.umap"), key=lambda p: str(p))
        if not matches:
            return None
        rel = matches[0].relative_to(maps_root).with_suffix('')
        return f"/Game/Carla/Maps/{rel.as_posix()}"

    def _list_local_startup_maps(self) -> List[Dict[str, str]]:
        """Return available local CARLA maps (no server required)."""
        maps_root = self._resolve_carla_maps_root()
        entries = []

        for umap_path in maps_root.rglob("*.umap"):
            try:
                rel = umap_path.relative_to(maps_root)
            except Exception:
                continue
            if any(part.lower() == "sublevels" for part in rel.parts):
                continue
            if any(part.lower() == "testmaps" for part in rel.parts):
                continue

            short_name = umap_path.stem
            # Large Maps (e.g. Town11/12 or RoadRunner imports) generate per-tile levels named
            # <MapName>_Tile_X_Y; only the root <MapName> level should be selectable on startup.
            if "_Tile_" in short_name:
                continue
            if short_name == "OpenDriveMap":
                continue
            if short_name.lower() == "emptymap":
                continue

            rel_noext = rel.with_suffix("").as_posix()
            map_value = f"/Game/Carla/Maps/{rel_noext}"
            entries.append({
                "short_name": short_name,
                "rel": rel_noext,
                "map_value": map_value,
            })

        entries.sort(key=lambda item: item["map_value"].lower())

        name_counts: Dict[str, int] = {}
        for entry in entries:
            name_counts[entry["short_name"]] = name_counts.get(entry["short_name"], 0) + 1

        options: List[Dict[str, str]] = []
        for entry in entries:
            short_name = entry["short_name"]
            rel_noext = entry["rel"]
            if name_counts.get(short_name, 0) > 1:
                label = f"{short_name} ({rel_noext})"
            else:
                label = short_name
            options.append({
                "label": label,
                "map_name": short_name,
                "map_value": entry["map_value"],
            })

        options.sort(key=lambda item: item["label"].lower())
        return options

    def _patch_default_engine_ini(self, ini_path: Path, map_value: str) -> None:
        """Patch GameMapsSettings default maps inside a DefaultEngine.ini."""
        target_section = "[/Script/EngineSettings.GameMapsSettings]"
        keys = ("EditorStartupMap", "GameDefaultMap", "ServerDefaultMap")

        text = ini_path.read_text(encoding='utf-8', errors='replace')
        lines = text.splitlines()

        seen = {k: False for k in keys}
        out: List[str] = []
        in_section = False

        for line in lines:
            if line.startswith("[") and line.endswith("]"):
                if in_section:
                    for k in keys:
                        if not seen[k]:
                            out.append(f"{k}={map_value}")
                    in_section = False

                if line.strip() == target_section:
                    in_section = True
                    out.append(line)
                    continue

            if in_section:
                replaced = False
                for k in keys:
                    if line.startswith(k + "="):
                        out.append(f"{k}={map_value}")
                        seen[k] = True
                        replaced = True
                        break
                if not replaced:
                    out.append(line)
            else:
                out.append(line)

        if in_section:
            for k in keys:
                if not seen[k]:
                    out.append(f"{k}={map_value}")

        patched = "\n".join(out) + "\n"
        tmp_path = ini_path.with_suffix(ini_path.suffix + ".tmp")
        tmp_path.write_text(patched, encoding='utf-8')
        os.replace(tmp_path, ini_path)

    def _get_default_engine_ini_path(self) -> Optional[Path]:
        """Return CARLA's DefaultEngine.ini path, or None when CARLA_ROOT is unset."""
        carla_root = os.environ.get('CARLA_ROOT')
        if not carla_root:
            return None
        return Path(carla_root) / 'CarlaUE4' / 'Config' / 'DefaultEngine.ini'

    def _get_default_engine_ini_backup_path(self, ini_path: Path) -> Path:
        """Return VSE's crash-safe backup path for DefaultEngine.ini."""
        return ini_path.with_suffix(ini_path.suffix + ".vse_runtime_backup")

    def _restore_default_engine_ini_backup_if_present(self) -> None:
        """Restore DefaultEngine.ini if a previous crash left a backup behind."""
        ini_path = self._get_default_engine_ini_path()
        if not ini_path:
            return
        backup_path = self._get_default_engine_ini_backup_path(ini_path)
        if not backup_path.is_file():
            return
        try:
            print(f"[CARLA INI] Restoring DefaultEngine.ini from backup: {backup_path}")
            os.replace(backup_path, ini_path)
            print("[CARLA INI] DefaultEngine.ini restored.")
        except Exception as exc:
            print(f"[CARLA INI] Failed to restore DefaultEngine.ini backup: {exc}")

    def _backup_and_patch_default_engine_ini_for_startup(self, map_value: str) -> None:
        """
        Temporarily patch CARLA_ROOT/CarlaUE4/Config/DefaultEngine.ini to boot into the requested map.
        The original file is saved as a backup and restored once startup completes.
        """
        ini_path = self._get_default_engine_ini_path()
        if not ini_path:
            raise RuntimeError("CARLA_ROOT is not set.")
        if not ini_path.is_file():
            raise RuntimeError(f"DefaultEngine.ini not found: {ini_path}")

        backup_path = self._get_default_engine_ini_backup_path(ini_path)
        if backup_path.exists():
            # Leftover from crash: try to restore first so we snapshot a clean original.
            try:
                os.replace(backup_path, ini_path)
                print("[CARLA INI] Restored leftover DefaultEngine.ini backup before patching.")
            except Exception as exc:
                raise RuntimeError(f"Failed to restore leftover DefaultEngine.ini backup: {exc}") from exc

        shutil.copy2(ini_path, backup_path)
        self._default_engine_ini_backup_path = backup_path
        try:
            self._patch_default_engine_ini(ini_path, map_value)
        except Exception:
            # Ensure we don't leave a partially patched ini behind.
            self._restore_default_engine_ini_backup()
            raise
        print(f"[CARLA INI] Patched DefaultEngine.ini for startup map: {map_value}")

    def _restore_default_engine_ini_backup(self) -> None:
        """Restore DefaultEngine.ini from the active backup, if any."""
        backup_path = getattr(self, "_default_engine_ini_backup_path", None)
        if not backup_path:
            return
        self._default_engine_ini_backup_path = None
        if not isinstance(backup_path, Path):
            return
        if not backup_path.is_file():
            return
        ini_path = backup_path.with_suffix("")
        try:
            os.replace(backup_path, ini_path)
            print("[CARLA INI] DefaultEngine.ini restored after startup.")
        except Exception as exc:
            print(f"[CARLA INI] Failed to restore DefaultEngine.ini after startup: {exc}")

    def _begin_startup_for_scenario(self, scenario_path: str, map_name: str, map_value: str) -> None:
        """Transition out of the start screen and begin startup for a local scenario."""
        self.startup_error = None
        self.loading_stage = f"Preparing map '{map_name}'..."
        self._startup_selected_scenario_path = scenario_path
        self._startup_selected_map_name = map_name
        self._startup_selected_map_package = map_value
        self.pending_scenario_load = scenario_path
        self.start_screen_active = False
        self.ready = False
        self._startup_thread_started = False
        self._startup_requested = True

    def _begin_startup_for_map(self, map_name: str, map_value: str) -> None:
        """Transition out of the start screen and begin startup for a local map."""
        self.startup_error = None
        self.loading_stage = f"Preparing map '{map_name}'..."
        self._startup_selected_scenario_path = None
        self._startup_selected_map_name = map_name
        self._startup_selected_map_package = map_value
        self.pending_scenario_load = None
        self.start_screen_active = False
        self.ready = False
        self._startup_thread_started = False
        self._startup_requested = True

    def _startup_entrypoint(self) -> None:
        """Wrapper that runs the normal startup sequence."""
        try:
            self.startup_sequence()
        finally:
            # Always restore DefaultEngine.ini after attempting startup so we don't leave CARLA_ROOT modified.
            self._restore_default_engine_ini_backup()
            self._startup_requested = False
            if self.startup_error and not self.ready:
                self.start_screen_active = True
                self._startup_thread_started = False
                self._startup_selected_scenario_path = None
                self._startup_selected_map_name = None
                self._startup_selected_map_package = None
                self.pending_scenario_load = None
        
    def startup_sequence(self):
        """Complete startup sequence with a single managed retry on failure."""
        max_attempts = 2
        attempt = 0

        while attempt < max_attempts:
            profile = self.connection_profile
            host = profile.host
            port = profile.port
            try:
                print(f"[Startup] Beginning startup for profile '{profile.name}' ({host}:{port}), manage_server={profile.manage_server}")

                if profile.manage_server:
                    startup_map_value = None
                    if self._startup_requested and self._startup_selected_map_package:
                        startup_map_value = self._startup_selected_map_package

                    if startup_map_value:
                        self.loading_stage = (
                            f"Configuring CARLA startup map "
                            f"'{self._startup_selected_map_name or startup_map_value}'..."
                        )
                        self._backup_and_patch_default_engine_ini_for_startup(startup_map_value)

                    self.loading_stage = "Starting CARLA server..."
                    self.server_manager.set_port(port)
                    try:
                        self.server_manager.start_server()
                    finally:
                        if startup_map_value:
                            self._restore_default_engine_ini_backup()

                    updated_port = self.server_manager.port
                    if updated_port != port:
                        port = updated_port
                        profile.port = updated_port
                        self.local_port = updated_port
                        print(f"[Startup] Updated managed port to {updated_port}")

                    self.loading_stage = "Waiting for server to be ready..."
                    if not self.server_manager.wait_for_server():
                        raise Exception("CARLA server failed to start within timeout period")
                    print("[Startup] Local CARLA server is ready.")
                else:
                    self.loading_stage = f"Waiting for remote server ({host}:{port})..."
                    if not self._wait_for_remote_server(host, port):
                        raise Exception("Remote CARLA server failed to respond within timeout period")
                    print(f"[Startup] Remote CARLA endpoint at {host}:{port} confirmed reachable.")

                # Stage 3: Connect client
                self.loading_stage = "Connecting to CARLA..."
                self.client = carla.Client(host, port)
                self.client.set_timeout(10.0)
                print("[Startup] CARLA client established.")

                requested_remote_map = None
                if profile.is_remote and self.pending_map_switch:
                    requested_remote_map = self.pending_map_switch
                    self.pending_map_switch = None
                elif profile.is_remote and self.pending_remote_map:
                    requested_remote_map = self.pending_remote_map
                    self.pending_remote_map = None

                # Stage 4: Get world
                self.loading_stage = "Loading world..."
                self.world = self.client.get_world()
                # CARLA RPC can become ready slightly before the world/map finishes loading.
                # Waiting for at least one tick helps avoid rare CARLA Python API crashes on world.get_map().
                is_sync = False
                try:
                    settings_probe = self.world.get_settings()
                    is_sync = bool(getattr(settings_probe, "synchronous_mode", False))
                except Exception:
                    settings_probe = None

                ticked = False
                if hasattr(self.world, "wait_for_tick"):
                    self.loading_stage = "Waiting for CARLA world to initialize..."
                    tick_timeout = 30.0 if not is_sync else 2.0
                    ticked = self._wait_for_world_tick(
                        self.world,
                        timeout=tick_timeout,
                        min_ticks=2,
                        label="startup",
                    )

                if not ticked:
                    if not is_sync and hasattr(self.world, "wait_for_tick"):
                        raise RuntimeError("CARLA world did not start ticking after connect; map may not be ready.")
                    # In synchronous mode we might not receive ticks yet. Give CARLA a moment to settle
                    # before querying the map to reduce the risk of CARLA API crashes.
                    if is_sync:
                        time.sleep(2.0)
                self.world_map = self.world.get_map()
                self.cached_map = self.world_map

                if requested_remote_map:
                    requested_short = requested_remote_map.split('/')[-1]
                    current_short = self.world_map.name.split('/')[-1] if self.world_map else ""
                    if requested_short != current_short:
                        if not self._load_remote_map(requested_remote_map):
                            return False
                    else:
                        print(f"[Remote Map] '{requested_short}' already active on remote server.")

                print(f"Connected to CARLA world: {self.world_map.name} ({host}:{port})")
                self.large_map_active = is_large_map_name(getattr(self.world_map, "name", None))
                if self.large_map_active:
                    print(f"[Startup] Large map detected; UI settle delay={self.large_map_ui_delay:.1f}s")

                try:
                    settings = self.world.get_settings()
                except Exception as exc:
                    settings = None
                    print(f"Unable to retrieve world settings: {exc}")

                # Stage 5: Configure map settings where possible
                if profile.manage_server and settings is not None:
                    self.loading_stage = "Configuring map settings..."
                    print("Using default world settings (no large-map streaming overrides).")
                elif profile.manage_server:
                    self.loading_stage = "Configuring map settings..."
                    print("Skipping map configuration; unable to retrieve settings from local server.")
                else:
                    self.loading_stage = "Inspecting remote map..."
                    if settings is not None:
                        print("Retrieved remote world settings")
                    else:
                        print("Unable to inspect remote world settings.")

                self.manual_tick_required = False
                self.manual_tick_accumulator = 0.0
                self.manual_tick_enabled = False
                self.manual_tick_recommendation = False

                # Default to CARLA's no-rendering mode for higher editor FPS unless the user enables it.
                self._apply_rendering_mode(
                    desired_enabled=self._rendering_desired_enabled,
                    reason="initial configuration",
                )

                if profile.is_remote and settings is not None:
                    if getattr(settings, 'synchronous_mode', False):
                        interval = settings.fixed_delta_seconds or 0.05
                        if interval <= 0:
                            interval = 0.05
                        self.manual_tick_required = True
                        self.manual_tick_interval = interval
                        self.manual_tick_accumulator = 0.0
                        self.manual_tick_enabled = False
                        self.manual_tick_recommendation = True
                        wait_for_control = getattr(settings, 'synchronous_mode_wait_for_vehicle_control_command', False)
                        if wait_for_control:
                            print("[Startup] Remote server awaits vehicle control; enable 'Drive Clock' only if no other controller is active.")
                        else:
                            print("[Startup] Remote server in synchronous mode; use 'Drive Clock' toggle if frames do not stream.")
                    else:
                        print("[Startup] Remote server is asynchronous; no manual ticking needed.")

                # Stage 6: Set up camera at world origin
                self.loading_stage = "Setting up visual scenario editor..."

                # Start at world origin - safe for all maps including large maps
                center_x, center_y = 0, 0
                print("Starting at world origin (0, 0, 200)")

                # Set up camera system
                self.camera_controller = TopDownCamera(center_x, center_y, 200)
                self.camera_controller.world = self.world  # Set world reference for debug raycast

                # Stage 7: Position spectator at world origin
                spectator = self.world.get_spectator()
                spectator_transform = carla.Transform(
                    carla.Location(x=0, y=0, z=200),
                    carla.Rotation(pitch=-90, yaw=0, roll=0)  # Looking down
                )
                spectator.set_transform(spectator_transform)

                # Stage 8: Now safe to spawn camera sensor and do raycasting
                self.loading_stage = "Setting up camera sensor..."
                self.camera_processor = CameraImageProcessor(
                    self.world,
                    self.camera_controller,
                    self.screen_width,
                    self.screen_height,
                    self,
                    stream_resolution=self.stream_resolution,
                    stream_fps=self.stream_fps if self._using_remote_server() else 0,
                )
                if self.vehicle_menu:
                    self.vehicle_menu.set_camera_processor(self.camera_processor)
                if self.pedestrian_menu:
                    self.pedestrian_menu.set_camera_processor(self.camera_processor)
                if self.ego_vehicle_menu:
                    self.ego_vehicle_menu.set_camera_processor(self.camera_processor)
                if getattr(self, "traffic_light_group_menu", None):
                    self.traffic_light_group_menu.set_camera_processor(self.camera_processor)
                if not self.camera_stream_enabled:
                    self._apply_stream_settings()
                if self.cached_map is not None:
                    self.camera_processor.coordinate_detector.world_map = self.cached_map

                # Pass server details to camera processor for map reload helpers
                self.camera_processor._server_port = port
                self.camera_processor._server_host = host
                print("[Startup] Camera processor initialized.")

                # Initialize info panel with camera processor reference
                self.info_panel = InfoPanel(self.camera_processor)

                # Initialize vehicle menu
                self.vehicle_menu.initialize_vehicles(self.world)
                self.pedestrian_menu.initialize_pedestrians(self.world)
                self.ego_vehicle_menu.initialize_ego_vehicle(self.world)
                print("[Startup] Actor menus initialized.")

                # Initialize map menu
                self.map_menu = MapSelectionMenu(self)
                self.map_menu.initialize()
                print("[Startup] Map menu initialized.")

                # Initialize scenario menu
                self.scenario_menu = ScenarioMenu(self)

                # Precompute OpenDRIVE lane data on startup (even though overlay is disabled)
                # This prevents issues when loading scenarios before toggling the overlay
                print("Precomputing OpenDRIVE lane data...")
                self.camera_processor.precompute_opendrive_lane_data()
                print("OpenDRIVE lane data ready")

                # Set initial minimum camera height based on terrain
                self.camera_controller.update_min_height_from_terrain(self.world, height_buffer=5.0)

                try:
                    initial_weather = self.world.get_weather()
                except Exception as exc:
                    print(f"[Weather] Unable to fetch initial weather: {exc}")
                else:
                    self._update_weather_state(initial_weather)
                    self._capture_baseline_weather(initial_weather)
                    if self.weather_window and self.weather_window.alive():
                        self.weather_window.apply_weather(initial_weather)

                # Subscribe to world tick events for reset detection
                self._register_world_tick_handler()

                pending_path = self.pending_scenario_load
                if pending_path:
                    if not os.path.isfile(pending_path):
                        print(f"[WARN] Pending scenario '{pending_path}' no longer exists; clearing handoff.")
                        self.pending_scenario_load = None
                    else:
                        self.loading_stage = "Loading scenario..."
                        print(f"Loading pending scenario: {pending_path}")
                        self.pending_scenario_load = None
                        try:
                            self._load_scenario_from_path(pending_path, prompt_unsaved=False)
                        except Exception as exc:
                            print(f"[Startup] Failed to load pending scenario '{pending_path}': {exc}")
                            traceback.print_exc()
                        if self.restart_in_progress:
                            return True

                self.loading_stage = "Ready!"
                self.ready = True
                self.remote_connection_active = profile.is_remote
                if profile.is_remote:
                    self.active_remote_port = profile.port
                    if not self.active_remote_label:
                        self.active_remote_label = f"Port {profile.port}"
                else:
                    self.active_remote_label = None
                    self.active_remote_port = None
                self._notify_handoff_ready()

                print("Visual Scenario Editor ready!")
                print(f"Connected to CARLA on {host}:{port}")
                print(f"[Startup] Startup sequence finished. Remote mode={self.remote_connection_active}")
                return True

            except Exception as e:
                print(f"Startup failed: {e}")
                traceback.print_exc()

                attempt += 1
                can_retry = profile.manage_server and attempt < max_attempts
                if not can_retry:
                    self.startup_error = str(e)
                    self.loading_stage = f"Error: {e}"
                    return False

                print("[Startup] Attempting managed CARLA restart and retry (1/1)...")
                try:
                    self.server_manager.kill_existing_carla_processes()
                except Exception as kill_exc:
                    print(f"[Startup] Warning: Failed to kill existing CARLA processes: {kill_exc}")

                self.server_manager.use_existing_server = False
                self.server_manager.process = None
                self.server_manager.known_server_pid = None

                self.world = None
                self.world_map = None
                self.client = None
                self.camera_processor = None
                self.cached_map = None

                try:
                    new_port = self.server_manager.find_available_port(self.connection_profile.port)
                    if new_port != self.connection_profile.port:
                        print(f"[Startup] Switching to alternative port {new_port} for retry.")
                    self.connection_profile.port = new_port
                    self.local_port = new_port
                    self.server_manager.set_port(new_port)
                except Exception as port_exc:
                    print(f"[Startup] Warning: unable to pick alternative port: {port_exc}")

                self.ready = False
                self.startup_error = None
                self.loading_stage = "Retrying startup after restarting CARLA..."
                time.sleep(1.0)
                continue

        return False
    
    def toggle_maximize(self):
        """Toggle between maximized and normal window size"""
        was_maximized = self.maximized

        if not was_maximized:
            surface = pygame.display.get_surface()
            if surface is not None:
                current_width, current_height = surface.get_size()
                if current_width > 0 and current_height > 0:
                    self.windowed_width = current_width
                    self.windowed_height = current_height
            else:
                self.windowed_width = self.screen_width
                self.windowed_height = self.screen_height

        self.maximized = not self.maximized
        
        if self.maximized:
            info = pygame.display.Info()
            # Leave some space for taskbar/title bar (subtract ~100 pixels)
            self.screen_width = info.current_w
            self.screen_height = max(100, info.current_h - 100)
            self.screen = pygame.display.set_mode((self.screen_width, self.screen_height), pygame.RESIZABLE)
            print(f"Window maximized: {self.screen_width}x{self.screen_height}")
        else:
            self.screen_width = self.windowed_width
            self.screen_height = self.windowed_height
            self.screen = pygame.display.set_mode((self.screen_width, self.screen_height), pygame.RESIZABLE)
            print(f"Window restored to: {self.screen_width}x{self.screen_height}")

        if self.ui_manager:
            self.ui_manager.set_window_resolution((self.screen_width, self.screen_height))
        
        # Update camera processor with new screen size
        if self.camera_processor:
            self.camera_processor.update_screen_size(self.screen_width, self.screen_height)
    
    def calculate_acceleration_factor(self, hold_time):
        """Calculate acceleration factor based on how long key has been held"""
        if hold_time <= 0:
            return 0.1
        
        normalized_time = min(hold_time / self.max_acceleration_time, 1.0)
        acceleration_factor = pow(normalized_time, 1.0 / self.acceleration_curve)
        return 0.1 + (0.9 * acceleration_factor)
    
    def show_exit_confirmation(self):
        """Show exit confirmation dialog and return True if user wants to exit."""
        self._close_all_dropdowns(keep_info_panel=True)
        dialog_rect = self._center_dialog_rect(380, 220)
        dialog = UIConfirmationDialog(
            rect=dialog_rect,
            action_long_desc=(
                "Are you sure you want to exit the Visual Scenario Editor?<br><br>"
                "All unsaved changes will be lost."
            ),
            manager=self.ui_manager,
            window_title="Exit Confirmation",
            action_short_name="Yes",
            blocking=True,
        )

        def handler(event: pygame.event.Event):
            if event.type == UI_CONFIRMATION_DIALOG_CONFIRMED and event.ui_element == dialog:
                return True, True
            if event.type == UI_BUTTON_PRESSED and event.ui_element == dialog.confirm_button:
                return True, True
            if event.type == UI_WINDOW_CLOSE and event.ui_element == dialog:
                return True, False
            return False, None

        result = self._run_modal_window(dialog, handler)
        return bool(result)
    

    def handle_events(self, dt):
        """Handle pygame events for user interaction and camera control."""
        blocking_window_alive = bool(self.result_window and self.result_window.alive())

        if not self.ready:
            for event in pygame.event.get():
                if self.ui_manager:
                    self.ui_manager.process_events(event)

                if event.type == pygame.QUIT:
                    if not self._handle_quit_event():
                        return False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if not self._handle_quit_event():
                            return False
                    elif event.key == pygame.K_F11:
                        self.toggle_maximize()
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    if self.start_screen_active:
                        self._handle_start_screen_click(event.pos)
                elif event.type == pygame.VIDEORESIZE:
                    self._handle_resize(event)
            return True

        camera_moved = False
        scenario_running = bool(self.scenario_running or (self.scenario_process and self.scenario_process.poll() is None))

        for event in pygame.event.get():
            if self.ui_manager:
                self.ui_manager.process_events(event)

            if event.type == pygame.QUIT:
                if not self._handle_quit_event():
                    return False
                continue

            if blocking_window_alive:
                if event.type == pygame.VIDEORESIZE:
                    self._handle_resize(event)
                # Swallow all other events while the blocking result window is open.
                continue

            if event.type == pygame.KEYDOWN:
                result = self._handle_keydown(event, scenario_running)
                if result is False:
                    return False
                if result:
                    continue

            if event.type == pygame.KEYUP:
                self._handle_keyup(event)
                continue

            if event.type == pygame.MOUSEBUTTONDOWN:
                if self._handle_mouse_button_down(event, scenario_running):
                    continue

            if event.type == pygame.MOUSEBUTTONUP:
                self._handle_mouse_button_up(event)
                continue

            if event.type == pygame.MOUSEMOTION:
                if self._handle_mouse_motion(event):
                    camera_moved = True
                continue

            if event.type == pygame.MOUSEWHEEL:
                if self._handle_mouse_wheel(event, scenario_running):
                    camera_moved = True
                continue

            if event.type == pygame.VIDEORESIZE:
                self._handle_resize(event)
                continue

        for key in self.key_hold_times:
            self.key_hold_times[key] += dt

        if self.camera_controller:
            navigation_height = self.camera_controller.get_navigation_height()
            height_scale = navigation_height / 400.0
            base_keyboard_speed = 30.0 * height_scale
            arrow_allowed = not (self.camera_processor and (self.camera_processor.manual_control_enabled or self.camera_processor.manual_control_pending))
            up_pressed = pygame.K_UP in self.keys_pressed if arrow_allowed else False
            down_pressed = pygame.K_DOWN in self.keys_pressed if arrow_allowed else False
            left_pressed = pygame.K_LEFT in self.keys_pressed if arrow_allowed else False
            right_pressed = pygame.K_RIGHT in self.keys_pressed if arrow_allowed else False

            if pygame.K_w in self.keys_pressed or up_pressed:
                hold_time = self.key_hold_times.get(pygame.K_w, 0.0)
                if up_pressed:
                    hold_time = max(hold_time, self.key_hold_times.get(pygame.K_UP, 0.0))
                acceleration_factor = self.calculate_acceleration_factor(hold_time)
                speed = base_keyboard_speed * acceleration_factor
                if self.camera_processor:
                    self.camera_processor.suppress_vehicle_menu_for_camera_pan()
                    self.camera_processor.begin_manual_camera_free_look("keyboard_pan")
                self.camera_controller.pan(0, -speed, dt)
                camera_moved = True
            if pygame.K_s in self.keys_pressed or down_pressed:
                keys = pygame.key.get_pressed()
                ctrl_pressed = is_ctrl_pressed(keys)
                if not ctrl_pressed:
                    hold_time = self.key_hold_times.get(pygame.K_s, 0.0)
                    if down_pressed:
                        hold_time = max(hold_time, self.key_hold_times.get(pygame.K_DOWN, 0.0))
                    acceleration_factor = self.calculate_acceleration_factor(hold_time)
                    speed = base_keyboard_speed * acceleration_factor
                    if self.camera_processor:
                        self.camera_processor.suppress_vehicle_menu_for_camera_pan()
                        self.camera_processor.begin_manual_camera_free_look("keyboard_pan")
                    self.camera_controller.pan(0, speed, dt)
                    camera_moved = True
            if pygame.K_a in self.keys_pressed or left_pressed:
                hold_time = self.key_hold_times.get(pygame.K_a, 0.0)
                if left_pressed:
                    hold_time = max(hold_time, self.key_hold_times.get(pygame.K_LEFT, 0.0))
                acceleration_factor = self.calculate_acceleration_factor(hold_time)
                speed = base_keyboard_speed * acceleration_factor
                if self.camera_processor:
                    self.camera_processor.suppress_vehicle_menu_for_camera_pan()
                    self.camera_processor.begin_manual_camera_free_look("keyboard_pan")
                self.camera_controller.pan(-speed, 0, dt)
                camera_moved = True
            if pygame.K_d in self.keys_pressed or right_pressed:
                hold_time = self.key_hold_times.get(pygame.K_d, 0.0)
                if right_pressed:
                    hold_time = max(hold_time, self.key_hold_times.get(pygame.K_RIGHT, 0.0))
                acceleration_factor = self.calculate_acceleration_factor(hold_time)
                speed = base_keyboard_speed * acceleration_factor
                if self.camera_processor:
                    self.camera_processor.suppress_vehicle_menu_for_camera_pan()
                    self.camera_processor.begin_manual_camera_free_look("keyboard_pan")
                self.camera_controller.pan(speed, 0, dt)
                camera_moved = True

        if camera_moved and self.camera_processor:
            self.camera_processor.update_camera_position()
            self.camera_processor.notify_manual_camera_adjustment()

        return True


    def render_start_screen(self):
        """Render the initial start screen shown on normal launches."""
        self.screen.fill(self.colors['background'])
        mouse_pos = pygame.mouse.get_pos()
        center_x = self.screen_width // 2

        title_surface = self.font.render("Visual Scenario Editor", True, self.colors['text'])
        title_rect = title_surface.get_rect(center=(center_x, max(60, self.screen_height // 4)))
        self.screen.blit(title_surface, title_rect)

        subtitle_surface = self.small_font.render("Choose what to do:", True, (210, 210, 210))
        subtitle_rect = subtitle_surface.get_rect(center=(center_x, title_rect.bottom + 22))
        self.screen.blit(subtitle_surface, subtitle_rect)

        button_w = min(460, max(260, self.screen_width - 120))
        button_h = 54
        spacing = 14
        start_y = subtitle_rect.bottom + 26

        def draw_button(rect: pygame.Rect, label: str, *, enabled: bool = True) -> None:
            hovered = rect.collidepoint(mouse_pos)
            if not enabled:
                fill = (80, 80, 80)
                border = (120, 120, 120)
                text_color = (170, 170, 170)
            else:
                fill = (90, 140, 90) if hovered else (70, 120, 70)
                border = (255, 255, 255) if hovered else (210, 210, 210)
                text_color = (255, 255, 255)
            pygame.draw.rect(self.screen, fill, rect, border_radius=8)
            pygame.draw.rect(self.screen, border, rect, 2, border_radius=8)
            label_surface = self.font.render(label, True, text_color)
            label_rect = label_surface.get_rect(center=rect.center)
            self.screen.blit(label_surface, label_rect)

        scenario_rect = pygame.Rect(center_x - button_w // 2, start_y, button_w, button_h)
        map_rect = pygame.Rect(center_x - button_w // 2, scenario_rect.bottom + spacing, button_w, button_h)
        remote_rect = pygame.Rect(center_x - button_w // 2, map_rect.bottom + spacing, button_w, button_h)

        self.start_screen_open_scenario_rect = scenario_rect
        self.start_screen_open_map_rect = map_rect
        self.start_screen_connect_remote_rect = remote_rect

        draw_button(scenario_rect, "Open Scenario", enabled=True)
        draw_button(map_rect, "Open Map", enabled=True)
        draw_button(remote_rect, "Connect Remote", enabled=True)

        recent_top = remote_rect.bottom + 30
        self.start_screen_recent_scenario_rects = []
        recent_entries = getattr(self, "recent_scenarios", []) or []
        if recent_entries:
            header = self.small_font.render("Recent scenarios:", True, (210, 210, 210))
            header_rect = header.get_rect(center=(center_x, recent_top))
            self.screen.blit(header, header_rect)
            item_y = header_rect.bottom + 10
            item_h = 34
            for entry in recent_entries[:3]:
                path = entry.get('path')
                name = entry.get('name') or (os.path.basename(path) if path else "Unknown")
                map_name = entry.get('map_name') or "Unknown"
                exists = bool(entry.get('exists')) if 'exists' in entry else bool(path and os.path.isfile(path))
                label = f"{name}  ({map_name})"

                row_rect = pygame.Rect(center_x - button_w // 2, item_y, button_w, item_h)
                self.start_screen_recent_scenario_rects.append((row_rect, path))

                hovered = row_rect.collidepoint(mouse_pos)
                if exists and path:
                    fill = (70, 70, 110) if hovered else (55, 55, 90)
                    border = (200, 200, 255)
                    text_color = (235, 235, 255)
                else:
                    fill = (60, 60, 60)
                    border = (120, 120, 120)
                    text_color = (160, 160, 160)

                pygame.draw.rect(self.screen, fill, row_rect, border_radius=6)
                pygame.draw.rect(self.screen, border, row_rect, 1, border_radius=6)
                label_surface = self.small_font.render(label, True, text_color)
                label_rect = label_surface.get_rect(midleft=(row_rect.left + 10, row_rect.centery))
                self.screen.blit(label_surface, label_rect)

                item_y = row_rect.bottom + 8

        carla_root = os.environ.get('CARLA_ROOT') or "(CARLA_ROOT not set)"
        carla_surface = self.small_font.render(f"CARLA_ROOT: {carla_root}", True, (180, 180, 180))
        self.screen.blit(carla_surface, (10, self.screen_height - 28))

        if self.startup_error:
            err_surface = self.small_font.render(str(self.startup_error), True, self.colors['error'])
            err_rect = err_surface.get_rect(center=(center_x, min(self.screen_height - 60, (recent_top + 20))))
            self.screen.blit(err_surface, err_rect)

        hint_surface = self.small_font.render("ESC to quit", True, (210, 210, 210))
        hint_rect = hint_surface.get_rect(bottomright=(self.screen_width - 10, self.screen_height - 10))
        self.screen.blit(hint_surface, hint_rect)

    def _handle_start_screen_click(self, mouse_pos: Tuple[int, int]) -> bool:
        """Handle click interactions on the start screen."""
        if self.start_screen_open_scenario_rect and self.start_screen_open_scenario_rect.collidepoint(mouse_pos):
            self._start_screen_open_scenario()
            return True

        if self.start_screen_open_map_rect and self.start_screen_open_map_rect.collidepoint(mouse_pos):
            self._start_screen_open_map()
            return True

        if self.start_screen_connect_remote_rect and self.start_screen_connect_remote_rect.collidepoint(mouse_pos):
            self.startup_error = None
            self.connect_to_remote()
            return True

        for rect, path in self.start_screen_recent_scenario_rects:
            if rect.collidepoint(mouse_pos):
                if path and os.path.isfile(path):
                    self._start_screen_launch_scenario(path)
                return True

        return False

    def _start_screen_open_scenario(self) -> None:
        """Prompt for a scenario file and begin startup."""
        self.startup_error = None
        scenario_path = self._prompt_scenario_file_path()
        if not scenario_path:
            return
        self._start_screen_launch_scenario(scenario_path)

    def _start_screen_open_map(self) -> None:
        """Prompt for a map choice and begin startup."""
        self.startup_error = None
        try:
            options = self._list_local_startup_maps()
        except Exception as exc:
            self.startup_error = str(exc)
            return

        if not options:
            self.startup_error = "No CARLA maps found under CARLA_ROOT."
            return

        picked = self._prompt_startup_map_choice(options)
        if not picked:
            return

        map_name = (picked.get("map_name") or picked.get("label") or "").strip()
        map_value = (picked.get("map_value") or "").strip()
        if not map_name or not map_value:
            self.startup_error = "Invalid map selection."
            return

        self.connection_profile = self._create_local_profile()
        self.server_manager.set_port(self.connection_profile.port)
        self._begin_startup_for_map(map_name, map_value)

    def _start_screen_launch_scenario(self, scenario_path: str) -> None:
        """Validate scenario, resolve map, and begin local startup."""
        if not scenario_path or not os.path.isfile(scenario_path):
            self.startup_error = "Scenario file not found."
            return

        try:
            map_name = self._extract_scenario_map_name(scenario_path)
        except Exception as exc:
            self.startup_error = str(exc)
            return

        if not map_name:
            self.startup_error = "Scenario is missing map_name (or map_name is Unknown)."
            return

        try:
            map_value = self._resolve_map_package_path(map_name)
        except Exception as exc:
            self.startup_error = str(exc)
            return
        if not map_value:
            self.startup_error = f"Map '{map_name}' not found under CARLA_ROOT CarlaUE4/Content/Carla/Maps."
            return

        self.connection_profile = self._create_local_profile()
        self.server_manager.set_port(self.connection_profile.port)
        self._begin_startup_for_scenario(scenario_path, map_name, map_value)

    def render_loading_screen(self):
        """Render loading screen"""
        self.screen.fill(self.colors['background'])
        
        # Loading title
        title_text = self.font.render("Visual Scenario Editor", True, self.colors['text'])
        title_rect = title_text.get_rect(center=(self.screen_width//2, self.screen_height//2 - 100))
        self.screen.blit(title_text, title_rect)
        
        # Loading status
        color = self.colors['error'] if self.startup_error else self.colors['loading']
        status_text = self.font.render(self.loading_stage, True, color)
        status_rect = status_text.get_rect(center=(self.screen_width//2, self.screen_height//2))
        self.screen.blit(status_text, status_rect)
        
        if not self.startup_error:
            # Progress animation (simple dots)
            dots = "." * (int(time.time() * 2) % 4)
            dots_text = self.font.render(dots, True, self.colors['loading'])
            dots_rect = dots_text.get_rect(center=(self.screen_width//2, self.screen_height//2 + 30))
            self.screen.blit(dots_text, dots_rect)
        else:
            # Show error details
            error_text = self.small_font.render("Check console for details", True, self.colors['error'])
            error_rect = error_text.get_rect(center=(self.screen_width//2, self.screen_height//2 + 30))
            self.screen.blit(error_text, error_rect)
        
        # Instructions
        instruction_text = self.small_font.render("ESC to cancel", True, self.colors['text'])
        instruction_rect = instruction_text.get_rect(center=(self.screen_width//2, self.screen_height//2 + 80))
        self.screen.blit(instruction_text, instruction_rect)

    def _render_external_swap_overlay(self):
        """Render a non-blocking overlay while an external ego is being adopted."""
        if not getattr(self, "_external_swap_overlay", False):
            return
        overlay = pygame.Surface((self.screen_width, self.screen_height), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 140))
        self.screen.blit(overlay, (0, 0))

        message = self._external_swap_overlay_message or "Adopting external ego..."
        try:
            elapsed = time.time() - self._external_swap_overlay_started_at if self._external_swap_overlay_started_at else 0.0
        except Exception:
            elapsed = 0.0
        dots = "." * (int(elapsed * 2) % 4)
        msg_surface = self.font.render(f"{message}{dots}", True, self.colors['text'])
        msg_rect = msg_surface.get_rect(center=(self.screen_width // 2, self.screen_height // 2))
        self.screen.blit(msg_surface, msg_rect)

        sub_text = "Please wait; external ego is connecting."
        sub_surface = self.small_font.render(sub_text, True, self.colors['text'])
        sub_rect = sub_surface.get_rect(center=(self.screen_width // 2, self.screen_height // 2 + 28))
        self.screen.blit(sub_surface, sub_rect)
        if self._external_swap_overlay_keep_until and time.time() >= self._external_swap_overlay_keep_until:
            self._clear_external_swap_overlay()

    def _render_external_swap_overlay_immediate(self):
        """Render and display the overlay once, useful right as swap work begins."""
        try:
            self._render_external_swap_overlay()
            pygame.display.flip()
        except Exception:
            pass

    def _truncate_text_to_width(self, font, text: str, max_width: int) -> str:
        """Return text truncated with ASCII ellipsis to fit within max_width."""
        if not text or max_width <= 0:
            return ""
        if font.size(text)[0] <= max_width:
            return text
        ellipsis = "..."
        ellipsis_width = font.size(ellipsis)[0]
        if ellipsis_width >= max_width:
            return ellipsis
        target_width = max_width - ellipsis_width
        trimmed = text
        while trimmed and font.size(trimmed)[0] > target_width:
            trimmed = trimmed[:-1]
        return f"{trimmed}{ellipsis}" if trimmed else ellipsis

    def render_ui(self):
        """Render UI elements overlay"""
        # Semi-transparent background for UI (smaller height)
        ui_height = self.top_ui_height
        ui_surface = pygame.Surface((self.screen_width, ui_height))
        ui_surface.set_alpha(180)
        ui_surface.fill((30, 30, 30))
        self.screen.blit(ui_surface, (0, 0))

        mouse_pos = pygame.mouse.get_pos()
        self.connection_button_rect = None
        self.gpu_button_rect = None
        self.resolution_button_rect = None
        self.fps_button_rect = None
        self.agent_button_rect = None
        self.agent_button_enabled = False
        self.resolution_option_rects = []
        self.fps_option_rects = []
        dropdown_draw_ops: List[Tuple[pygame.Rect, Tuple[int, int, int], pygame.Surface]] = []
        row_y = 10
        button_height = 30
        button_spacing = 10
        next_x = 10

        # Map selector button
        map_display_name = self._get_map_display_name()
        map_label_full = map_display_name if map_display_name != "Unknown" else "Open Map"
        map_label_full_surface = self.small_font.render(map_label_full, True, self.colors['text'])
        map_button_max_width = max(80, min(260, self.screen_width - 20))
        map_button_width = max(140, map_label_full_surface.get_width() + 24)
        map_button_width = min(map_button_width, map_button_max_width)
        map_label_display = self._truncate_text_to_width(self.small_font, map_label_full, map_button_width - 24)
        map_label_surface = self.small_font.render(map_label_display, True, self.colors['text'])
        map_button_rect = pygame.Rect(next_x, row_y, map_button_width, button_height)
        is_map_hovered = map_button_rect.collidepoint(mouse_pos)
        map_button_color = (80, 120, 170) if is_map_hovered else (60, 90, 140)

        pygame.draw.rect(self.screen, map_button_color, map_button_rect, border_radius=6)
        pygame.draw.rect(self.screen, self.colors['text'], map_button_rect, 1, border_radius=6)
        map_label_rect = map_label_surface.get_rect(center=map_button_rect.center)
        prev_clip = self.screen.get_clip()
        self.screen.set_clip(map_button_rect)
        self.screen.blit(map_label_surface, map_label_rect)
        self.screen.set_clip(prev_clip)
        self.open_map_button_rect = map_button_rect
        if is_map_hovered and self.tooltip_manager:
            map_tooltip = TOP_UI_BUTTON_TOOLTIPS.get('map', '')
            if map_label_display != map_label_full:
                map_tooltip = f"{map_tooltip}: {map_label_full}" if map_tooltip else map_label_full
            self.tooltip_manager.register_hover("map_button", map_button_rect, map_tooltip)

        next_x = map_button_rect.right + button_spacing

        # Connection toggle button (Local/Remote)
        is_remote = bool(self.connection_profile and self.connection_profile.is_remote)
        connection_label = "Remote" if is_remote else "Local"
        connection_label_surface = self.small_font.render(connection_label, True, self.colors['text'])
        connection_button_width = max(110, connection_label_surface.get_width() + 24)
        connection_rect = pygame.Rect(next_x, row_y, connection_button_width, button_height)
        is_connection_hovered = connection_rect.collidepoint(mouse_pos)
        if is_remote:
            connection_color = (150, 110, 60) if is_connection_hovered else (125, 90, 45)
        else:
            connection_color = (70, 140, 80) if is_connection_hovered else (55, 110, 60)

        pygame.draw.rect(self.screen, connection_color, connection_rect, border_radius=6)
        pygame.draw.rect(self.screen, self.colors['text'], connection_rect, 1, border_radius=6)
        connection_label_rect = connection_label_surface.get_rect(center=connection_rect.center)
        self.screen.blit(connection_label_surface, connection_label_rect)
        self.connection_button_rect = connection_rect
        if is_connection_hovered and self.tooltip_manager:
            self.tooltip_manager.register_hover("connection_button", connection_rect, TOP_UI_BUTTON_TOOLTIPS.get('connection', ''))

        next_x = connection_rect.right + button_spacing

        self.gpu_button_rect = None

        # Stream resolution selector (always visible)
        res_width, res_height = self.stream_resolution
        resolution_label = f"{res_width}x{res_height}" if self.camera_stream_enabled else "No Camera"
        resolution_surface = self.small_font.render(resolution_label, True, self.colors['text'])
        resolution_button_width = max(150, resolution_surface.get_width() + 24)
        resolution_rect = pygame.Rect(next_x, row_y, resolution_button_width, button_height)
        is_resolution_hovered = resolution_rect.collidepoint(mouse_pos)
        if self._using_remote_server():
            resolution_color = (90, 120, 180) if is_resolution_hovered else (70, 95, 150)
        else:
            resolution_color = (110, 110, 110) if is_resolution_hovered else (85, 85, 85)

        pygame.draw.rect(self.screen, resolution_color, resolution_rect, border_radius=6)
        pygame.draw.rect(self.screen, self.colors['text'], resolution_rect, 1, border_radius=6)
        resolution_label_rect = resolution_surface.get_rect(center=resolution_rect.center)
        self.screen.blit(resolution_surface, resolution_label_rect)
        self.resolution_button_rect = resolution_rect
        if is_resolution_hovered and self.tooltip_manager:
            self.tooltip_manager.register_hover("resolution_button", resolution_rect, TOP_UI_BUTTON_TOOLTIPS.get('resolution', ''))
        next_x = resolution_rect.right + button_spacing

        if self.resolution_menu_open:
            option_height = button_height
            menu_top = resolution_rect.bottom + 2
            for idx, option in enumerate(self.remote_resolution_options):
                option_rect = pygame.Rect(
                    resolution_rect.left,
                    menu_top + idx * option_height,
                    resolution_button_width,
                    option_height,
                )
                is_selected = (
                    (option is None and not self.camera_stream_enabled)
                    or (
                        option is not None
                        and self.camera_stream_enabled
                        and option == self.stream_resolution
                    )
                )
                is_hovered = option_rect.collidepoint(mouse_pos)
                if self._using_remote_server():
                    base_color = (90, 120, 180) if is_hovered else (60, 85, 130)
                    selected_color = (120, 150, 200)
                else:
                    base_color = (110, 110, 110) if is_hovered else (70, 70, 70)
                    selected_color = (140, 140, 140)
                draw_color = selected_color if is_selected else base_color
                option_label = "No Camera" if option is None else f"{option[0]}x{option[1]}"
                option_surface = self.small_font.render(option_label, True, self.colors['text'])
                self.resolution_option_rects.append((option_rect, option))
                dropdown_draw_ops.append((option_rect, draw_color, option_surface))

        # FPS selector (remote only)
        if self._using_remote_server():
            fps_label = f"{self.stream_fps} FPS"
            fps_surface = self.small_font.render(fps_label, True, self.colors['text'])
            fps_button_width = max(120, fps_surface.get_width() + 24)
            fps_rect = pygame.Rect(next_x, row_y, fps_button_width, button_height)
            is_fps_hovered = fps_rect.collidepoint(mouse_pos)
            fps_color = (110, 110, 110) if is_fps_hovered else (80, 80, 80)

            pygame.draw.rect(self.screen, fps_color, fps_rect, border_radius=6)
            pygame.draw.rect(self.screen, self.colors['text'], fps_rect, 1, border_radius=6)
            fps_label_rect = fps_surface.get_rect(center=fps_rect.center)
            self.screen.blit(fps_surface, fps_label_rect)
            self.fps_button_rect = fps_rect
            if is_fps_hovered and self.tooltip_manager:
                self.tooltip_manager.register_hover("fps_button", fps_rect, TOP_UI_BUTTON_TOOLTIPS.get('fps', ''))
            next_x = fps_rect.right + button_spacing

            if self.fps_menu_open:
                option_height = button_height
                menu_top = fps_rect.bottom + 2
                for idx in range(self.remote_fps_min, self.remote_fps_max + 1):
                    option_rect = pygame.Rect(
                        fps_rect.left,
                        menu_top + (idx - self.remote_fps_min) * option_height,
                        fps_button_width,
                        option_height,
                    )
                    is_selected = idx == self.stream_fps
                    is_hovered = option_rect.collidepoint(mouse_pos)
                    base_color = (110, 110, 110) if is_hovered else (70, 70, 70)
                    selected_color = (140, 140, 140)
                    draw_color = selected_color if is_selected else base_color
                    option_surface = self.small_font.render(f"{idx} FPS", True, self.colors['text'])
                    self.fps_option_rects.append((option_rect, idx))
                    dropdown_draw_ops.append((option_rect, draw_color, option_surface))
        else:
            self.fps_button_rect = None
            self.fps_option_rects = []
            self.fps_menu_open = False

        # Drive Clock toggle (always visible, last in the row)
        manual_label = "Drive Clock: ON" if self.manual_tick_enabled else "Drive Clock: OFF"
        manual_label_surface = self.small_font.render(manual_label, True, self.colors['text'])
        manual_button_width = max(170, manual_label_surface.get_width() + 24)
        manual_rect = pygame.Rect(next_x, row_y, manual_button_width, button_height)
        is_manual_hovered = manual_rect.collidepoint(mouse_pos)
        if self.manual_tick_enabled:
            manual_color = (70, 160, 80) if is_manual_hovered else (50, 130, 60)
        else:
            manual_color = (150, 100, 40) if is_manual_hovered else (120, 80, 30)

        pygame.draw.rect(self.screen, manual_color, manual_rect, border_radius=6)
        pygame.draw.rect(self.screen, self.colors['text'], manual_rect, 1, border_radius=6)
        manual_label_rect = manual_label_surface.get_rect(center=manual_rect.center)
        self.screen.blit(manual_label_surface, manual_label_rect)
        if is_manual_hovered and self.tooltip_manager:
            self.tooltip_manager.register_hover("manual_tick_button", manual_rect, TOP_UI_BUTTON_TOOLTIPS.get('manual_tick', ''))

        if self.manual_tick_required and self.manual_tick_recommendation and not self.manual_tick_enabled:
            tip_text = "Enable Drive Clock for live RGB"
            tip_surface = self.small_font.render(tip_text, True, (230, 200, 120))
            tip_rect = tip_surface.get_rect()
            tip_rect.left = manual_rect.right + 8
            tip_rect.centery = manual_rect.centery
            self.screen.blit(tip_surface, tip_rect)

        self.manual_tick_button_rect = manual_rect
        next_x = manual_rect.right + button_spacing

        capture_rects: List[pygame.Rect] = []
        if self.resolution_menu_open:
            if self.resolution_button_rect:
                capture_rects.append(self.resolution_button_rect)
            capture_rects.extend(rect for rect, _ in self.resolution_option_rects)
        if self.fps_menu_open:
            if self.fps_button_rect:
                capture_rects.append(self.fps_button_rect)
            capture_rects.extend(rect for rect, _ in self.fps_option_rects)
        self._dropdown_capture_rects = capture_rects
        self._dropdown_mouse_captured = any(rect.collidepoint(mouse_pos) for rect in capture_rects)

        # Scenario button below the map selector
        scenario_label_full = self.current_scenario_name if self.current_scenario_name else "Scenario"
        scenario_button_width = map_button_width
        scenario_label_display = self._truncate_text_to_width(self.small_font, scenario_label_full, scenario_button_width - 24)
        scenario_label_surface = self.small_font.render(scenario_label_display, True, self.colors['text'])
        scenario_button_rect = pygame.Rect(10, row_y + button_height + 10, scenario_button_width, button_height)
        is_scenario_hovered = scenario_button_rect.collidepoint(mouse_pos)
        if self._dropdown_mouse_captured and not scenario_button_rect.collidepoint(mouse_pos):
            is_scenario_hovered = False
        scenario_button_color = (80, 120, 170) if is_scenario_hovered else (60, 90, 140)

        pygame.draw.rect(self.screen, scenario_button_color, scenario_button_rect, border_radius=6)
        pygame.draw.rect(self.screen, self.colors['text'], scenario_button_rect, 1, border_radius=6)
        scenario_label_rect = scenario_label_surface.get_rect(center=scenario_button_rect.center)
        prev_clip = self.screen.get_clip()
        self.screen.set_clip(scenario_button_rect)
        self.screen.blit(scenario_label_surface, scenario_label_rect)
        self.screen.set_clip(prev_clip)
        self.open_scenario_button_rect = scenario_button_rect
        if is_scenario_hovered and self.tooltip_manager:
            scenario_tooltip = TOP_UI_BUTTON_TOOLTIPS.get('scenario', '')
            if scenario_label_display != scenario_label_full and scenario_label_full != "Scenario":
                scenario_tooltip = f"{scenario_tooltip}: {scenario_label_full}" if scenario_tooltip else scenario_label_full
            self.tooltip_manager.register_hover("scenario_button", scenario_button_rect, scenario_tooltip)

        # 2. Play/Stop button (top-right corner, next to undo/redo)
        play_button_width = 80
        play_button_height = 30
        play_button_x = self.screen_width - play_button_width - 10
        play_button_y = 10
        play_button_rect = pygame.Rect(play_button_x, play_button_y, play_button_width, play_button_height)
        is_play_hovered = play_button_rect.collidepoint(mouse_pos)
        scenario_ready = self._scenario_has_playable_content()
        scenario_active = bool(self.scenario_running or (self.scenario_process and self.scenario_process.poll() is None))

        # Agent button (to the left of Play/Stop)
        has_agent = bool(getattr(self, "agent_path", None))
        agent_label = "Clear Agent" if has_agent else "Set Agent"
        agent_label_font = self.micro_font if has_agent else self.small_font
        agent_label_surface = agent_label_font.render(agent_label, True, self.colors['text'])
        agent_button_width = max(110, agent_label_surface.get_width() + 24)
        agent_filename_surface = None
        if has_agent:
            agent_filename = os.path.basename(self.agent_path)
            if agent_filename:
                agent_filename = self._truncate_text_to_width(
                    self.micro_font,
                    agent_filename,
                    agent_button_width - 16,
                )
                agent_filename_surface = self.micro_font.render(agent_filename, True, self.colors['text'])
        agent_button_height = play_button_height
        agent_button_x = play_button_x - agent_button_width - button_spacing
        agent_button_rect = pygame.Rect(agent_button_x, play_button_y, agent_button_width, agent_button_height)
        is_agent_hovered = agent_button_rect.collidepoint(mouse_pos)
        if self._dropdown_mouse_captured and not agent_button_rect.collidepoint(mouse_pos):
            is_agent_hovered = False

        agent_button_enabled = not scenario_active
        if agent_button_enabled:
            agent_button_color = (80, 120, 170) if is_agent_hovered else (60, 90, 140)
        else:
            agent_button_color = (80, 80, 80)

        pygame.draw.rect(self.screen, agent_button_color, agent_button_rect, border_radius=6)
        pygame.draw.rect(self.screen, self.colors['text'], agent_button_rect, 1, border_radius=6)
        prev_clip = self.screen.get_clip()
        self.screen.set_clip(agent_button_rect)
        if agent_filename_surface:
            total_text_height = agent_label_surface.get_height() + agent_filename_surface.get_height()
            top = agent_button_rect.top + max(0, (agent_button_height - total_text_height) // 2)
            label_rect = agent_label_surface.get_rect(
                midtop=(agent_button_rect.centerx, top)
            )
            filename_rect = agent_filename_surface.get_rect(
                midtop=(agent_button_rect.centerx, label_rect.bottom)
            )
            self.screen.blit(agent_label_surface, label_rect)
            self.screen.blit(agent_filename_surface, filename_rect)
        else:
            agent_label_rect = agent_label_surface.get_rect(center=agent_button_rect.center)
            self.screen.blit(agent_label_surface, agent_label_rect)
        self.screen.set_clip(prev_clip)
        self.agent_button_rect = agent_button_rect
        self.agent_button_enabled = bool(agent_button_enabled)
        if is_agent_hovered and self.tooltip_manager:
            self.tooltip_manager.register_hover("agent_button", agent_button_rect, TOP_UI_BUTTON_TOOLTIPS.get('agent', ''))

        # Determine button state and appearance
        if scenario_active:
            play_button_text = "Stop"
            play_button_color = (170, 80, 80) if is_play_hovered else (140, 60, 60)  # Red for stop
            play_button_enabled = True
        elif scenario_ready:
            play_button_text = "Play"
            play_button_color = (80, 170, 80) if is_play_hovered else (60, 140, 60)  # Green for play
            play_button_enabled = True
        else:
            play_button_text = "Play"
            play_button_color = (80, 80, 80)  # Gray when disabled
            play_button_enabled = False

        pygame.draw.rect(self.screen, play_button_color, play_button_rect, border_radius=6)
        pygame.draw.rect(self.screen, self.colors['text'], play_button_rect, 1, border_radius=6)

        play_label_surface = self.small_font.render(play_button_text, True, self.colors['text'])
        play_label_rect = play_label_surface.get_rect(center=play_button_rect.center)
        self.screen.blit(play_label_surface, play_label_rect)

        self.play_button_rect = play_button_rect
        self.play_button_enabled = play_button_enabled
        if is_play_hovered and self.tooltip_manager:
            tooltip_key = 'stop' if scenario_active else 'play'
            self.tooltip_manager.register_hover("play_button", play_button_rect, TOP_UI_BUTTON_TOOLTIPS.get(tooltip_key, ''))

        manual_only_hint = self._should_show_manual_only_hint()
        if manual_only_hint:
            hint_text = "Manual-only (no ego route)"
            hint_surface = self.tiny_font.render(hint_text, True, (230, 200, 120))
            hint_rect = hint_surface.get_rect(midtop=(play_button_rect.centerx, play_button_rect.bottom + 2))
            self.screen.blit(hint_surface, hint_rect)

        # 3. Movement legend (centered slightly higher for spacing)
        controls = "WASD: Pan | Right/Middle Click+Drag: Pan | Wheel: Zoom | Shift+Right Click: Move Camera | Ctrl+Click: Spawn | O: Toggle Lanes | T: Toggle Stop Lines | Ctrl+S: Save | Ctrl+L: Load"
        controls_surface = self.small_font.render(controls, True, (200, 200, 200))
        controls_center_y = ui_height - 35
        controls_rect = controls_surface.get_rect(center=(self.screen_width // 2, controls_center_y))
        self.screen.blit(controls_surface, controls_rect)

        manual_message = None
        if self.camera_processor:
            if self.camera_processor.manual_control_enabled:
                state = getattr(self.camera_processor, 'manual_control_state', {})
                autopilot_hint = ""
                if state.get('autopilot_enabled') or state.get('autopilot_active'):
                    autopilot_hint = " (autopilot on)"
                manual_message = "Manual control: Up accel, Down brake (hold Down at stop for auto reverse) | Space hand brake | Q toggle reverse | P toggle autopilot" + autopilot_hint
            elif self.scenario_running and self.camera_processor.manual_control_pending:
                manual_message = "Manual ego control: waiting for ego vehicle to spawn..."

        manual_surface = None
        manual_rect = None
        undo_offset = 18
        if manual_message:
            manual_color = (200, 230, 150) if self.camera_processor and self.camera_processor.manual_control_enabled else (180, 180, 180)
            manual_surface = self.small_font.render(manual_message, True, manual_color)
            manual_rect = manual_surface.get_rect(center=(self.screen_width // 2, controls_rect.top - 18))
            undo_offset = 36

        # 3b. Undo/Redo status centered above controls legend
        undo_status = self.get_undo_status()
        undo_text = f"{undo_status} | Ctrl+Z: Undo | Ctrl+Y: Redo"
        undo_surface = self.small_font.render(undo_text, True, (150, 200, 150))
        undo_rect = undo_surface.get_rect(center=(self.screen_width // 2, controls_rect.top - undo_offset))
        self.screen.blit(undo_surface, undo_rect)
        if manual_surface:
            self.screen.blit(manual_surface, manual_rect)

        self._dropdown_draw_ops = dropdown_draw_ops

        # 4. Camera position centered beneath the control guide
        if self.camera_controller:
            position_surface = self.small_font.render(
                f"Position: ({self.camera_controller.center_x:.1f}, {self.camera_controller.center_y:.1f}) "
                f"Height: {self.camera_controller.height:.1f}m",
                True,
                self.colors['text']
            )
            position_rect = position_surface.get_rect(center=(self.screen_width // 2, controls_rect.bottom + 18))
            self.screen.blit(position_surface, position_rect)

    def _close_all_dropdowns(self, *, except_menu=None, keep_info_panel: bool = False) -> None:
        """Close all open dropdown-style menus in the UI."""
        self.resolution_menu_open = False
        self.fps_menu_open = False
        self.map_menu_visible = False
        self.scenario_menu_visible = False
        for menu in (self.vehicle_menu, self.pedestrian_menu, self.ego_vehicle_menu):
            if menu and menu is not except_menu:
                menu.dropdown_open = False
        if self.info_panel and not keep_info_panel:
            self.info_panel.dropdown_open_field = None

    def get_active_selection_menu(self):
        """Return the menu matching the current placement mode."""
        if self.placement_mode == PlacementMode.VEHICLE:
            return self.vehicle_menu
        if self.placement_mode == PlacementMode.PEDESTRIAN:
            return self.pedestrian_menu
        if self.placement_mode == PlacementMode.EGO:
            return self.ego_vehicle_menu
        if self.placement_mode == PlacementMode.TRIGGER:
            return getattr(self, "traffic_light_group_menu", None)
        return None

    def _get_mode_button_rects(self):
        """Compute placement mode toggle button rectangles."""
        base_x = self.mode_button_base_x
        base_y = self.top_ui_height + 10
        button_width = self.mode_button_width
        button_height = self.mode_button_height
        spacing = self.mode_button_spacing

        vehicle_rect = pygame.Rect(base_x, base_y, button_width, button_height)
        pedestrian_rect = pygame.Rect(base_x + button_width + spacing, base_y, button_width, button_height)
        ego_rect = pygame.Rect(base_x + 2 * (button_width + spacing), base_y, button_width, button_height)
        trigger_rect = pygame.Rect(base_x + 3 * (button_width + spacing), base_y, button_width, button_height)

        return {
            PlacementMode.VEHICLE: vehicle_rect,
            PlacementMode.PEDESTRIAN: pedestrian_rect,
            PlacementMode.EGO: ego_rect,
            PlacementMode.TRIGGER: trigger_rect,
        }

    def _get_weather_button_rect(self) -> pygame.Rect:
        """Return the rectangle for the weather control button."""
        base_x = self.mode_button_base_x
        base_y = self.top_ui_height + 10
        width = self.mode_button_width
        height = self.mode_button_height
        spacing = self.mode_button_spacing
        return pygame.Rect(base_x + 4 * (width + spacing), base_y, width, height)

    def handle_mode_toggle_click(self, mouse_pos):
        """Handle clicks on the placement mode toggle."""
        rects = self.mode_button_rects or self._get_mode_button_rects()
        for mode, rect in rects.items():
            if rect.collidepoint(mouse_pos):
                self.set_placement_mode(mode)
                return True
        return False

    def set_placement_mode(self, mode):
        """Update active placement mode and reset menus."""
        previous_mode = self.placement_mode
        if mode == previous_mode:
            # Re-arm trigger placement if the user clicks the active trigger button while disarmed.
            if (mode == PlacementMode.TRIGGER and self.camera_processor
                    and not self.camera_processor.placing_trigger):
                self.camera_processor.start_trigger_placement()
            return

        self.placement_mode = mode
        if self.vehicle_menu:
            self.vehicle_menu.dropdown_open = False
        if self.pedestrian_menu:
            self.pedestrian_menu.dropdown_open = False
        if self.ego_vehicle_menu:
            self.ego_vehicle_menu.dropdown_open = False

        if self.camera_processor:
            if previous_mode == PlacementMode.TRIGGER and self.camera_processor.placing_trigger:
                self.camera_processor.stop_trigger_placement()
            self.camera_processor.clear_vehicle_selection()
            self.camera_processor.waypoint_display_vehicle_id = None
            self.camera_processor.creating_waypoint = False
            if self.info_panel:
                self.info_panel.hide()
            if mode == PlacementMode.TRIGGER:
                self.camera_processor.start_trigger_placement()

    def render_mode_toggle(self):
        """Render placement mode toggle buttons with active highlight."""
        rects = self._get_mode_button_rects()
        self.mode_button_rects = rects

        active_color = (90, 140, 90)
        inactive_color = (70, 70, 70)
        border_color = (120, 120, 120)
        hover_color = (110, 110, 110)

        mouse_pos = pygame.mouse.get_pos()
        if getattr(self, "_dropdown_capture_rects", None):
            for rect in self._dropdown_capture_rects:
                if rect.collidepoint(mouse_pos):
                    mouse_pos = (-1, -1)
                    break

        for mode, rect in rects.items():
            is_active = (mode == self.placement_mode)
            is_hovered = rect.collidepoint(mouse_pos)

            fill_color = active_color if is_active else inactive_color
            if is_hovered and not is_active:
                fill_color = hover_color

            pygame.draw.rect(self.screen, fill_color, rect, border_radius=6)
            pygame.draw.rect(self.screen, border_color, rect, width=2, border_radius=6)

            if mode == PlacementMode.VEHICLE:
                label = "NPC Vehicles"
            elif mode == PlacementMode.PEDESTRIAN:
                label = "Pedestrians"
            elif mode == PlacementMode.EGO:
                label = "Ego Vehicle"
            else:
                label = "Triggers"

            text_surface = self.small_font.render(label, True, (255, 255, 255))
            text_rect = text_surface.get_rect(center=rect.center)
            self.screen.blit(text_surface, text_rect)

            # Register hover for tooltip
            if is_hovered and self.tooltip_manager:
                tooltip_text = MODE_BUTTON_TOOLTIPS.get(mode.name, '')
                if tooltip_text:
                    self.tooltip_manager.register_hover(f"mode_button_{mode.name}", rect, tooltip_text)

        weather_rect = self._get_weather_button_rect()
        self.weather_button_rect = weather_rect
        weather_enabled = self.ready and (self.world is not None)
        self.weather_button_enabled = weather_enabled
        weather_active = weather_enabled and bool(self.weather_window and self.weather_window.alive())
        weather_hovered = weather_rect.collidepoint(mouse_pos)

        if weather_enabled:
            weather_fill = active_color if weather_active else inactive_color
            if weather_hovered and not weather_active:
                weather_fill = hover_color
            weather_text_color = (255, 255, 255)
        else:
            weather_fill = (55, 55, 55)
            weather_text_color = (170, 170, 170)

        pygame.draw.rect(self.screen, weather_fill, weather_rect, border_radius=6)
        pygame.draw.rect(self.screen, border_color, weather_rect, width=2, border_radius=6)

        weather_text_surface = self.small_font.render("Weather", True, weather_text_color)
        weather_text_rect = weather_text_surface.get_rect(center=weather_rect.center)
        self.screen.blit(weather_text_surface, weather_text_rect)

        # Register hover for weather button tooltip
        if weather_hovered and self.tooltip_manager:
            self.tooltip_manager.register_hover("weather_button", weather_rect, TOP_UI_BUTTON_TOOLTIPS.get('weather', ''))

    def _weather_dict_from_params(self, weather: "carla.WeatherParameters") -> Dict[str, float]:
        """Convert WeatherParameters to a plain dict for the UI/state."""
        payload: Dict[str, float] = {}
        for spec in WEATHER_PARAMETER_SPECS:
            try:
                payload[spec.name] = float(getattr(weather, spec.name))
            except Exception:
                payload[spec.name] = spec.min_value
        return payload

    def _capture_baseline_weather(self, weather: Optional["carla.WeatherParameters"]) -> None:
        """Store the current world weather as the baseline for 'New Scenario' resets."""
        if not weather:
            return
        try:
            self._baseline_weather_state = self._weather_dict_from_params(weather)
        except Exception:
            self._baseline_weather_state = None

    def _reset_weather_to_baseline(self) -> None:
        """Reset world weather + editor weather UI state back to the session baseline."""
        if not self.world:
            return
        baseline = getattr(self, "_baseline_weather_state", None)
        if not isinstance(baseline, dict) or not baseline:
            try:
                baseline_weather = self.world.get_weather()
            except Exception:
                baseline_weather = None
            self._capture_baseline_weather(baseline_weather)
            baseline = getattr(self, "_baseline_weather_state", None)

        if not isinstance(baseline, dict) or not baseline:
            return

        try:
            weather = self._weather_params_from_dict(baseline)
        except Exception:
            return

        try:
            self.world.set_weather(weather)
        except Exception as exc:
            print(f"[Weather] Failed to reset weather: {exc}")
            return

        base_frame = {"route_percentage": 0.0, **dict(baseline)}
        self._weather_keyframes = [
            base_frame,
            {**base_frame, "route_percentage": 100.0},
        ]
        self._active_weather_index = 0
        self._pending_weather_pct = 0.0
        self._update_weather_state(weather, keyframe_index=0)
        if self.weather_window and self.weather_window.alive():
            try:
                self.weather_window.apply_weather(weather)
            except Exception:
                pass
        self._refresh_weather_window_metadata()

    def _weather_params_from_dict(self, values: Dict[str, float]) -> "carla.WeatherParameters":
        """Convert a payload dict back into WeatherParameters."""
        weather = carla.WeatherParameters()
        for spec in WEATHER_PARAMETER_SPECS:
            if spec.name in values:
                try:
                    setattr(weather, spec.name, float(values[spec.name]))
                except Exception:
                    pass
        return weather

    def _sanitize_weather_keyframes_payload(self, keyframes: Optional[Iterable[Dict[str, float]]]) -> List[Dict[str, float]]:
        """Normalize a list of keyframes (dicts) to a sorted, deduped payload."""
        defaults: Dict[str, float] = {}
        try:
            defaults = self._weather_dict_from_params(self.world.get_weather()) if self.world else {}
        except Exception:
            defaults = dict(self._weather_state)
        cleaned: List[Dict[str, float]] = []

        def _append(frame: Dict[str, float]) -> None:
            try:
                pct = float(frame.get("route_percentage", frame.get("route_percent", frame.get("pct", 0.0))))
            except Exception:
                return
            normalized: Dict[str, float] = {"route_percentage": max(0.0, min(100.0, pct))}
            for spec in WEATHER_PARAMETER_SPECS:
                val = frame.get(spec.name)
                if val is None and spec.name.lower() in frame:
                    val = frame.get(spec.name.lower())
                if val is None:
                    continue
                try:
                    normalized[spec.name] = float(val)
                except Exception:
                    normalized[spec.name] = spec.min_value
            cleaned.append(normalized)

        for frame in keyframes or []:
            if isinstance(frame, dict):
                _append(frame)

        if not cleaned:
            base = defaults or dict(self._weather_state)
            default_frame = {"route_percentage": 0.0, **base}
            cleaned = [
                default_frame,
                {**default_frame, "route_percentage": 100.0},
            ]

        cleaned = sorted(cleaned, key=lambda kf: float(kf.get("route_percentage", 0.0)))
        deduped: List[Dict[str, float]] = []
        for frame in cleaned:
            pct = float(frame.get("route_percentage", 0.0))
            if deduped and abs(deduped[-1].get("route_percentage", 0.0) - pct) < 1e-3:
                deduped[-1].update({k: v for k, v in frame.items() if k != "route_percentage"})
            else:
                deduped.append(frame)

        if deduped[0].get("route_percentage", 0.0) > 0.0:
            deduped.insert(0, {"route_percentage": 0.0, **deduped[0]})
        if deduped[-1].get("route_percentage", 0.0) < 100.0:
            deduped.append({"route_percentage": 100.0, **deduped[-1]})

        for frame in deduped:
            for spec in WEATHER_PARAMETER_SPECS:
                if spec.name not in frame:
                    frame[spec.name] = float(defaults.get(spec.name, self._weather_state.get(spec.name, spec.min_value)))
        return deduped

    def _ensure_weather_keyframes(self) -> None:
        """Ensure we have at least 0% and 100% keyframes with full parameter coverage."""
        self._weather_keyframes = self._sanitize_weather_keyframes_payload(self._weather_keyframes)
        self._active_weather_index = min(self._active_weather_index, len(self._weather_keyframes) - 1)

    def _update_weather_state(self, weather: "carla.WeatherParameters", *, keyframe_index: Optional[int] = None) -> None:
        """Cache latest weather values and sync active keyframe if provided."""
        for spec in WEATHER_PARAMETER_SPECS:
            try:
                value = getattr(weather, spec.name)
            except AttributeError:
                value = spec.min_value
            self._weather_state[spec.name] = float(value)

        if keyframe_index is None:
            keyframe_index = self._active_weather_index
        if self._weather_keyframes and 0 <= keyframe_index < len(self._weather_keyframes):
            for spec in WEATHER_PARAMETER_SPECS:
                self._weather_keyframes[keyframe_index][spec.name] = self._weather_state[spec.name]
        else:
            # Seed if empty
            self._ensure_weather_keyframes()
            if self._weather_keyframes:
                for spec in WEATHER_PARAMETER_SPECS:
                    self._weather_keyframes[0][spec.name] = self._weather_state[spec.name]

    def _refresh_weather_window(self) -> None:
        """Refresh slider positions to match the world's weather when the window is open."""
        if not (self.weather_window and self.weather_window.alive() and self.world):
            return
        try:
            weather = self.world.get_weather()
        except Exception as exc:
            print(f"[Weather] Unable to refresh weather controls: {exc}")
            return
        self._update_weather_state(weather, keyframe_index=self._active_weather_index)
        self.weather_window.apply_weather(weather)
        self._refresh_weather_window_metadata()

    def _on_weather_window_closed(self) -> None:
        """Callback when the weather window is dismissed."""
        self.weather_window = None

    def _on_weather_slider_preview(self, parameter: str, value: float) -> None:
        """Apply live slider changes without creating undo entries."""
        spec = self._weather_spec_lookup.get(parameter)
        if spec:
            value = float(max(spec.min_value, min(spec.max_value, value)))
        if not self.world:
            return
        self._ensure_weather_keyframes()
        if not self._weather_keyframes:
            return
        active_index = max(0, min(self._active_weather_index, len(self._weather_keyframes) - 1))

        if self._weather_drag_snapshot is None:
            self._weather_drag_snapshot = {
                "keyframes": copy.deepcopy(self._weather_keyframes),
                "index": active_index,
                "pending": self._pending_weather_pct,
            }

        try:
            self._weather_keyframes[active_index][parameter] = value
        except Exception:
            return

        try:
            frame = self._weather_keyframes[active_index]
            weather = self._weather_params_from_dict(frame)
            if self.world:
                self.world.set_weather(weather)
            self._update_weather_state(weather, keyframe_index=active_index)
        except Exception as exc:
            print(f"[Weather] Unable to apply live slider change for {parameter}: {exc}")
            return

        self._refresh_weather_window_metadata()

    def _on_weather_slider_commit(self, parameter: str, value: float) -> None:
        """Commit a weather slider change to undo/redo after drag ends."""
        if not self._weather_keyframes:
            return
        active_index = max(0, min(self._active_weather_index, len(self._weather_keyframes) - 1))

        start = self._weather_drag_snapshot
        self._weather_drag_snapshot = None
        if start is None:
            return  # No drag was recorded; nothing to commit.

        old_keyframes = start.get("keyframes", [])
        old_index = int(start.get("index", active_index))
        old_pending = float(start.get("pending", self._pending_weather_pct))

        # Ensure final value is stored in the active frame
        spec = self._weather_spec_lookup.get(parameter)
        if spec:
            value = float(max(spec.min_value, min(spec.max_value, value)))
        try:
            self._weather_keyframes[active_index][parameter] = value
        except Exception:
            return

        new_keyframes = copy.deepcopy(self._weather_keyframes)
        command = WeatherEditCommand(
            self,
            old_keyframes,
            new_keyframes,
            old_index,
            active_index,
            old_pending,
            self._pending_weather_pct,
            description=f"Set weather {parameter}",
        )
        self.execute_command(command)

    def _refresh_weather_window_metadata(self) -> None:
        """Sync keyframe metadata UI (label, percent slider, buttons)."""
        if not (self.weather_window and self.weather_window.alive()):
            return
        self._ensure_weather_keyframes()
        if not self._weather_keyframes:
            return
        count = len(self._weather_keyframes)
        index = max(0, min(self._active_weather_index, count - 1))
        # Use pending slider position for display to keep user-chosen insert point.
        pct = float(max(0.0, min(100.0, self._pending_weather_pct)))
        can_delete = count > 2 and index not in (0, count - 1)
        # Disable add when the pending percentage matches an existing keyframe.
        matches_existing = any(abs(float(frame.get("route_percentage", 0.0)) - pct) < 1e-3 for frame in self._weather_keyframes)
        try:
            self.weather_window.update_keyframe_metadata(
                count=count,
                index=index,
                percentage=pct,
                percent_editable=True,
                can_delete=can_delete,
                can_add=not matches_existing,
            )
        except Exception:
            pass

    def _set_active_weather_index(self, index: int) -> None:
        """Select a different weather keyframe and apply it to the world."""
        self._ensure_weather_keyframes()
        if not self._weather_keyframes or not self.world:
            return
        index = max(0, min(index, len(self._weather_keyframes) - 1))
        self._active_weather_index = index
        frame = self._weather_keyframes[index]
        try:
            self._pending_weather_pct = float(frame.get("route_percentage", 0.0))
        except Exception:
            self._pending_weather_pct = 0.0
        try:
            weather = self._weather_params_from_dict(frame)
        except Exception:
            return
        try:
            self.world.set_weather(weather)
        except Exception as exc:
            print(f"[Weather] Failed to apply keyframe {index}: {exc}")
        self._update_weather_state(weather, keyframe_index=index)
        if self.weather_window and self.weather_window.alive():
            try:
                self.weather_window.apply_weather(weather)
            except Exception:
                pass
        self._refresh_weather_window_metadata()

    def _set_active_weather_percentage(self, percentage: float) -> None:
        """Track the desired insert percentage from the slider."""
        try:
            self._pending_weather_pct = float(max(0.0, min(100.0, percentage)))
        except Exception:
            self._pending_weather_pct = 0.0
        self._refresh_weather_window_metadata()

    def _add_weather_keyframe_at(self, percentage: float) -> None:
        """Insert a new keyframe at the requested route percentage."""
        self._ensure_weather_keyframes()
        if not self._weather_keyframes:
            return
        pct = max(0.0, min(100.0, float(percentage)))
        for idx, frame in enumerate(self._weather_keyframes):
            if abs(float(frame.get("route_percentage", 0.0)) - pct) < 1e-3:
                # Selecting an existing keyframe is navigation, not an edit.
                self._set_active_weather_index(idx)
                self._pending_weather_pct = pct
                self._refresh_weather_window_metadata()
                return
        new_frame: Dict[str, float] = {"route_percentage": pct}
        for spec in WEATHER_PARAMETER_SPECS:
            new_frame[spec.name] = float(self._weather_state.get(spec.name, spec.min_value))
        old_keyframes = copy.deepcopy(self._weather_keyframes)
        new_keyframes = copy.deepcopy(self._weather_keyframes)
        new_keyframes.append(new_frame)
        new_keyframes = sorted(new_keyframes, key=lambda kf: float(kf.get("route_percentage", 0.0)))
        new_index = new_keyframes.index(new_frame)
        command = WeatherEditCommand(
            self,
            old_keyframes,
            new_keyframes,
            self._active_weather_index,
            new_index,
            self._pending_weather_pct,
            pct,
            description="Add weather keyframe",
        )
        self.execute_command(command)

    def _delete_active_weather_keyframe(self) -> None:
        """Remove the current keyframe when allowed (not first/last)."""
        self._ensure_weather_keyframes()
        if len(self._weather_keyframes) <= 2:
            return
        if self._active_weather_index in (0, len(self._weather_keyframes) - 1):
            return
        old_keyframes = copy.deepcopy(self._weather_keyframes)
        new_keyframes = copy.deepcopy(self._weather_keyframes)
        new_keyframes.pop(self._active_weather_index)
        new_index = max(0, min(self._active_weather_index, len(new_keyframes) - 1))
        command = WeatherEditCommand(
            self,
            old_keyframes,
            new_keyframes,
            self._active_weather_index,
            new_index,
            self._pending_weather_pct,
            float(new_keyframes[new_index].get("route_percentage", self._pending_weather_pct)) if new_keyframes else 0.0,
            description="Delete weather keyframe",
        )
        self.execute_command(command)

    def _on_weather_keyframe_percentage_change(self, value: float) -> None:
        self._set_active_weather_percentage(value)

    def _on_weather_add_keyframe(self) -> None:
        pct = float(max(0.0, min(100.0, getattr(self, "_pending_weather_pct", 0.0))))
        self._add_weather_keyframe_at(pct)

    def _on_weather_delete_keyframe(self) -> None:
        self._delete_active_weather_keyframe()

    def _on_weather_prev_keyframe(self) -> None:
        target = self._active_weather_index - 1
        if target < 0:
            return
        self._set_active_weather_index(target)

    def _on_weather_next_keyframe(self) -> None:
        target = self._active_weather_index + 1
        if target >= len(self._weather_keyframes):
            return
        self._set_active_weather_index(target)

    def _apply_weather_from_json_data(self, scenario_data: Optional[dict]) -> bool:
        """Apply weather keyframes from a JSON payload if present."""
        if not self.world or not scenario_data:
            return False

        raw_keyframes = scenario_data.get("weather_keyframes")
        if not isinstance(raw_keyframes, list):
            return False

        cleaned = self._sanitize_weather_keyframes_payload(raw_keyframes)
        if not cleaned:
            return False

        self._weather_keyframes = cleaned
        self._active_weather_index = 0
        try:
            self._pending_weather_pct = float(cleaned[0].get("route_percentage", 0.0))
        except Exception:
            self._pending_weather_pct = 0.0

        try:
            start_weather = self._weather_params_from_dict(cleaned[0])
            self.world.set_weather(start_weather)
            self._update_weather_state(start_weather, keyframe_index=0)
            if self.weather_window and self.weather_window.alive():
                self.weather_window.apply_weather(start_weather)
                try:
                    self.weather_window.update_keyframe_metadata(
                        count=len(cleaned),
                        index=self._active_weather_index,
                        percentage=float(cleaned[0].get("route_percentage", 0.0)),
                        percent_editable=len(cleaned) > 1 and self._active_weather_index not in (0, len(cleaned) - 1),
                        can_delete=len(cleaned) > 2 and self._active_weather_index not in (0, len(cleaned) - 1),
                    )
                except Exception:
                    pass
            return True
        except Exception as exc:
            print(f"[Weather] Failed to apply start weather from JSON keyframes: {exc}")
            return False

    def toggle_weather_window(self) -> None:
        """Show or hide the weather control window."""
        if not self.ready or not self.world:
            print("Weather controls are available once the CARLA world finishes loading.")
            return

        if self.weather_window and self.weather_window.alive():
            window = self.weather_window
            self.weather_window = None
            window.kill()
            return

        available_width = self.screen_width - 20
        width_candidate = max(280, min(520, available_width))
        width = min(width_candidate, available_width) if available_width > 0 else 360

        # Estimate required height based on layout metrics from WeatherControlWindow.
        columns = 2 if width >= 420 and len(WEATHER_PARAMETER_SPECS) > 6 else 1
        items_per_column = math.ceil(len(WEATHER_PARAMETER_SPECS) / columns)
        row_height = 58
        keyframe_controls_height = 120
        bottom_padding = 24
        window_chrome = 52  # title bar + margins inside UIWindow
        desired_content_height = keyframe_controls_height + (items_per_column * row_height) + bottom_padding
        desired_height = desired_content_height + window_chrome

        available_height = self.screen_height - (self.top_ui_height + self.mode_button_height + 40)
        height_candidate = max(280, min(580, available_height))
        height = min(height_candidate, max(320, desired_height)) if available_height > 0 else 420
        bottom_margin = 12
        top_margin = self.top_ui_height + self.mode_button_height + 12
        top = max(top_margin, self.screen_height - height - bottom_margin)
        rect = pygame.Rect(12, top, width, height)

        self.weather_window = WeatherControlWindow(
            rect=rect,
            manager=self.ui_manager,
            specs=WEATHER_PARAMETER_SPECS,
            on_change_live=self._on_weather_slider_preview,
            on_change_commit=self._on_weather_slider_commit,
            keyframe_count=len(self._weather_keyframes) if self._weather_keyframes else 1,
            active_index=self._active_weather_index,
            active_percentage=float(max(0.0, min(100.0, getattr(self, "_pending_weather_pct", 0.0)))),
            percent_editable=True,
            can_delete=bool(len(self._weather_keyframes) > 2 and self._active_weather_index not in (0, len(self._weather_keyframes) - 1)),
            on_percentage_change=self._on_weather_keyframe_percentage_change,
            on_add_keyframe=self._on_weather_add_keyframe,
            on_delete_keyframe=self._on_weather_delete_keyframe,
            on_prev_keyframe=self._on_weather_prev_keyframe,
            on_next_keyframe=self._on_weather_next_keyframe,
            on_close=self._on_weather_window_closed,
        )

        try:
            self._ensure_weather_keyframes()
            weather = None
            if self._weather_keyframes:
                weather = self._weather_params_from_dict(self._weather_keyframes[self._active_weather_index])
            if weather is None:
                weather = self.world.get_weather()
        except Exception as exc:
            print(f"[Weather] Unable to read current weather: {exc}")
            weather = None

        if weather:
            self._update_weather_state(weather)
            self.weather_window.apply_weather(weather)
            self._refresh_weather_window_metadata()
        elif self._weather_state:
            try:
                fallback = carla.WeatherParameters(**self._weather_state)
            except Exception:
                fallback = None
            if fallback:
                self.weather_window.apply_weather(fallback)
                self._refresh_weather_window_metadata()

    def render_crosshair(self):
        """Render red crosshair in the center of the screen"""
        center_x = self.screen_width // 2
        center_y = self.screen_height // 2
        crosshair_size = 20
        crosshair_thickness = 2
        crosshair_color = (255, 0, 0)  # Red
        
        # Horizontal line
        pygame.draw.line(self.screen, crosshair_color, 
                        (center_x - crosshair_size, center_y), 
                        (center_x + crosshair_size, center_y), 
                        crosshair_thickness)
        
        # Vertical line
        pygame.draw.line(self.screen, crosshair_color, 
                        (center_x, center_y - crosshair_size), 
                        (center_x, center_y + crosshair_size), 
                        crosshair_thickness)
        
        # Small center dot for precision
        pygame.draw.circle(self.screen, crosshair_color,
                          (center_x, center_y), 2)
    
    def _update_fps_meter(self, raw_fps: float) -> None:
        """Smooth the incoming FPS readings for a stable on-screen display."""
        if not math.isfinite(raw_fps):
            return

        if raw_fps <= 0.0:
            # Gradually decay when the clock reports no measurable FPS.
            self._fps_display = max(0.0, self._fps_display * 0.95)
            return

        smoothing = self._fps_smoothing
        if self._fps_display <= 0.0:
            self._fps_display = raw_fps
        else:
            self._fps_display = max(
                0.0,
                (self._fps_display * smoothing) + (raw_fps * (1.0 - smoothing)),
            )

    def render_fps_meter(self) -> Optional[pygame.Rect]:
        """Render UI, camera, and WallTime tick FPS on a single line near the top-right corner."""
        if not self.screen or not self.fps_font:
            return None

        ui_fps = max(0.0, self._fps_display)
        try:
            camera_fps = max(0.0, float(self.camera_processor.get_camera_fps())) if self.camera_processor else 0.0
        except Exception:
            camera_fps = 0.0
        world_fps = max(0.0, getattr(self, "_world_tick_fps", 0.0))

        segments = [
            f"UI: {ui_fps:0.1f} FPS" if ui_fps >= 0.05 else "UI: 0.0 FPS",
            f"Camera: {camera_fps:0.1f} FPS" if camera_fps >= 0.05 else "Camera: 0.0 FPS",
            f"WallTime: {world_fps:0.1f} FPS" if world_fps >= 0.05 else "WallTime: 0.0 FPS",
        ]
        text_surface = self.fps_font.render("   |   ".join(segments), True, self.colors['fps'])

        padding = 10
        text_rect = text_surface.get_rect()
        play_button_rect = getattr(self, 'play_button_rect', None)
        screen_width = self.screen.get_width()
        if play_button_rect and self.ready:
            offset = 6
            text_rect.topright = (play_button_rect.right, play_button_rect.bottom + offset)
            text_rect.right = min(text_rect.right, screen_width - padding)
        else:
            text_rect.topright = (screen_width - padding, padding)

        self.screen.blit(text_surface, text_rect)
        self._fps_text_rect = text_rect
        return text_rect

    def render_rendering_toggle(self, anchor_rect: Optional[pygame.Rect]) -> None:
        """Render the scene rendering checkbox under the FPS counter."""
        if not self.screen or not self.small_font:
            return

        padding = 10
        right_edge = self.screen.get_width() - padding
        top = (anchor_rect.bottom + 6) if anchor_rect else (padding + 8)

        label_text = "No Rendering Mode"
        label_surface = self.small_font.render(label_text, True, self.colors['text'])
        label_rect = label_surface.get_rect()
        label_rect.topright = (right_edge, top)

        checkbox_size = max(14, label_rect.height - 4)
        checkbox_rect = pygame.Rect(0, 0, checkbox_size, checkbox_size)
        checkbox_rect.top = label_rect.top + (label_rect.height - checkbox_size) // 2
        checkbox_rect.right = label_rect.left - 8

        toggle_rect = checkbox_rect.union(label_rect).inflate(6, 4)
        self.rendering_toggle_rect = toggle_rect

        mouse_pos = pygame.mouse.get_pos()
        is_hovered = toggle_rect.collidepoint(mouse_pos)

        no_render_active = not self.rendering_enabled
        base_color = self.colors['toggle_on'] if no_render_active else self.colors['toggle_off']
        if is_hovered:
            hover_boost = 20
            fill_color = tuple(min(c + hover_boost, 255) for c in base_color)
        else:
            fill_color = base_color

        pygame.draw.rect(self.screen, fill_color, checkbox_rect, border_radius=3)
        pygame.draw.rect(self.screen, self.colors['text'], checkbox_rect, 1, border_radius=3)

        if no_render_active:
            # Simple check mark.
            check_points = [
                (checkbox_rect.left + 3, checkbox_rect.centery),
                (checkbox_rect.left + checkbox_rect.width // 2 - 1, checkbox_rect.bottom - 4),
                (checkbox_rect.right - 3, checkbox_rect.top + 3),
            ]
            pygame.draw.lines(self.screen, self.colors['text'], False, check_points, 2)

        self.screen.blit(label_surface, label_rect)
    
    def cleanup(self):
        """Cleanup resources"""
        print("Cleaning up...")

        self._close_result_window()
        self._world_reset_in_progress = False
        self._world_reset_finalize_pending = False
        self._world_reset_ready_world = None
        self._world_reset_candidate_world = None
        self._world_reset_pending = False
        self._unregister_world_tick_handler()

        try:
            scenario_proc = getattr(self, "scenario_process", None)
            mini_runner = getattr(self, "_mini_runner", None)
            scenario_active = bool(
                getattr(self, "scenario_running", False)
                or (scenario_proc and scenario_proc.poll() is None)
                or (mini_runner and getattr(mini_runner, "is_running", False))
            )
            if scenario_active:
                self.stop_scenario()
        except Exception as exc:
            print(f"[Cleanup] Warning: failed to stop scenario: {exc}")
        
        # Clean up vehicles first
        if self.camera_processor:
            self.camera_processor.cleanup_all_vehicles()
            self.camera_processor.cleanup()
        
        if self.vehicle_menu:
            self.vehicle_menu.cleanup()
        if self.pedestrian_menu:
            self.pedestrian_menu.cleanup()

        if self.keep_server_running_on_exit:
            self.server_manager.set_auto_stop_enabled(False)
        else:
            self.server_manager.set_auto_stop_enabled(True)
            self.server_manager.stop_server(force=True)
        if self.handoff_read_fd is not None:
            try:
                os.close(self.handoff_read_fd)
            except OSError:
                pass
            self.handoff_read_fd = None
        if self.handoff_write_fd is not None:
            try:
                os.close(self.handoff_write_fd)
            except OSError:
                pass
            self.handoff_write_fd = None
        pygame.quit()
        self.keep_server_running_on_exit = False
    
    def run(self):
        """
        Main application loop for the Visual Scenario Editor.
        Handles startup, event processing, rendering, and cleanup.
        """
        clock = pygame.time.Clock()
        running = True

        # --- Startup Banner ---
        print("\nVisual Scenario Editor")
        print("======================")
        print("Click waypoints to select, drag to move")
        print("Press 'O' to toggle OpenDRIVE overlay, 'T' to toggle traffic light stop lines (both start disabled)")
        print("Ctrl+Click to spawn selected entity, Ctrl+S to save, Ctrl+L to load")
        print("ESC cancels operations - Alt+F4 or close button (X) to exit")

        try:
            while running:
                dt = clock.tick(60) / 1000.0  # --- Timing: Delta time in seconds ---
                self._update_fps_meter(clock.get_fps())

                # --- Startup Sequence ---
                if (
                    self._startup_requested
                    and not self._startup_thread_started
                    and not self.ready
                    and not self.startup_error
                    and not self.start_screen_active
                ):
                    startup_thread = threading.Thread(target=self._startup_entrypoint)
                    startup_thread.daemon = True
                    startup_thread.start()
                    self._startup_thread_started = True

                # --- Event Handling ---
                running = self.handle_events(dt)

                if self.ui_manager:
                    self.ui_manager.update(dt)

                # --- Rendering ---
                self.screen.fill(self.colors['background'])  # Clear screen

                # --- Handle world reset lifecycle ---
                self._process_world_reset_events()

                if not self.ready:
                    if self.start_screen_active:
                        self.render_start_screen()
                    else:
                        self.render_loading_screen()
                    self._dropdown_draw_ops = []
                else:
                    self._maybe_open_result_window()

                    # --- Update Simulation State ---
                    self._monitor_external_ego_status()

                    if self.manual_tick_required:
                        self._manual_world_tick(dt)

                    self._process_pending_camera_focus()

                    if self.camera_processor:
                        self.camera_processor.update(dt)
                        self._process_pending_actor_reselect()

                    # --- Render Camera Feed ---
                    if self.camera_processor:
                        latest_image = self.camera_processor.get_latest_image()
                        if self.camera_stream_enabled and latest_image:
                            self.screen.blit(latest_image, (0, 0))
                        elif not self.camera_stream_enabled:
                            self.screen.fill((0, 0, 0))

                    # --- Clear tooltip hover state for this frame ---
                    if self.tooltip_manager:
                        self.tooltip_manager.clear_hover()

                    # --- Render Overlays and UI ---
                    self.render_crosshair()  # Center crosshair
                    # Render action menus BEFORE UI panels so they appear behind
                    if self.camera_processor:
                        self.camera_processor.render_action_menus(self.screen)
                    self.render_ui()         # Top UI bar
                    self.render_mode_toggle()
                    active_menu = self.get_active_selection_menu()
                    if (active_menu and not self.scenario_running):
                        active_menu.render(self.screen)

                    # --- Render Vehicle and Waypoint Overlays ---
                    if self.camera_processor:
                        self.camera_processor.render_all_overlays(self.screen)

                    # --- Render Info Panel ---
                    self.info_panel.render(self.screen, tooltip_manager=self.tooltip_manager)

                    # --- Render Map Selection Menu ---
                    if self.map_menu_visible and self.map_menu:
                        mouse_pos = pygame.mouse.get_pos()
                        self.map_menu.render(self.screen, mouse_pos)

                    # --- Render Scenario Selection Menu ---
                    if self.scenario_menu_visible and self.scenario_menu:
                        mouse_pos = pygame.mouse.get_pos()
                        self.scenario_menu.render(self.screen, mouse_pos)

                if self.ui_manager:
                    self.ui_manager.draw_ui(self.screen)

                if getattr(self, "_dropdown_draw_ops", None):
                    for rect, fill_color, text_surface in self._dropdown_draw_ops:
                        pygame.draw.rect(self.screen, fill_color, rect, border_radius=4)
                        pygame.draw.rect(self.screen, self.colors['text'], rect, 1, border_radius=4)
                        text_rect = text_surface.get_rect(center=rect.center)
                        self.screen.blit(text_surface, text_rect)

                self._render_external_swap_overlay()
                self._render_error_overlay()

                fps_rect = self.render_fps_meter()
                self.render_rendering_toggle(fps_rect)

                # --- Render Tooltip (must be last, on top of everything) ---
                if self.tooltip_manager:
                    self.tooltip_manager.update()
                    self.tooltip_manager.render(self.screen)

                # --- Display Update ---
                pygame.display.flip()

                if self.pending_exit:
                    if self.handoff_read_fd is not None:
                        ready, _, _ = select.select([self.handoff_read_fd], [], [], 0)
                        if ready:
                            try:
                                os.read(self.handoff_read_fd, 1)
                            except OSError:
                                pass
                            try:
                                os.close(self.handoff_read_fd)
                            except OSError:
                                pass
                            self.handoff_read_fd = None
                            if self.pending_profile_switch:
                                if (self.connection_profile.manage_server and
                                        self.pending_profile_switch.is_remote):
                                    print("[Connection] Remote session confirmed; local CARLA server will be stopped on exit.")
                                    self.keep_server_running_on_exit = False
                                self.pending_profile_switch = None
                                self.pending_profile_switch_label = None
                            self.pending_exit = False
                            running = False
                            continue
                    if self.relaunch_process and self.relaunch_process.poll() is not None:
                        return_code = self.relaunch_process.returncode
                        print(f"Map change failed (code {return_code}). Staying in current session.")
                        self.loading_stage = f"Map change failed (code {return_code})."
                        self.startup_error = f"Map change failed (code {return_code})"
                        self.pending_exit = False
                        self.keep_server_running_on_exit = False
                        self.relaunch_process = None
                        self.restart_start_time = None
                        self.ready = False
                        self.server_manager.set_auto_stop_enabled(True)
                        self.wait_for_child = False
                        self.pending_profile_switch = None
                        self.pending_profile_switch_label = None
                    elif self.restart_start_time and (time.time() - self.restart_start_time) >= self.restart_wait_duration:
                        if self.handoff_read_fd is not None:
                            try:
                                os.close(self.handoff_read_fd)
                            except OSError:
                                pass
                            self.handoff_read_fd = None
                        self.pending_exit = False
                        running = False
                        self.pending_profile_switch = None
                        self.pending_profile_switch_label = None

        except KeyboardInterrupt:
            print("\nReceived interrupt signal...")
        finally:
            self.cleanup()
            if self.wait_for_child and self.relaunch_process:
                try:
                    self.relaunch_process.wait()
                except Exception:
                    pass
                finally:
                    self.relaunch_process = None
                    self.wait_for_child = False
                    self.server_manager.set_auto_stop_enabled(True)


def _is_pid_running(pid: Optional[int]) -> bool:
    """Return True if the given PID is alive."""
    if not pid:
        return False
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False


def main():
    """Entry point for Visual Scenario Editor."""
    parser = argparse.ArgumentParser(description="Visual Scenario Editor", add_help=True)
    parser.add_argument("--debug", action="store_true", help="Enable debug logs.")
    parser.add_argument("--port", type=int, help="CARLA port (default 2000).")
    parser.add_argument("--carla-path", dest="carla_path", help="Path to CarlaUE4.sh.")
    # Legacy positional args (carla_path, port) preserved for compatibility.
    parser.add_argument("legacy_carla_path", nargs="?", default=None)
    parser.add_argument("legacy_port", nargs="?", type=int, default=None)

    args = parser.parse_args()

    # Configure logging based on --debug flag
    if args.debug:
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        logger.info("Debug logging enabled via --debug flag")
    else:
        # Only show warnings and errors by default
        logging.basicConfig(
            level=logging.WARNING,
            format='%(name)s - %(levelname)s - %(message)s'
        )

    carla_path = args.carla_path or args.legacy_carla_path
    port = args.port if args.port is not None else (args.legacy_port if args.legacy_port is not None else 2000)

    print("Visual Scenario Editor for CARLA")
    print("================================")
    print("Shift+Right Click to move camera to position")
    print("ESC exits during loading, cancels operations after loading")
    print("Alt+F4 or close button (X) to exit with confirmation")

    try:
        editor = VisualScenarioEditor(carla_path, port, debug=args.debug)
        editor.run()
    except KeyboardInterrupt:
        print("\nExiting...")
        return 0
    except Exception as e:
        print(f"Error: {e}")
        traceback.print_exc()
        return 1

    return 0

# Entry point for script execution
if __name__ == "__main__":
    sys.exit(main())
